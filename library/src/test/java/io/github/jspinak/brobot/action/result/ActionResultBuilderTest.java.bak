package io.github.jspinak.brobot.action.result;

import io.github.jspinak.brobot.action.ActionConfig;
import io.github.jspinak.brobot.action.ActionResult;
import io.github.jspinak.brobot.action.basic.find.PatternFindOptions;
import io.github.jspinak.brobot.model.element.Location;
import io.github.jspinak.brobot.model.element.Movement;
import io.github.jspinak.brobot.model.element.Region;
import io.github.jspinak.brobot.model.match.Match;
import io.github.jspinak.brobot.test.BrobotTestBase;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.time.Duration;
import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@DisplayName("ActionResultBuilder Tests")
public class ActionResultBuilderTest extends BrobotTestBase {
    
    @Mock
    private ActionConfig mockActionConfig;
    
    @Mock
    private Match mockMatch1;
    
    @Mock
    private Match mockMatch2;
    
    @Mock
    private MatchCollection mockMatchCollection;
    
    @Mock
    private TimingData mockTimingData;
    
    @Mock
    private TextExtractionResult mockTextResult;
    
    @Mock
    private StateTracker mockStateTracker;
    
    @Mock
    private RegionManager mockRegionManager;
    
    @Mock
    private MovementTracker mockMovementTracker;
    
    @Mock
    private ActionAnalysis mockAnalysis;
    
    @Mock
    private ActionMetrics mockMetrics;
    
    @Mock
    private ExecutionHistory mockHistory;
    
    private ActionResultBuilder builder;
    
    @BeforeEach
    @Override
    public void setupTest() {
        super.setupTest();
        MockitoAnnotations.openMocks(this);
        builder = new ActionResultBuilder();
    }
    
    @Nested
    @DisplayName("Basic Properties")
    class BasicProperties {
        
        @Test
        @DisplayName("Build with description")
        public void testWithDescription() {
            String description = "Test action performed";
            
            ActionResult result = builder
                .withDescription(description)
                .build();
            
            assertEquals(description, result.getActionDescription());
        }
        
        @Test
        @DisplayName("Build with success status")
        public void testWithSuccess() {
            ActionResult successResult = builder
                .withSuccess(true)
                .build();
            
            assertTrue(successResult.isSuccess());
            
            ActionResult failureResult = new ActionResultBuilder()
                .withSuccess(false)
                .build();
            
            assertFalse(failureResult.isSuccess());
        }
        
        @Test
        @DisplayName("Build with action config")
        public void testWithActionConfig() {
            PatternFindOptions config = new PatternFindOptions.Builder().build();
            
            ActionResult result = builder
                .withActionConfig(config)
                .build();
            
            assertEquals(config, result.getActionConfig());
        }
        
        @Test
        @DisplayName("Default values when not set")
        public void testDefaultValues() {
            ActionResult result = builder.build();
            
            assertFalse(result.isSuccess());
            assertEquals("", result.getActionDescription());
            assertNull(result.getActionConfig());
            assertNotNull(result.getMatchList());
            assertTrue(result.getMatchList().isEmpty());
        }
    }
    
    @Nested
    @DisplayName("Match Management")
    class MatchManagement {
        
        @Test
        @DisplayName("Add single match")
        public void testWithMatch() {
            ActionResult result = builder
                .withMatch(mockMatch1)
                .build();
            
            assertEquals(1, result.getMatchList().size());
            assertTrue(result.getMatchList().contains(mockMatch1));
        }
        
        @Test
        @DisplayName("Add multiple matches via list")
        public void testWithMatchesList() {
            List<Match> matches = Arrays.asList(mockMatch1, mockMatch2);
            
            ActionResult result = builder
                .withMatches(matches)
                .build();
            
            assertEquals(2, result.getMatchList().size());
            assertTrue(result.getMatchList().contains(mockMatch1));
            assertTrue(result.getMatchList().contains(mockMatch2));
        }
        
        @Test
        @DisplayName("Add match collection")
        public void testWithMatchCollection() {
            when(mockMatchCollection.getAllMatches())
                .thenReturn(Arrays.asList(mockMatch1, mockMatch2));
            
            ActionResult result = builder
                .withMatches(mockMatchCollection)
                .build();
            
            assertNotNull(result.getMatchList());
        }
        
        @Test
        @DisplayName("Handle null match")
        public void testWithNullMatch() {
            ActionResult result = builder
                .withMatch(null)
                .build();
            
            assertTrue(result.getMatchList().isEmpty());
        }
        
        @Test
        @DisplayName("Handle null match list")
        public void testWithNullMatchList() {
            ActionResult result = builder
                .withMatches((List<Match>) null)
                .build();
            
            assertNotNull(result.getMatchList());
            assertTrue(result.getMatchList().isEmpty());
        }
        
        @Test
        @DisplayName("Add matches incrementally")
        public void testIncrementalMatches() {
            ActionResult result = builder
                .withMatch(mockMatch1)
                .withMatch(mockMatch2)
                .withMatches(Arrays.asList(mock(Match.class)))
                .build();
            
            assertEquals(3, result.getMatchList().size());
        }
    }
    
    @Nested
    @DisplayName("Timing Management")
    class TimingManagement {
        
        @Test
        @DisplayName("Set timing data directly")
        public void testWithTimingData() {
            when(mockTimingData.getStartTime()).thenReturn(LocalDateTime.now());
            when(mockTimingData.getTotalDuration()).thenReturn(Duration.ofSeconds(5));
            
            ActionResult result = builder
                .withTiming(mockTimingData)
                .build();
            
            assertNotNull(result.getStartTime());
            assertNotNull(result.getDuration());
        }
        
        @Test
        @DisplayName("Set timing with start and end times")
        public void testWithStartEndTimes() {
            LocalDateTime start = LocalDateTime.now();
            LocalDateTime end = start.plusSeconds(10);
            
            ActionResult result = builder
                .withTiming(start, end)
                .build();
            
            assertEquals(start, result.getStartTime());
            assertEquals(Duration.ofSeconds(10), result.getDuration());
        }
        
        @Test
        @DisplayName("Set timing with only start time")
        public void testWithOnlyStartTime() {
            LocalDateTime start = LocalDateTime.now();
            
            ActionResult result = builder
                .withTiming(start, null)
                .build();
            
            assertEquals(start, result.getStartTime());
        }
        
        @Test
        @DisplayName("Handle null timing data")
        public void testWithNullTimingData() {
            ActionResult result = builder
                .withTiming((TimingData) null)
                .build();
            
            assertNotNull(result.getStartTime());
        }
    }
    
    @Nested
    @DisplayName("Text Extraction")
    class TextExtraction {
        
        @Test
        @DisplayName("Set text extraction result")
        public void testWithTextResult() {
            when(mockTextResult.getAllText()).thenReturn("Extracted text");
            
            ActionResult result = builder
                .withText(mockTextResult)
                .build();
            
            assertNotNull(result.getText());
        }
        
        @Test
        @DisplayName("Set simple text string")
        public void testWithTextString() {
            String text = "Simple text";
            
            ActionResult result = builder
                .withText(text)
                .build();
            
            assertNotNull(result.getText());
            assertEquals(text, result.getText().toString());
        }
        
        @Test
        @DisplayName("Handle null text")
        public void testWithNullText() {
            ActionResult result = builder
                .withText((String) null)
                .build();
            
            assertNotNull(result.getText());
        }
    }
    
    @Nested
    @DisplayName("State Management")
    class StateManagement {
        
        @Test
        @DisplayName("Set state tracker")
        public void testWithStateTracker() {
            when(mockStateTracker.getActiveStates())
                .thenReturn(Set.of("State1", "State2"));
            
            ActionResult result = builder
                .withStates(mockStateTracker)
                .build();
            
            assertNotNull(result.getActiveStates());
            assertEquals(2, result.getActiveStates().size());
        }
        
        @Test
        @DisplayName("Add active states")
        public void testWithActiveStates() {
            Set<String> states = Set.of("MainState", "DialogState");
            
            ActionResult result = builder
                .withActiveStates(states)
                .build();
            
            assertEquals(states, result.getActiveStates());
        }
        
        @Test
        @DisplayName("Add single active state")
        public void testWithSingleActiveState() {
            ActionResult result = builder
                .withActiveState("TestState")
                .build();
            
            assertTrue(result.getActiveStates().contains("TestState"));
        }
    }
    
    @Nested
    @DisplayName("Region Management")
    class RegionManagementTests {
        
        @Test
        @DisplayName("Set region manager")
        public void testWithRegionManager() {
            Region region = new Region(10, 10, 100, 100);
            when(mockRegionManager.getSearchRegions())
                .thenReturn(Arrays.asList(region));
            
            ActionResult result = builder
                .withRegions(mockRegionManager)
                .build();
            
            assertNotNull(result.getSearchRegions());
            assertFalse(result.getSearchRegions().isEmpty());
        }
        
        @Test
        @DisplayName("Add search regions")
        public void testWithSearchRegions() {
            List<Region> regions = Arrays.asList(
                new Region(0, 0, 50, 50),
                new Region(50, 50, 100, 100)
            );
            
            ActionResult result = builder
                .withSearchRegions(regions)
                .build();
            
            assertEquals(2, result.getSearchRegions().size());
        }
    }
    
    @Nested
    @DisplayName("Movement Tracking")
    class MovementTracking {
        
        @Test
        @DisplayName("Set movement tracker")
        public void testWithMovementTracker() {
            Movement movement = mock(Movement.class);
            when(mockMovementTracker.getMovements())
                .thenReturn(Arrays.asList(movement));
            
            ActionResult result = builder
                .withMovements(mockMovementTracker)
                .build();
            
            assertNotNull(result.getMovements());
            assertEquals(1, result.getMovements().size());
        }
        
        @Test
        @DisplayName("Add movements list")
        public void testWithMovementsList() {
            List<Movement> movements = Arrays.asList(
                mock(Movement.class),
                mock(Movement.class)
            );
            
            ActionResult result = builder
                .withMovements(movements)
                .build();
            
            assertEquals(2, result.getMovements().size());
        }
    }
    
    @Nested
    @DisplayName("Complex Building Scenarios")
    class ComplexBuildingScenarios {
        
        @Test
        @DisplayName("Build complete successful action result")
        public void testBuildCompleteSuccessResult() {
            LocalDateTime startTime = LocalDateTime.now();
            LocalDateTime endTime = startTime.plusSeconds(3);
            PatternFindOptions config = new PatternFindOptions.Builder().build();
            
            ActionResult result = builder
                .withDescription("Find and click button")
                .withSuccess(true)
                .withActionConfig(config)
                .withMatch(mockMatch1)
                .withMatch(mockMatch2)
                .withTiming(startTime, endTime)
                .withText("Button text")
                .withActiveState("MainScreen")
                .build();
            
            assertTrue(result.isSuccess());
            assertEquals("Find and click button", result.getActionDescription());
            assertEquals(config, result.getActionConfig());
            assertEquals(2, result.getMatchList().size());
            assertEquals(startTime, result.getStartTime());
            assertEquals(Duration.ofSeconds(3), result.getDuration());
            assertNotNull(result.getText());
            assertTrue(result.getActiveStates().contains("MainScreen"));
        }
        
        @Test
        @DisplayName("Build failure result with minimal data")
        public void testBuildFailureResult() {
            ActionResult result = builder
                .withDescription("Failed to find element")
                .withSuccess(false)
                .withTiming(LocalDateTime.now(), LocalDateTime.now().plusSeconds(5))
                .build();
            
            assertFalse(result.isSuccess());
            assertEquals("Failed to find element", result.getActionDescription());
            assertTrue(result.getMatchList().isEmpty());
            assertEquals(Duration.ofSeconds(5), result.getDuration());
        }
        
        @Test
        @DisplayName("Build with all components")
        public void testBuildWithAllComponents() {
            ActionResult result = builder
                .withDescription("Complex action")
                .withSuccess(true)
                .withActionConfig(mockActionConfig)
                .withMatches(mockMatchCollection)
                .withTiming(mockTimingData)
                .withText(mockTextResult)
                .withStates(mockStateTracker)
                .withRegions(mockRegionManager)
                .withMovements(mockMovementTracker)
                .withAnalysis(mockAnalysis)
                .withMetrics(mockMetrics)
                .withHistory(mockHistory)
                .build();
            
            assertNotNull(result);
            assertTrue(result.isSuccess());
            assertEquals("Complex action", result.getActionDescription());
        }
    }
    
    @Nested
    @DisplayName("Builder Chaining")
    class BuilderChaining {
        
        @Test
        @DisplayName("All methods return builder for chaining")
        public void testMethodChaining() {
            ActionResultBuilder returnedBuilder = builder
                .withDescription("test")
                .withSuccess(true)
                .withActionConfig(mockActionConfig)
                .withMatch(mockMatch1)
                .withTiming(LocalDateTime.now(), LocalDateTime.now())
                .withText("text")
                .withActiveState("state")
                .withSearchRegions(Collections.emptyList())
                .withMovements(Collections.emptyList());
            
            assertSame(builder, returnedBuilder);
        }
        
        @ParameterizedTest
        @ValueSource(booleans = {true, false})
        @DisplayName("Success status affects result")
        public void testSuccessStatusEffect(boolean success) {
            ActionResult result = builder
                .withSuccess(success)
                .build();
            
            assertEquals(success, result.isSuccess());
        }
    }
    
    @Nested
    @DisplayName("Edge Cases")
    class EdgeCases {
        
        @Test
        @DisplayName("Build empty result")
        public void testBuildEmptyResult() {
            ActionResult result = new ActionResultBuilder().build();
            
            assertNotNull(result);
            assertFalse(result.isSuccess());
            assertEquals("", result.getActionDescription());
            assertTrue(result.getMatchList().isEmpty());
            assertNotNull(result.getActiveStates());
            assertNotNull(result.getMovements());
        }
        
        @Test
        @DisplayName("Override values with multiple calls")
        public void testOverrideValues() {
            ActionResult result = builder
                .withDescription("First")
                .withDescription("Second")
                .withSuccess(false)
                .withSuccess(true)
                .build();
            
            assertEquals("Second", result.getActionDescription());
            assertTrue(result.isSuccess());
        }
        
        @Test
        @DisplayName("Handle all null inputs")
        public void testAllNullInputs() {
            ActionResult result = builder
                .withDescription(null)
                .withActionConfig(null)
                .withMatches((List<Match>) null)
                .withTiming((TimingData) null)
                .withText((String) null)
                .withActiveStates(null)
                .withSearchRegions(null)
                .withMovements((List<Movement>) null)
                .build();
            
            assertNotNull(result);
            assertNotNull(result.getMatchList());
            assertNotNull(result.getActiveStates());
            assertNotNull(result.getMovements());
        }
    }
}
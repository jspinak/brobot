package io.github.jspinak.brobot.util.string;

import io.github.jspinak.brobot.test.BrobotTestBase;
import org.junit.jupiter.api.*;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.Arrays;
import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Unit tests for StringSimilarity utility class.
 * Tests various string comparison and similarity algorithms.
 */
@ExtendWith(MockitoExtension.class)
class StringSimilarityTest extends BrobotTestBase {
    
    private StringSimilarity similarity;
    
    @BeforeEach
    @Override
    public void setupTest() {
        super.setupTest();
        similarity = new StringSimilarity();
    }
    
    @Nested
    @DisplayName("Levenshtein Distance Tests")
    class LevenshteinDistanceTests {
        
        @Test
        @DisplayName("Should calculate zero distance for identical strings")
        void shouldCalculateZeroDistanceForIdenticalStrings() {
            // Given
            String str1 = "hello";
            String str2 = "hello";
            
            // When
            int distance = similarity.levenshteinDistance(str1, str2);
            
            // Then
            assertEquals(0, distance);
        }
        
        @Test
        @DisplayName("Should calculate distance for different strings")
        void shouldCalculateDistanceForDifferentStrings() {
            // Given
            String str1 = "kitten";
            String str2 = "sitting";
            
            // When
            int distance = similarity.levenshteinDistance(str1, str2);
            
            // Then
            assertEquals(3, distance); // Classic example
        }
        
        @Test
        @DisplayName("Should handle empty strings")
        void shouldHandleEmptyStrings() {
            // Given
            String str1 = "";
            String str2 = "hello";
            
            // When
            int distance = similarity.levenshteinDistance(str1, str2);
            
            // Then
            assertEquals(5, distance); // Length of non-empty string
        }
        
        @Test
        @DisplayName("Should handle null strings")
        void shouldHandleNullStrings() {
            // When/Then
            assertThrows(NullPointerException.class, () -> 
                similarity.levenshteinDistance(null, "test"));
        }
    }
    
    @Nested
    @DisplayName("Jaro-Winkler Distance Tests")
    class JaroWinklerDistanceTests {
        
        @Test
        @DisplayName("Should calculate perfect similarity for identical strings")
        void shouldCalculatePerfectSimilarityForIdenticalStrings() {
            // Given
            String str1 = "MARTHA";
            String str2 = "MARTHA";
            
            // When
            double similarity = this.similarity.jaroWinklerSimilarity(str1, str2);
            
            // Then
            assertEquals(1.0, similarity, 0.001);
        }
        
        @Test
        @DisplayName("Should calculate similarity for similar strings")
        void shouldCalculateSimilarityForSimilarStrings() {
            // Given
            String str1 = "MARTHA";
            String str2 = "MARHTA";
            
            // When
            double similarity = this.similarity.jaroWinklerSimilarity(str1, str2);
            
            // Then
            assertTrue(similarity > 0.9); // Very similar
        }
        
        @Test
        @DisplayName("Should calculate low similarity for different strings")
        void shouldCalculateLowSimilarityForDifferentStrings() {
            // Given
            String str1 = "DIXON";
            String str2 = "DICKSONX";
            
            // When
            double similarity = this.similarity.jaroWinklerSimilarity(str1, str2);
            
            // Then
            assertTrue(similarity > 0.7 && similarity < 0.9);
        }
        
        @Test
        @DisplayName("Should handle case sensitivity")
        void shouldHandleCaseSensitivity() {
            // Given
            String str1 = "hello";
            String str2 = "HELLO";
            
            // When
            double caseSensitive = similarity.jaroWinklerSimilarity(str1, str2);
            double caseInsensitive = similarity.jaroWinklerSimilarityIgnoreCase(str1, str2);
            
            // Then
            assertTrue(caseSensitive < caseInsensitive);
            assertEquals(1.0, caseInsensitive, 0.001);
        }
    }
    
    @Nested
    @DisplayName("Cosine Similarity Tests")
    class CosineSimilarityTests {
        
        @Test
        @DisplayName("Should calculate cosine similarity for text")
        void shouldCalculateCosineSimilarityForText() {
            // Given
            String text1 = "The quick brown fox jumps over the lazy dog";
            String text2 = "The quick brown dog jumps over the lazy fox";
            
            // When
            double similarity = this.similarity.cosineSimilarity(text1, text2);
            
            // Then
            assertTrue(similarity > 0.8); // Very similar texts
            assertTrue(similarity < 1.0); // Not identical
        }
        
        @Test
        @DisplayName("Should return 1.0 for identical texts")
        void shouldReturnOneForIdenticalTexts() {
            // Given
            String text = "This is a test sentence";
            
            // When
            double similarity = this.similarity.cosineSimilarity(text, text);
            
            // Then
            assertEquals(1.0, similarity, 0.001);
        }
        
        @Test
        @DisplayName("Should handle completely different texts")
        void shouldHandleCompletelyDifferentTexts() {
            // Given
            String text1 = "apple orange banana";
            String text2 = "car truck motorcycle";
            
            // When
            double similarity = this.similarity.cosineSimilarity(text1, text2);
            
            // Then
            assertEquals(0.0, similarity, 0.001);
        }
    }
    
    @Nested
    @DisplayName("Fuzzy Matching Tests")
    class FuzzyMatchingTests {
        
        @Test
        @DisplayName("Should find best fuzzy match")
        void shouldFindBestFuzzyMatch() {
            // Given
            String target = "hello";
            List<String> candidates = Arrays.asList(
                "helo",
                "hello world",
                "hi",
                "yellow"
            );
            
            // When
            String bestMatch = similarity.findBestFuzzyMatch(target, candidates);
            
            // Then
            assertEquals("helo", bestMatch); // Closest match
        }
        
        @Test
        @DisplayName("Should find all matches above threshold")
        void shouldFindAllMatchesAboveThreshold() {
            // Given
            String target = "test";
            List<String> candidates = Arrays.asList(
                "test",
                "tests",
                "testing",
                "best",
                "rest",
                "unrelated"
            );
            
            // When
            List<String> matches = similarity.findFuzzyMatches(target, candidates, 0.7);
            
            // Then
            assertTrue(matches.contains("test"));
            assertTrue(matches.contains("tests"));
            assertTrue(matches.contains("best"));
            assertTrue(matches.contains("rest"));
            assertFalse(matches.contains("unrelated"));
        }
        
        @Test
        @DisplayName("Should rank matches by similarity")
        void shouldRankMatchesBySimilarity() {
            // Given
            String target = "hello";
            List<String> candidates = Arrays.asList(
                "yellow",
                "helo",
                "hello!",
                "hi"
            );
            
            // When
            List<String> ranked = similarity.rankBySimilarity(target, candidates);
            
            // Then
            assertEquals("hello!", ranked.get(0)); // Most similar
            assertEquals("helo", ranked.get(1));
        }
    }
    
    @Nested
    @DisplayName("N-gram Similarity Tests")
    class NGramSimilarityTests {
        
        @Test
        @DisplayName("Should calculate bigram similarity")
        void shouldCalculateBigramSimilarity() {
            // Given
            String str1 = "hello";
            String str2 = "hallo";
            
            // When
            double similarity = this.similarity.ngramSimilarity(str1, str2, 2);
            
            // Then
            // Share "ll" and "lo" bigrams
            assertTrue(similarity > 0.3);
        }
        
        @Test
        @DisplayName("Should calculate trigram similarity")
        void shouldCalculateTrigramSimilarity() {
            // Given
            String str1 = "testing";
            String str2 = "resting";
            
            // When
            double similarity = this.similarity.ngramSimilarity(str1, str2, 3);
            
            // Then
            // Share "sti", "tin", "ing" trigrams
            assertTrue(similarity > 0.5);
        }
        
        @Test
        @DisplayName("Should handle short strings")
        void shouldHandleShortStrings() {
            // Given
            String str1 = "ab";
            String str2 = "cd";
            
            // When
            double similarity = this.similarity.ngramSimilarity(str1, str2, 3);
            
            // Then
            assertEquals(0.0, similarity); // No trigrams possible
        }
    }
    
    @Nested
    @DisplayName("Phonetic Similarity Tests")
    class PhoneticSimilarityTests {
        
        @Test
        @DisplayName("Should detect phonetically similar words")
        void shouldDetectPhoneticallySimilarWords() {
            // Given
            String word1 = "smith";
            String word2 = "smythe";
            
            // When
            boolean similar = similarity.arePhoneticallySimilar(word1, word2);
            
            // Then
            assertTrue(similar);
        }
        
        @Test
        @DisplayName("Should generate soundex codes")
        void shouldGenerateSoundexCodes() {
            // Given
            String name1 = "Robert";
            String name2 = "Rupert";
            
            // When
            String soundex1 = similarity.soundex(name1);
            String soundex2 = similarity.soundex(name2);
            
            // Then
            assertEquals(soundex1, soundex2); // Same soundex code
        }
        
        @Test
        @DisplayName("Should use metaphone algorithm")
        void shouldUseMetaphoneAlgorithm() {
            // Given
            String word1 = "programming";
            String word2 = "programing";
            
            // When
            String metaphone1 = similarity.metaphone(word1);
            String metaphone2 = similarity.metaphone(word2);
            
            // Then
            assertEquals(metaphone1, metaphone2);
        }
    }
    
    @Nested
    @DisplayName("Token-based Similarity Tests")
    class TokenBasedSimilarityTests {
        
        @Test
        @DisplayName("Should calculate Jaccard similarity")
        void shouldCalculateJaccardSimilarity() {
            // Given
            String text1 = "the quick brown fox";
            String text2 = "the slow brown fox";
            
            // When
            double similarity = this.similarity.jaccardSimilarity(text1, text2);
            
            // Then
            assertEquals(0.6, similarity, 0.001); // 3 common out of 5 total unique
        }
        
        @Test
        @DisplayName("Should calculate Dice coefficient")
        void shouldCalculateDiceCoefficient() {
            // Given
            String text1 = "night knight";
            String text2 = "knight night";
            
            // When
            double coefficient = similarity.diceCoefficient(text1, text2);
            
            // Then
            assertEquals(1.0, coefficient, 0.001); // Same tokens
        }
        
        @Test
        @DisplayName("Should handle token order independence")
        void shouldHandleTokenOrderIndependence() {
            // Given
            String text1 = "apple banana orange";
            String text2 = "orange apple banana";
            
            // When
            double jaccard = similarity.jaccardSimilarity(text1, text2);
            double dice = similarity.diceCoefficient(text1, text2);
            
            // Then
            assertEquals(1.0, jaccard, 0.001);
            assertEquals(1.0, dice, 0.001);
        }
    }
    
    @Nested
    @DisplayName("Performance Tests")
    class PerformanceTests {
        
        @Test
        @DisplayName("Should cache similarity calculations")
        void shouldCacheSimilarityCalculations() {
            // Given
            String str1 = "performance test string";
            String str2 = "performance test strings";
            
            // When - first calculation
            long start1 = System.nanoTime();
            double similarity1 = similarity.cachedLevenshteinSimilarity(str1, str2);
            long time1 = System.nanoTime() - start1;
            
            // When - second calculation (should be cached)
            long start2 = System.nanoTime();
            double similarity2 = similarity.cachedLevenshteinSimilarity(str1, str2);
            long time2 = System.nanoTime() - start2;
            
            // Then
            assertEquals(similarity1, similarity2);
            assertTrue(time2 < time1); // Cached should be faster
        }
        
        @Test
        @DisplayName("Should handle large string comparisons efficiently")
        void shouldHandleLargeStringComparisonsEfficiently() {
            // Given
            StringBuilder sb1 = new StringBuilder();
            StringBuilder sb2 = new StringBuilder();
            for (int i = 0; i < 1000; i++) {
                sb1.append("test ");
                sb2.append(i % 2 == 0 ? "test " : "best ");
            }
            
            // When
            long start = System.currentTimeMillis();
            double similarity = this.similarity.cosineSimilarity(sb1.toString(), sb2.toString());
            long duration = System.currentTimeMillis() - start;
            
            // Then
            assertNotNull(similarity);
            assertTrue(duration < 1000); // Should complete within 1 second
        }
    }
}
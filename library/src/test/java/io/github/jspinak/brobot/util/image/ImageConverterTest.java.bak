package io.github.jspinak.brobot.util.image.core;

import io.github.jspinak.brobot.test.BrobotTestBase;
import org.junit.jupiter.api.*;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.opencv.core.Mat;
import org.opencv.core.CvType;
import org.opencv.core.Size;
import org.sikuli.script.Image;
import org.sikuli.script.Pattern;

import java.awt.image.BufferedImage;
import java.io.File;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Base64;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

/**
 * Unit tests for ImageConverter utility class.
 * Tests conversions between different image formats.
 */
@ExtendWith(MockitoExtension.class)
class ImageConverterTest extends BrobotTestBase {
    
    @Mock
    private BufferedImage mockBufferedImage;
    
    @Mock
    private Image mockSikuliImage;
    
    @Mock
    private Pattern mockPattern;
    
    private ImageConverter converter;
    
    @BeforeEach
    @Override
    public void setupTest() {
        super.setupTest();
        converter = new ImageConverter();
    }
    
    @Nested
    @DisplayName("BufferedImage Conversion Tests")
    class BufferedImageConversionTests {
        
        @Test
        @DisplayName("Should convert BufferedImage to Mat")
        void shouldConvertBufferedImageToMat() {
            // Given
            BufferedImage image = new BufferedImage(100, 100, BufferedImage.TYPE_INT_RGB);
            
            // When
            Mat mat = converter.bufferedImageToMat(image);
            
            // Then
            assertNotNull(mat);
            assertEquals(100, mat.rows());
            assertEquals(100, mat.cols());
        }
        
        @Test
        @DisplayName("Should convert Mat to BufferedImage")
        void shouldConvertMatToBufferedImage() {
            // Given
            Mat mat = new Mat(100, 100, CvType.CV_8UC3);
            
            // When
            BufferedImage image = converter.matToBufferedImage(mat);
            
            // Then
            assertNotNull(image);
            assertEquals(100, image.getWidth());
            assertEquals(100, image.getHeight());
        }
        
        @Test
        @DisplayName("Should handle grayscale BufferedImage")
        void shouldHandleGrayscaleBufferedImage() {
            // Given
            BufferedImage grayImage = new BufferedImage(50, 50, BufferedImage.TYPE_BYTE_GRAY);
            
            // When
            Mat mat = converter.bufferedImageToMat(grayImage);
            
            // Then
            assertNotNull(mat);
            assertEquals(1, mat.channels()); // Grayscale has 1 channel
        }
        
        @Test
        @DisplayName("Should preserve alpha channel")
        void shouldPreserveAlphaChannel() {
            // Given
            BufferedImage imageWithAlpha = new BufferedImage(100, 100, BufferedImage.TYPE_INT_ARGB);
            
            // When
            Mat mat = converter.bufferedImageToMat(imageWithAlpha);
            BufferedImage converted = converter.matToBufferedImage(mat);
            
            // Then
            assertEquals(BufferedImage.TYPE_INT_ARGB, converted.getType());
        }
    }
    
    @Nested
    @DisplayName("Sikuli Image Conversion Tests")
    class SikuliImageConversionTests {
        
        @Test
        @DisplayName("Should convert Sikuli Image to BufferedImage")
        void shouldConvertSikuliImageToBufferedImage() {
            // Given
            when(mockSikuliImage.get()).thenReturn(mockBufferedImage);
            when(mockBufferedImage.getWidth()).thenReturn(200);
            when(mockBufferedImage.getHeight()).thenReturn(150);
            
            // When
            BufferedImage result = converter.sikuliImageToBufferedImage(mockSikuliImage);
            
            // Then
            assertNotNull(result);
            assertEquals(mockBufferedImage, result);
        }
        
        @Test
        @DisplayName("Should convert BufferedImage to Sikuli Image")
        void shouldConvertBufferedImageToSikuliImage() {
            // Given
            BufferedImage bufferedImage = new BufferedImage(100, 100, BufferedImage.TYPE_INT_RGB);
            
            // When
            Image sikuliImage = converter.bufferedImageToSikuliImage(bufferedImage);
            
            // Then
            assertNotNull(sikuliImage);
        }
        
        @Test
        @DisplayName("Should convert Pattern to BufferedImage")
        void shouldConvertPatternToBufferedImage() {
            // Given
            when(mockPattern.getImage()).thenReturn(mockSikuliImage);
            when(mockSikuliImage.get()).thenReturn(mockBufferedImage);
            
            // When
            BufferedImage result = converter.patternToBufferedImage(mockPattern);
            
            // Then
            assertNotNull(result);
            assertEquals(mockBufferedImage, result);
        }
        
        @Test
        @DisplayName("Should handle null Sikuli Image")
        void shouldHandleNullSikuliImage() {
            // When/Then
            assertThrows(NullPointerException.class, () ->
                converter.sikuliImageToBufferedImage(null));
        }
    }
    
    @Nested
    @DisplayName("File-based Conversion Tests")
    class FileBasedConversionTests {
        
        @Test
        @DisplayName("Should load image from file path")
        void shouldLoadImageFromFilePath() {
            // Given
            Path imagePath = Paths.get("test-image.png");
            
            // When - would need actual file
            // BufferedImage image = converter.loadImage(imagePath);
            
            // Then
            // assertNotNull(image);
        }
        
        @Test
        @DisplayName("Should save image to file")
        void shouldSaveImageToFile() {
            // Given
            BufferedImage image = new BufferedImage(50, 50, BufferedImage.TYPE_INT_RGB);
            Path outputPath = Paths.get("output.png");
            
            // When
            boolean saved = converter.saveImage(image, outputPath);
            
            // Then - in mock mode, may not actually save
            assertNotNull(saved);
        }
        
        @Test
        @DisplayName("Should detect image format from file extension")
        void shouldDetectImageFormatFromFileExtension() {
            // Given
            String jpgFile = "image.jpg";
            String pngFile = "image.png";
            String bmpFile = "image.bmp";
            
            // When
            String jpgFormat = converter.getImageFormat(jpgFile);
            String pngFormat = converter.getImageFormat(pngFile);
            String bmpFormat = converter.getImageFormat(bmpFile);
            
            // Then
            assertEquals("jpg", jpgFormat);
            assertEquals("png", pngFormat);
            assertEquals("bmp", bmpFormat);
        }
    }
    
    @Nested
    @DisplayName("Base64 Conversion Tests")
    class Base64ConversionTests {
        
        @Test
        @DisplayName("Should encode image to Base64")
        void shouldEncodeImageToBase64() {
            // Given
            BufferedImage image = new BufferedImage(10, 10, BufferedImage.TYPE_INT_RGB);
            
            // When
            String base64 = converter.imageToBase64(image);
            
            // Then
            assertNotNull(base64);
            assertFalse(base64.isEmpty());
            // Should be valid Base64
            assertDoesNotThrow(() -> Base64.getDecoder().decode(base64));
        }
        
        @Test
        @DisplayName("Should decode Base64 to image")
        void shouldDecodeBase64ToImage() {
            // Given
            BufferedImage original = new BufferedImage(10, 10, BufferedImage.TYPE_INT_RGB);
            String base64 = converter.imageToBase64(original);
            
            // When
            BufferedImage decoded = converter.base64ToImage(base64);
            
            // Then
            assertNotNull(decoded);
            assertEquals(original.getWidth(), decoded.getWidth());
            assertEquals(original.getHeight(), decoded.getHeight());
        }
        
        @Test
        @DisplayName("Should handle data URI format")
        void shouldHandleDataUriFormat() {
            // Given
            BufferedImage image = new BufferedImage(10, 10, BufferedImage.TYPE_INT_RGB);
            
            // When
            String dataUri = converter.imageToDataUri(image, "png");
            
            // Then
            assertTrue(dataUri.startsWith("data:image/png;base64,"));
        }
    }
    
    @Nested
    @DisplayName("Image Type Conversion Tests")
    class ImageTypeConversionTests {
        
        @Test
        @DisplayName("Should convert RGB to BGR")
        void shouldConvertRgbToBgr() {
            // Given
            BufferedImage rgbImage = new BufferedImage(100, 100, BufferedImage.TYPE_INT_RGB);
            
            // When
            BufferedImage bgrImage = converter.rgbToBgr(rgbImage);
            
            // Then
            assertNotNull(bgrImage);
            assertEquals(rgbImage.getWidth(), bgrImage.getWidth());
            assertEquals(rgbImage.getHeight(), bgrImage.getHeight());
        }
        
        @Test
        @DisplayName("Should convert to grayscale")
        void shouldConvertToGrayscale() {
            // Given
            BufferedImage colorImage = new BufferedImage(100, 100, BufferedImage.TYPE_INT_RGB);
            
            // When
            BufferedImage grayImage = converter.toGrayscale(colorImage);
            
            // Then
            assertNotNull(grayImage);
            assertEquals(BufferedImage.TYPE_BYTE_GRAY, grayImage.getType());
        }
        
        @Test
        @DisplayName("Should convert to binary")
        void shouldConvertToBinary() {
            // Given
            BufferedImage image = new BufferedImage(100, 100, BufferedImage.TYPE_INT_RGB);
            
            // When
            BufferedImage binary = converter.toBinary(image, 128);
            
            // Then
            assertNotNull(binary);
            // Check pixels are only black or white
            for (int x = 0; x < 10; x++) {
                for (int y = 0; y < 10; y++) {
                    int rgb = binary.getRGB(x, y);
                    assertTrue(rgb == 0xFF000000 || rgb == 0xFFFFFFFF);
                }
            }
        }
    }
    
    @Nested
    @DisplayName("Mat Type Conversion Tests")
    class MatTypeConversionTests {
        
        @Test
        @DisplayName("Should convert Mat types")
        void shouldConvertMatTypes() {
            // Given
            Mat mat8U = new Mat(100, 100, CvType.CV_8UC3);
            
            // When
            Mat mat32F = converter.convertMatType(mat8U, CvType.CV_32FC3);
            
            // Then
            assertNotNull(mat32F);
            assertEquals(CvType.CV_32FC3, mat32F.type());
        }
        
        @Test
        @DisplayName("Should normalize Mat values")
        void shouldNormalizeMatValues() {
            // Given
            Mat mat = new Mat(100, 100, CvType.CV_8UC1);
            
            // When
            Mat normalized = converter.normalizeMat(mat, 0, 1);
            
            // Then
            assertNotNull(normalized);
            // Values should be between 0 and 1
        }
        
        @Test
        @DisplayName("Should resize Mat")
        void shouldResizeMat() {
            // Given
            Mat original = new Mat(100, 100, CvType.CV_8UC3);
            
            // When
            Mat resized = converter.resizeMat(original, new Size(50, 50));
            
            // Then
            assertNotNull(resized);
            assertEquals(50, resized.rows());
            assertEquals(50, resized.cols());
        }
    }
    
    @Nested
    @DisplayName("Batch Conversion Tests")
    class BatchConversionTests {
        
        @Test
        @DisplayName("Should convert multiple images in batch")
        void shouldConvertMultipleImagesInBatch() {
            // Given
            BufferedImage[] images = new BufferedImage[5];
            for (int i = 0; i < 5; i++) {
                images[i] = new BufferedImage(50, 50, BufferedImage.TYPE_INT_RGB);
            }
            
            // When
            Mat[] mats = converter.batchConvertToMat(images);
            
            // Then
            assertEquals(5, mats.length);
            for (Mat mat : mats) {
                assertNotNull(mat);
            }
        }
        
        @Test
        @DisplayName("Should handle parallel conversion")
        void shouldHandleParallelConversion() {
            // Given
            BufferedImage[] images = new BufferedImage[10];
            for (int i = 0; i < 10; i++) {
                images[i] = new BufferedImage(100, 100, BufferedImage.TYPE_INT_RGB);
            }
            
            // When
            long startTime = System.currentTimeMillis();
            Mat[] mats = converter.parallelBatchConvert(images);
            long duration = System.currentTimeMillis() - startTime;
            
            // Then
            assertEquals(10, mats.length);
            // Parallel should be reasonably fast
            assertTrue(duration < 5000);
        }
    }
}
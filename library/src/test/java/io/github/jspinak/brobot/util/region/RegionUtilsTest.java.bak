package io.github.jspinak.brobot.util.region;

import io.github.jspinak.brobot.model.element.Location;
import io.github.jspinak.brobot.model.element.Region;
import io.github.jspinak.brobot.model.element.SearchRegions;
import io.github.jspinak.brobot.test.BrobotTestBase;
import org.junit.jupiter.api.*;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.Arrays;
import java.util.List;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Unit tests for RegionUtils utility class.
 * Tests region manipulation, intersection, and transformation operations.
 */
@ExtendWith(MockitoExtension.class)
class RegionUtilsTest extends BrobotTestBase {
    
    private RegionUtils regionUtils;
    
    @BeforeEach
    @Override
    public void setupTest() {
        super.setupTest();
        regionUtils = new RegionUtils();
    }
    
    @Nested
    @DisplayName("Region Intersection Tests")
    class RegionIntersectionTests {
        
        @Test
        @DisplayName("Should detect overlapping regions")
        void shouldDetectOverlappingRegions() {
            // Given
            Region region1 = new Region(0, 0, 100, 100);
            Region region2 = new Region(50, 50, 100, 100);
            
            // When
            boolean overlaps = regionUtils.doRegionsOverlap(region1, region2);
            
            // Then
            assertTrue(overlaps);
        }
        
        @Test
        @DisplayName("Should detect non-overlapping regions")
        void shouldDetectNonOverlappingRegions() {
            // Given
            Region region1 = new Region(0, 0, 50, 50);
            Region region2 = new Region(100, 100, 50, 50);
            
            // When
            boolean overlaps = regionUtils.doRegionsOverlap(region1, region2);
            
            // Then
            assertFalse(overlaps);
        }
        
        @Test
        @DisplayName("Should calculate intersection area")
        void shouldCalculateIntersectionArea() {
            // Given
            Region region1 = new Region(0, 0, 100, 100);
            Region region2 = new Region(50, 50, 100, 100);
            
            // When
            Optional<Region> intersection = regionUtils.getIntersection(region1, region2);
            
            // Then
            assertTrue(intersection.isPresent());
            Region intersect = intersection.get();
            assertEquals(50, intersect.getX());
            assertEquals(50, intersect.getY());
            assertEquals(50, intersect.getW());
            assertEquals(50, intersect.getH());
        }
        
        @Test
        @DisplayName("Should return empty for non-intersecting regions")
        void shouldReturnEmptyForNonIntersectingRegions() {
            // Given
            Region region1 = new Region(0, 0, 50, 50);
            Region region2 = new Region(100, 100, 50, 50);
            
            // When
            Optional<Region> intersection = regionUtils.getIntersection(region1, region2);
            
            // Then
            assertFalse(intersection.isPresent());
        }
        
        @Test
        @DisplayName("Should handle touching regions")
        void shouldHandleTouchingRegions() {
            // Given
            Region region1 = new Region(0, 0, 50, 50);
            Region region2 = new Region(50, 0, 50, 50);
            
            // When
            boolean overlaps = regionUtils.doRegionsOverlap(region1, region2);
            
            // Then
            assertFalse(overlaps); // Touching but not overlapping
        }
    }
    
    @Nested
    @DisplayName("Region Union Tests")
    class RegionUnionTests {
        
        @Test
        @DisplayName("Should calculate union of regions")
        void shouldCalculateUnionOfRegions() {
            // Given
            Region region1 = new Region(0, 0, 50, 50);
            Region region2 = new Region(25, 25, 50, 50);
            
            // When
            Region union = regionUtils.getUnion(region1, region2);
            
            // Then
            assertEquals(0, union.getX());
            assertEquals(0, union.getY());
            assertEquals(75, union.getW());
            assertEquals(75, union.getH());
        }
        
        @Test
        @DisplayName("Should handle disjoint regions union")
        void shouldHandleDisjointRegionsUnion() {
            // Given
            Region region1 = new Region(0, 0, 50, 50);
            Region region2 = new Region(100, 100, 50, 50);
            
            // When
            Region union = regionUtils.getUnion(region1, region2);
            
            // Then
            assertEquals(0, union.getX());
            assertEquals(0, union.getY());
            assertEquals(150, union.getW());
            assertEquals(150, union.getH());
        }
        
        @Test
        @DisplayName("Should merge multiple regions")
        void shouldMergeMultipleRegions() {
            // Given
            List<Region> regions = Arrays.asList(
                new Region(0, 0, 50, 50),
                new Region(40, 40, 50, 50),
                new Region(80, 80, 50, 50)
            );
            
            // When
            Region merged = regionUtils.mergeRegions(regions);
            
            // Then
            assertEquals(0, merged.getX());
            assertEquals(0, merged.getY());
            assertEquals(130, merged.getW());
            assertEquals(130, merged.getH());
        }
    }
    
    @Nested
    @DisplayName("Region Containment Tests")
    class RegionContainmentTests {
        
        @Test
        @DisplayName("Should detect point in region")
        void shouldDetectPointInRegion() {
            // Given
            Region region = new Region(10, 10, 100, 100);
            Location pointInside = new Location(50, 50);
            Location pointOutside = new Location(5, 5);
            
            // When
            boolean inside = regionUtils.isPointInRegion(pointInside, region);
            boolean outside = regionUtils.isPointInRegion(pointOutside, region);
            
            // Then
            assertTrue(inside);
            assertFalse(outside);
        }
        
        @Test
        @DisplayName("Should detect region containing another")
        void shouldDetectRegionContainingAnother() {
            // Given
            Region outer = new Region(0, 0, 100, 100);
            Region inner = new Region(25, 25, 50, 50);
            
            // When
            boolean contains = regionUtils.contains(outer, inner);
            boolean contained = regionUtils.contains(inner, outer);
            
            // Then
            assertTrue(contains);
            assertFalse(contained);
        }
        
        @Test
        @DisplayName("Should handle boundary points")
        void shouldHandleBoundaryPoints() {
            // Given
            Region region = new Region(10, 10, 100, 100);
            Location topLeft = new Location(10, 10);
            Location bottomRight = new Location(109, 109);
            Location justOutside = new Location(110, 110);
            
            // When
            boolean tlInside = regionUtils.isPointInRegion(topLeft, region);
            boolean brInside = regionUtils.isPointInRegion(bottomRight, region);
            boolean outside = regionUtils.isPointInRegion(justOutside, region);
            
            // Then
            assertTrue(tlInside);
            assertTrue(brInside);
            assertFalse(outside);
        }
    }
    
    @Nested
    @DisplayName("Region Transformation Tests")
    class RegionTransformationTests {
        
        @Test
        @DisplayName("Should scale region")
        void shouldScaleRegion() {
            // Given
            Region original = new Region(10, 10, 100, 100);
            
            // When
            Region scaled = regionUtils.scaleRegion(original, 2.0);
            
            // Then
            assertEquals(20, scaled.getX());
            assertEquals(20, scaled.getY());
            assertEquals(200, scaled.getW());
            assertEquals(200, scaled.getH());
        }
        
        @Test
        @DisplayName("Should translate region")
        void shouldTranslateRegion() {
            // Given
            Region original = new Region(10, 10, 100, 100);
            
            // When
            Region translated = regionUtils.translateRegion(original, 50, -20);
            
            // Then
            assertEquals(60, translated.getX());
            assertEquals(-10, translated.getY());
            assertEquals(100, translated.getW());
            assertEquals(100, translated.getH());
        }
        
        @Test
        @DisplayName("Should expand region")
        void shouldExpandRegion() {
            // Given
            Region original = new Region(50, 50, 100, 100);
            
            // When
            Region expanded = regionUtils.expandRegion(original, 10);
            
            // Then
            assertEquals(40, expanded.getX());
            assertEquals(40, expanded.getY());
            assertEquals(120, expanded.getW());
            assertEquals(120, expanded.getH());
        }
        
        @Test
        @DisplayName("Should shrink region")
        void shouldShrinkRegion() {
            // Given
            Region original = new Region(50, 50, 100, 100);
            
            // When
            Region shrunk = regionUtils.shrinkRegion(original, 10);
            
            // Then
            assertEquals(60, shrunk.getX());
            assertEquals(60, shrunk.getY());
            assertEquals(80, shrunk.getW());
            assertEquals(80, shrunk.getH());
        }
        
        @Test
        @DisplayName("Should rotate region around center")
        void shouldRotateRegionAroundCenter() {
            // Given
            Region original = new Region(0, 0, 100, 50);
            
            // When
            Region rotated = regionUtils.rotateRegion(original, 90);
            
            // Then
            // After 90 degree rotation, width and height swap
            assertEquals(50, rotated.getW());
            assertEquals(100, rotated.getH());
        }
    }
    
    @Nested
    @DisplayName("Region Division Tests")
    class RegionDivisionTests {
        
        @Test
        @DisplayName("Should divide region into grid")
        void shouldDivideRegionIntoGrid() {
            // Given
            Region region = new Region(0, 0, 100, 100);
            
            // When
            List<Region> grid = regionUtils.divideIntoGrid(region, 2, 2);
            
            // Then
            assertEquals(4, grid.size());
            assertEquals(50, grid.get(0).getW());
            assertEquals(50, grid.get(0).getH());
        }
        
        @Test
        @DisplayName("Should split region horizontally")
        void shouldSplitRegionHorizontally() {
            // Given
            Region region = new Region(0, 0, 100, 100);
            
            // When
            List<Region> splits = regionUtils.splitHorizontally(region, 3);
            
            // Then
            assertEquals(3, splits.size());
            assertTrue(splits.stream().allMatch(r -> r.getW() == 100));
        }
        
        @Test
        @DisplayName("Should split region vertically")
        void shouldSplitRegionVertically() {
            // Given
            Region region = new Region(0, 0, 100, 100);
            
            // When
            List<Region> splits = regionUtils.splitVertically(region, 4);
            
            // Then
            assertEquals(4, splits.size());
            assertTrue(splits.stream().allMatch(r -> r.getH() == 100));
        }
        
        @Test
        @DisplayName("Should create quadrants")
        void shouldCreateQuadrants() {
            // Given
            Region region = new Region(0, 0, 100, 100);
            
            // When
            List<Region> quadrants = regionUtils.getQuadrants(region);
            
            // Then
            assertEquals(4, quadrants.size());
            // Top-left quadrant
            assertEquals(0, quadrants.get(0).getX());
            assertEquals(0, quadrants.get(0).getY());
            assertEquals(50, quadrants.get(0).getW());
            assertEquals(50, quadrants.get(0).getH());
        }
    }
    
    @Nested
    @DisplayName("Region Comparison Tests")
    class RegionComparisonTests {
        
        @Test
        @DisplayName("Should calculate IoU (Intersection over Union)")
        void shouldCalculateIoU() {
            // Given
            Region region1 = new Region(0, 0, 100, 100);
            Region region2 = new Region(50, 50, 100, 100);
            
            // When
            double iou = regionUtils.calculateIoU(region1, region2);
            
            // Then
            // Intersection area = 50*50 = 2500
            // Union area = 100*100 + 100*100 - 2500 = 17500
            assertEquals(2500.0 / 17500.0, iou, 0.001);
        }
        
        @Test
        @DisplayName("Should find closest region")
        void shouldFindClosestRegion() {
            // Given
            Region target = new Region(0, 0, 50, 50);
            List<Region> regions = Arrays.asList(
                new Region(100, 100, 50, 50),
                new Region(60, 60, 50, 50),
                new Region(200, 200, 50, 50)
            );
            
            // When
            Region closest = regionUtils.findClosestRegion(target, regions);
            
            // Then
            assertEquals(60, closest.getX());
            assertEquals(60, closest.getY());
        }
        
        @Test
        @DisplayName("Should sort regions by area")
        void shouldSortRegionsByArea() {
            // Given
            List<Region> regions = Arrays.asList(
                new Region(0, 0, 50, 50),   // area = 2500
                new Region(0, 0, 100, 100), // area = 10000
                new Region(0, 0, 25, 25)    // area = 625
            );
            
            // When
            List<Region> sorted = regionUtils.sortByArea(regions);
            
            // Then
            assertEquals(625, sorted.get(0).getArea());
            assertEquals(2500, sorted.get(1).getArea());
            assertEquals(10000, sorted.get(2).getArea());
        }
    }
    
    @Nested
    @DisplayName("SearchRegions Utility Tests")
    class SearchRegionsUtilityTests {
        
        @Test
        @DisplayName("Should create SearchRegions from list")
        void shouldCreateSearchRegionsFromList() {
            // Given
            List<Region> regions = Arrays.asList(
                new Region(0, 0, 50, 50),
                new Region(100, 100, 50, 50)
            );
            
            // When
            SearchRegions searchRegions = regionUtils.createSearchRegions(regions);
            
            // Then
            assertNotNull(searchRegions);
            assertEquals(2, searchRegions.getRegions().size());
        }
        
        @Test
        @DisplayName("Should filter valid regions")
        void shouldFilterValidRegions() {
            // Given
            List<Region> regions = Arrays.asList(
                new Region(0, 0, 50, 50),
                new Region(-10, -10, 50, 50), // Invalid position
                new Region(0, 0, 0, 0),       // Invalid size
                new Region(100, 100, 50, 50)
            );
            
            // When
            List<Region> valid = regionUtils.filterValidRegions(regions);
            
            // Then
            assertEquals(2, valid.size());
        }
        
        @Test
        @DisplayName("Should clip regions to screen bounds")
        void shouldClipRegionsToScreenBounds() {
            // Given
            Region screenBounds = new Region(0, 0, 1920, 1080);
            List<Region> regions = Arrays.asList(
                new Region(-50, -50, 100, 100),
                new Region(1900, 1050, 100, 100),
                new Region(500, 500, 100, 100)
            );
            
            // When
            List<Region> clipped = regionUtils.clipToScreenBounds(regions, screenBounds);
            
            // Then
            // First region should be clipped to start at (0,0)
            assertEquals(0, clipped.get(0).getX());
            assertEquals(0, clipped.get(0).getY());
            
            // Second region should be clipped to fit screen
            assertTrue(clipped.get(1).getX() + clipped.get(1).getW() <= 1920);
            assertTrue(clipped.get(1).getY() + clipped.get(1).getH() <= 1080);
            
            // Third region should be unchanged
            assertEquals(500, clipped.get(2).getX());
            assertEquals(500, clipped.get(2).getY());
        }
    }
}
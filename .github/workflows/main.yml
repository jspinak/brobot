name: Brobot CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
  workflow_dispatch:

jobs:
  build-and-test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: "21"
          distribution: "temurin"
          cache: "gradle"

      - name: Make Gradle wrapper executable
        run: chmod +x ./gradlew

      # Create a test environment setup that matches your configuration
      - name: Setup test environment
        run: |
          # Backup original application.properties
          if [ -f "app/src/main/resources/application.properties" ]; then
            cp app/src/main/resources/application.properties app/src/main/resources/application.properties.backup
          fi
          
          # Create application-ci.properties with direct values
          cat > app/src/main/resources/application-ci.properties << EOF
          # Application Configuration
          spring.application.name=brobot-app
          server.port=8080
          
          # Database Configuration - direct values, no placeholders
          spring.datasource.url=jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE;DEFAULT_NULL_ORDERING=HIGH
          spring.datasource.username=sa
          spring.datasource.password=
          spring.datasource.driver-class-name=org.h2.Driver
          spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.H2Dialect
          spring.jpa.hibernate.ddl-auto=create-drop
          spring.jpa.show-sql=true
          spring.jpa.properties.hibernate.format_sql=true
          
          # Hikari Configuration - direct values, no placeholders
          spring.datasource.hikari.jdbc-url=jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE;DEFAULT_NULL_ORDERING=HIGH
          spring.datasource.hikari.username=sa
          spring.datasource.hikari.password=
          spring.datasource.hikari.driver-class-name=org.h2.Driver
          spring.datasource.hikari.auto-commit=false
          
          # WebSocket Configuration
          spring.websocket.enabled=true
          spring.websocket.max-text-message-size=512000
          spring.websocket.max-binary-message-size=512000
          
          # JSON Configuration
          spring.jackson.serialization.WRITE_DATES_AS_TIMESTAMPS=false
          
          # Client App Authentication - test values
          client.app.username=test-user
          client.app.password=test-password
          client.app.base-url=http://localhost:8081
          client.app.url=http://localhost:8081
          client.app.login-url=http://localhost:8081/api/auth/login
          client.app.api-key=test-api-key
          
          # Security Configuration
          spring.security.enabled=false
          client.app.auth.token=test-token
          
          # Logging Configuration
          logging.level.org.springframework.boot=DEBUG
          logging.level.com.zaxxer.hikari.pool=INFO
          logging.level.org.springframework.web.socket=INFO
          logging.level.org.springframework.messaging=INFO
          logging.level.com.brobot.client.security=INFO
          logging.level.io.github.jspinak.brobot.app.services=INFO
          
          # Additional test settings
          spring.jpa.properties.hibernate.generate_statistics=false
          spring.jpa.properties.hibernate.jdbc.batch_size=25
          spring.jpa.properties.hibernate.order_inserts=true
          spring.jpa.properties.hibernate.order_updates=true
          spring.flyway.enabled=false
          EOF
          
          # Also set environment variables to match your .env structure
          cat > .env << EOF
          # Server
          SERVER_PORT=8080
          
          # Database
          DATABASE_URL=jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE;DEFAULT_NULL_ORDERING=HIGH
          DATABASE_USERNAME=sa
          DATABASE_PASSWORD=
          SHOW_SQL=true
          FORMAT_SQL=true
          
          # Client
          CLIENT_BASE_URL=http://localhost:8081
          CLIENT_APP_USERNAME=test-user
          CLIENT_APP_PASSWORD=test-password
          CLIENT_APP_API_KEY=test-api-key
          DEV_CLIENT_BASE_URL=http://localhost:8081
          
          # Auth
          DYNAMIC_AUTH_TOKEN=test-token
          
          # Logging
          SPRING_LOG_LEVEL=DEBUG
          HIKARI_LOG_LEVEL=INFO
          WEBSOCKET_LOG_LEVEL=INFO
          MESSAGING_LOG_LEVEL=INFO
          SECURITY_LOG_LEVEL=INFO
          SERVICES_LOG_LEVEL=INFO
          EOF
          
          # Set up xvfb for headless GUI tests
          sudo apt-get update
          sudo apt-get install -y xvfb

      - name: Build with Gradle
        run: ./gradlew build -x test

      - name: Run unit tests
        run: |
          # Start Xvfb
          Xvfb :99 -screen 0 1024x768x24 > /dev/null 2>&1 &
          export DISPLAY=:99
          
          # Run tests with direct environment variables
          ./gradlew test -x :library-test:test --info
        env:
          # Activate CI profile
          SPRING_PROFILES_ACTIVE: "ci"

          # Database variables
          DATABASE_URL: "jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE;DEFAULT_NULL_ORDERING=HIGH"
          DATABASE_USERNAME: "sa"
          DATABASE_PASSWORD: ""

          # Client variables
          CLIENT_BASE_URL: "http://localhost:8081"
          CLIENT_APP_USERNAME: "test-user"
          CLIENT_APP_PASSWORD: "test-password"
          CLIENT_APP_API_KEY: "test-api-key"
          DEV_CLIENT_BASE_URL: "http://localhost:8081"

          # Auth token
          DYNAMIC_AUTH_TOKEN: "test-token"

          # Logging
          SPRING_LOG_LEVEL: "DEBUG"
          HIKARI_LOG_LEVEL: "INFO"
          WEBSOCKET_LOG_LEVEL: "INFO"
          MESSAGING_LOG_LEVEL: "INFO"
          SECURITY_LOG_LEVEL: "INFO"
          SERVICES_LOG_LEVEL: "INFO"

          # Server port
          SERVER_PORT: "8080"

          # Misc
          SHOW_SQL: "true"
          FORMAT_SQL: "true"

          # Headless mode
          _JAVA_OPTIONS: "-Djava.awt.headless=true"

      - name: Run integration tests
        run: |
          # Use the same display from Xvfb
          export DISPLAY=:99
          
          # Run integration tests
          ./gradlew :library-test:test --info
        env:
          # Activate CI profile
          SPRING_PROFILES_ACTIVE: "ci"

          # Database variables
          DATABASE_URL: "jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE;DEFAULT_NULL_ORDERING=HIGH"
          DATABASE_USERNAME: "sa"
          DATABASE_PASSWORD: ""

          # Client variables
          CLIENT_BASE_URL: "http://localhost:8081"
          CLIENT_APP_USERNAME: "test-user"
          CLIENT_APP_PASSWORD: "test-password"
          CLIENT_APP_API_KEY: "test-api-key"
          DEV_CLIENT_BASE_URL: "http://localhost:8081"

          # Auth token
          DYNAMIC_AUTH_TOKEN: "test-token"

          # Logging
          SPRING_LOG_LEVEL: "DEBUG"
          HIKARI_LOG_LEVEL: "INFO"
          WEBSOCKET_LOG_LEVEL: "INFO"
          MESSAGING_LOG_LEVEL: "INFO"
          SECURITY_LOG_LEVEL: "INFO"
          SERVICES_LOG_LEVEL: "INFO"

          # Server port
          SERVER_PORT: "8080"

          # Misc
          SHOW_SQL: "true"
          FORMAT_SQL: "true"

          # Headless mode
          _JAVA_OPTIONS: "-Djava.awt.headless=true"

      - name: Upload test results
        if: always() && (success() || failure())
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: "**/build/test-results/test"
          if-no-files-found: warn

      - name: Cache build artifacts
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-

  # Web build job commented out as we're focusing on desktop first
  #  build-web:
  #    runs-on: ubuntu-latest
  #    needs: build-and-test
  #
  #    steps:
  #      - uses: actions/checkout@v4
  #
  #      - name: Set up Node.js
  #        uses: actions/setup-node@v4
  #        with:
  #          node-version: "18"
  #          cache: "npm"
  #          cache-dependency-path: "web/package-lock.json"
  #
  #      - name: Install web dependencies
  #        working-directory: ./web
  #        run: npm ci
  #
  #      - name: Build web app
  #        working-directory: ./web
  #        run: npm run build
  #
  #      - name: Cache web build artifacts
  #        uses: actions/upload-artifact@v4
  #        with:
  #          name: web-build
  #          path: web/build

  # App module is used as a dependency, not a standalone application

  # AWS deployment jobs commented out
  #  deploy-web-amplify:
  #    runs-on: ubuntu-latest
  #    needs: [build-web]
  #    if: github.ref == 'refs/heads/main' && github.event_name != 'pull_request'
  #
  #    steps:
  #      - uses: actions/checkout@v4
  #
  #      - name: Download web build artifacts
  #        uses: actions/download-artifact@v4
  #        with:
  #          name: web-build
  #          path: web-build
  #
  #      - name: Configure AWS credentials
  #        uses: aws-actions/configure-aws-credentials@v2
  #        with:
  #          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #          aws-region: ${{ secrets.AWS_REGION }}
  #
  #      - name: Deploy to AWS Amplify
  #        run: |
  #          # Install AWS Amplify CLI
  #          npm install -g @aws-amplify/cli
  #
  #          # Deploy the built web app to Amplify
  #          # Instead of using the Action, we'll use the AWS CLI directly
  #          aws amplify start-job \
  #            --app-id ${{ secrets.AMPLIFY_APP_ID }} \
  #            --branch-name ${{ secrets.AMPLIFY_BRANCH }} \
  #            --job-type RELEASE
  #
  #          # Optional: Upload build artifacts if using manual deployment
  #          # aws s3 sync web-build/ s3://${AMPLIFY_DEPLOYMENT_BUCKET}/ --delete
  #        env:
  #          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #          AWS_REGION: ${{ secrets.AWS_REGION }}

  package-desktop:
    runs-on: ubuntu-latest
    needs: build-and-test
    if: github.ref == 'refs/heads/main' && github.event_name != 'pull_request'

    steps:
      - uses: actions/checkout@v4

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: "21"
          distribution: "temurin"
          cache: "gradle"

      - name: Make Gradle wrapper executable
        run: chmod +x ./gradlew

      - name: Build desktop application
        run: ./gradlew :runner:build
        env:
          _JAVA_OPTIONS: "-Djava.awt.headless=true"

      - name: Package desktop application with jpackage
        run: |
          # Install required dependencies for jpackage
          sudo apt-get update
          sudo apt-get install -y fakeroot

          # Create a distribution using jpackage
          ./gradlew :runner:jpackage

      - name: Upload desktop application package
        uses: actions/upload-artifact@v4
        with:
          name: runner-package
          path: runner/build/jpackage

      - name: Create GitHub release with desktop app
        if: startsWith(github.ref, 'refs/tags/')
        uses: softprops/action-gh-release@v2
        with:
          files: runner/build/jpackage/**/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
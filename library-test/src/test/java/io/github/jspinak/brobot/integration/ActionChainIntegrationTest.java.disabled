package io.github.jspinak.brobot.integration;

import io.github.jspinak.brobot.action.*;
import io.github.jspinak.brobot.action.basic.click.ClickOptions;
import io.github.jspinak.brobot.action.basic.find.PatternFindOptions;
import io.github.jspinak.brobot.action.basic.type.TypeOptions;
import io.github.jspinak.brobot.model.element.Location;
import io.github.jspinak.brobot.model.element.Pattern;
import io.github.jspinak.brobot.model.element.Region;
import io.github.jspinak.brobot.model.match.Match;
import io.github.jspinak.brobot.model.state.StateImage;
import io.github.jspinak.brobot.test.BrobotTestBase;
import io.github.jspinak.brobot.tools.testing.mock.builders.MockSceneBuilder;
import org.junit.jupiter.api.*;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.springframework.boot.test.context.SpringBootTest;

import java.util.Arrays;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

/**
 * Integration tests for end-to-end action chains in Brobot.
 * 
 * These tests verify that complex sequences of actions work correctly together,
 * including find, click, type, and drag operations in realistic scenarios.
 */
@SpringBootTest
@DisplayName("Action Chain Integration Tests")
public class ActionChainIntegrationTest extends BrobotTestBase {

    @Mock
    private Action action;
    
    @InjectMocks
    private ActionChainExecutor chainExecutor;
    
    @BeforeEach
    public void setUp() {
        super.setupTest();
        // Mock mode is already enabled by BrobotTestBase
    }
    
    @Nested
    @DisplayName("Simple Action Chains")
    class SimpleActionChains {
        
        @Test
        @DisplayName("Should execute find-click chain successfully")
        void shouldExecuteFindClickChain() {
            // Arrange
            StateImage targetImage = MockSceneBuilder.createMockStateImage("button.png");
            Match mockMatch = MockSceneBuilder.createMockMatch(100, 100, 50, 30);
            
            ActionResult findResult = new ActionResult();
            findResult.setSuccess(true);
            findResult.setMatchList(Arrays.asList(mockMatch));
            
            ActionResult clickResult = new ActionResult();
            clickResult.setSuccess(true);
            
            when(action.find(any(StateImage.class))).thenReturn(findResult);
            when(action.click(any(Match.class))).thenReturn(clickResult);
            
            // Act
            ActionResult findRes = action.find(targetImage);
            ActionResult clickRes = null;
            if (findRes.isSuccess() && !findRes.getMatchList().isEmpty()) {
                clickRes = action.click(findRes.getMatchList().get(0));
            }
            
            // Assert
            assertNotNull(findRes);
            assertTrue(findRes.isSuccess());
            assertNotNull(clickRes);
            assertTrue(clickRes.isSuccess());
            verify(action).find(targetImage);
            verify(action).click(mockMatch);
        }
        
        @Test
        @DisplayName("Should execute find-type chain successfully")
        void shouldExecuteFindTypeChain() {
            // Arrange
            StateImage inputField = MockSceneBuilder.createMockStateImage("input.png");
            String textToType = "Hello World";
            Match mockMatch = MockSceneBuilder.createMockMatch(200, 150, 100, 25);
            
            ActionResult findResult = new ActionResult();
            findResult.setSuccess(true);
            findResult.setMatchList(Arrays.asList(mockMatch));
            
            ActionResult clickResult = new ActionResult();
            clickResult.setSuccess(true);
            
            ActionResult typeResult = new ActionResult();
            typeResult.setSuccess(true);
            typeResult.setText(textToType);
            
            when(action.find(any(StateImage.class))).thenReturn(findResult);
            when(action.click(any(Match.class))).thenReturn(clickResult);
            when(action.type(anyString())).thenReturn(typeResult);
            
            // Act
            ActionResult findRes = action.find(inputField);
            ActionResult clickRes = null;
            ActionResult typeRes = null;
            
            if (findRes.isSuccess() && !findRes.getMatchList().isEmpty()) {
                clickRes = action.click(findRes.getMatchList().get(0));
                if (clickRes.isSuccess()) {
                    typeRes = action.type(textToType);
                }
            }
            
            // Assert
            assertTrue(findRes.isSuccess());
            assertTrue(clickRes.isSuccess());
            assertNotNull(typeRes);
            assertTrue(typeRes.isSuccess());
            assertEquals(textToType, typeRes.getText());
        }
    }
    
    @Nested
    @DisplayName("Complex Action Chains")
    class ComplexActionChains {
        
        @Test
        @DisplayName("Should execute multi-step form fill chain")
        void shouldExecuteFormFillChain() {
            // Arrange
            StateImage nameField = MockSceneBuilder.createMockStateImage("name_field.png");
            StateImage emailField = MockSceneBuilder.createMockStateImage("email_field.png");
            StateImage submitButton = MockSceneBuilder.createMockStateImage("submit.png");
            
            ActionResult successResult = new ActionResult();
            successResult.setSuccess(true);
            successResult.setMatchList(Arrays.asList(MockSceneBuilder.createMockMatch(100, 100, 100, 25)));
            
            when(action.find(any(StateImage.class))).thenReturn(successResult);
            when(action.click(any(Match.class))).thenReturn(successResult);
            when(action.type(anyString())).thenReturn(successResult);
            
            // Act - Simulate form filling
            boolean formFilled = fillForm(nameField, "John Doe", emailField, "john@example.com", submitButton);
            
            // Assert
            assertTrue(formFilled);
            verify(action, times(3)).find(any(StateImage.class)); // Find each field
            verify(action, times(3)).click(any(Match.class)); // Click each field
            verify(action, times(2)).type(anyString()); // Type in two fields
        }
        
        @Test
        @DisplayName("Should handle drag and drop chain")
        void shouldExecuteDragDropChain() {
            // Arrange
            StateImage sourceElement = MockSceneBuilder.createMockStateImage("source.png");
            StateImage targetElement = MockSceneBuilder.createMockStateImage("target.png");
            
            Match sourceMatch = MockSceneBuilder.createMockMatch(100, 100, 50, 50);
            Match targetMatch = MockSceneBuilder.createMockMatch(300, 100, 50, 50);
            
            ActionResult findSourceResult = new ActionResult();
            findSourceResult.setSuccess(true);
            findSourceResult.setMatchList(Arrays.asList(sourceMatch));
            
            ActionResult findTargetResult = new ActionResult();
            findTargetResult.setSuccess(true);
            findTargetResult.setMatchList(Arrays.asList(targetMatch));
            
            ActionResult dragResult = new ActionResult();
            dragResult.setSuccess(true);
            
            when(action.find(sourceElement)).thenReturn(findSourceResult);
            when(action.find(targetElement)).thenReturn(findTargetResult);
            when(action.drag(any(Match.class), any(Match.class))).thenReturn(dragResult);
            
            // Act
            boolean dragSuccess = performDragDrop(sourceElement, targetElement);
            
            // Assert
            assertTrue(dragSuccess);
            verify(action).find(sourceElement);
            verify(action).find(targetElement);
            verify(action).drag(sourceMatch, targetMatch);
        }
    }
    
    @Nested
    @DisplayName("Error Handling in Chains")
    class ErrorHandlingChains {
        
        @Test
        @DisplayName("Should handle find failure in chain")
        void shouldHandleFindFailure() {
            // Arrange
            StateImage missingImage = MockSceneBuilder.createMockStateImage("missing.png");
            
            ActionResult failedFindResult = new ActionResult();
            failedFindResult.setSuccess(false);
            
            when(action.find(any(StateImage.class))).thenReturn(failedFindResult);
            
            // Act
            ActionResult result = action.find(missingImage);
            boolean chainContinued = false;
            
            if (result.isSuccess()) {
                // This should not execute
                action.click(result.getMatchList().get(0));
                chainContinued = true;
            }
            
            // Assert
            assertFalse(result.isSuccess());
            assertFalse(chainContinued);
            verify(action).find(missingImage);
            verify(action, never()).click(any());
        }
        
        @Test
        @DisplayName("Should retry failed actions in chain")
        void shouldRetryFailedActions() {
            // Arrange
            StateImage targetImage = MockSceneBuilder.createMockStateImage("retry_target.png");
            Match mockMatch = MockSceneBuilder.createMockMatch(100, 100, 50, 30);
            
            ActionResult failedResult = new ActionResult();
            failedResult.setSuccess(false);
            
            ActionResult successResult = new ActionResult();
            successResult.setSuccess(true);
            successResult.setMatchList(Arrays.asList(mockMatch));
            
            // First call fails, second succeeds
            when(action.find(any(StateImage.class)))
                .thenReturn(failedResult)
                .thenReturn(successResult);
            
            // Act
            ActionResult result = executeWithRetry(() -> action.find(targetImage), 3);
            
            // Assert
            assertTrue(result.isSuccess());
            verify(action, times(2)).find(targetImage); // Called twice: first fail, then success
        }
    }
    
    @Nested
    @DisplayName("Conditional Action Chains")
    class ConditionalActionChains {
        
        @Test
        @DisplayName("Should execute conditional chain based on find result")
        void shouldExecuteConditionalChain() {
            // Arrange
            StateImage primaryTarget = MockSceneBuilder.createMockStateImage("primary.png");
            StateImage fallbackTarget = MockSceneBuilder.createMockStateImage("fallback.png");
            
            ActionResult primaryNotFound = new ActionResult();
            primaryNotFound.setSuccess(false);
            
            ActionResult fallbackFound = new ActionResult();
            fallbackFound.setSuccess(true);
            fallbackFound.setMatchList(Arrays.asList(MockSceneBuilder.createMockMatch(200, 200, 50, 50)));
            
            when(action.find(primaryTarget)).thenReturn(primaryNotFound);
            when(action.find(fallbackTarget)).thenReturn(fallbackFound);
            when(action.click(any(Match.class))).thenReturn(new ActionResult());
            
            // Act
            ActionResult result = action.find(primaryTarget);
            if (!result.isSuccess()) {
                result = action.find(fallbackTarget);
                if (result.isSuccess() && !result.getMatchList().isEmpty()) {
                    action.click(result.getMatchList().get(0));
                }
            }
            
            // Assert
            assertTrue(result.isSuccess());
            verify(action).find(primaryTarget);
            verify(action).find(fallbackTarget);
            verify(action).click(any(Match.class));
        }
        
        @Test
        @DisplayName("Should execute different paths based on conditions")
        void shouldExecuteDifferentPaths() {
            // Arrange
            StateImage checkboxImage = MockSceneBuilder.createMockStateImage("checkbox.png");
            StateImage checkedState = MockSceneBuilder.createMockStateImage("checked.png");
            
            // Checkbox found but not checked
            ActionResult checkboxFound = new ActionResult();
            checkboxFound.setSuccess(true);
            checkboxFound.setMatchList(Arrays.asList(MockSceneBuilder.createMockMatch(100, 100, 20, 20)));
            
            ActionResult checkedNotFound = new ActionResult();
            checkedNotFound.setSuccess(false);
            
            ActionResult clickSuccess = new ActionResult();
            clickSuccess.setSuccess(true);
            
            when(action.find(checkboxImage)).thenReturn(checkboxFound);
            when(action.find(checkedState)).thenReturn(checkedNotFound);
            when(action.click(any(Match.class))).thenReturn(clickSuccess);
            
            // Act
            boolean wasChecked = ensureCheckboxChecked(checkboxImage, checkedState);
            
            // Assert
            assertTrue(wasChecked);
            verify(action).find(checkboxImage);
            verify(action).find(checkedState);
            verify(action).click(any(Match.class)); // Clicked to check the box
        }
    }
    
    // Helper methods for complex scenarios
    
    private boolean fillForm(StateImage nameField, String name, 
                            StateImage emailField, String email,
                            StateImage submitButton) {
        // Find and fill name field
        ActionResult nameResult = action.find(nameField);
        if (!nameResult.isSuccess() || nameResult.getMatchList().isEmpty()) {
            return false;
        }
        action.click(nameResult.getMatchList().get(0));
        action.type(name);
        
        // Find and fill email field
        ActionResult emailResult = action.find(emailField);
        if (!emailResult.isSuccess() || emailResult.getMatchList().isEmpty()) {
            return false;
        }
        action.click(emailResult.getMatchList().get(0));
        action.type(email);
        
        // Submit form
        ActionResult submitResult = action.find(submitButton);
        if (!submitResult.isSuccess() || submitResult.getMatchList().isEmpty()) {
            return false;
        }
        action.click(submitResult.getMatchList().get(0));
        
        return true;
    }
    
    private boolean performDragDrop(StateImage source, StateImage target) {
        ActionResult sourceResult = action.find(source);
        if (!sourceResult.isSuccess() || sourceResult.getMatchList().isEmpty()) {
            return false;
        }
        
        ActionResult targetResult = action.find(target);
        if (!targetResult.isSuccess() || targetResult.getMatchList().isEmpty()) {
            return false;
        }
        
        ActionResult dragResult = action.drag(
            sourceResult.getMatchList().get(0),
            targetResult.getMatchList().get(0)
        );
        
        return dragResult.isSuccess();
    }
    
    private ActionResult executeWithRetry(java.util.function.Supplier<ActionResult> action, int maxRetries) {
        ActionResult result = null;
        for (int i = 0; i < maxRetries; i++) {
            result = action.get();
            if (result.isSuccess()) {
                break;
            }
            try {
                Thread.sleep(100); // Brief pause between retries
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
        return result;
    }
    
    private boolean ensureCheckboxChecked(StateImage checkbox, StateImage checkedState) {
        // First check if checkbox exists
        ActionResult checkboxResult = action.find(checkbox);
        if (!checkboxResult.isSuccess() || checkboxResult.getMatchList().isEmpty()) {
            return false;
        }
        
        // Check if already checked
        ActionResult checkedResult = action.find(checkedState);
        if (checkedResult.isSuccess()) {
            return true; // Already checked
        }
        
        // Click to check
        ActionResult clickResult = action.click(checkboxResult.getMatchList().get(0));
        return clickResult.isSuccess();
    }
    
    /**
     * Helper class to simulate action chain execution.
     * In a real implementation, this would coordinate actual action execution.
     */
    static class ActionChainExecutor {
        // This would contain the actual chain execution logic
    }
}
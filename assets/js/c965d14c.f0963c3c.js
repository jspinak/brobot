"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2682],{1200:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"testing/mock-stochasticity","title":"Mock Stochasticity in Brobot","description":"Overview","source":"@site/docs/04-testing/mock-stochasticity.md","sourceDirName":"04-testing","slug":"/testing/mock-stochasticity","permalink":"/brobot/docs/testing/mock-stochasticity","draft":false,"unlisted":false,"editUrl":"https://github.com/jspinak/brobot/edit/main/docs/docs/04-testing/mock-stochasticity.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docSidebar","previous":{"title":"Mat Testing Utilities","permalink":"/brobot/docs/testing/mat-testing-utilities"},"next":{"title":"Migration from FrameworkSettings to BrobotProperties","permalink":"/brobot/docs/migration/frameworksettings-to-brobotproperties"}}');var s=t(74848),r=t(28453);const o={},a="Mock Stochasticity in Brobot",c={},l=[{value:"Overview",id:"overview",level:2},{value:"The mockFindStochasticModifier Field",id:"the-mockfindstochasticmodifier-field",level:2},{value:"Purpose",id:"purpose",level:3},{value:"How It Works",id:"how-it-works",level:3},{value:"Usage Example",id:"usage-example",level:3},{value:"Important Implementation Notes",id:"important-implementation-notes",level:2},{value:"When NOT to Modify mockFindStochasticModifier",id:"when-not-to-modify-mockfindstochasticmodifier",level:3},{value:"Why These Are Bugs",id:"why-these-are-bugs",level:3},{value:"Correct Approach",id:"correct-approach",level:3},{value:"Configuration",id:"configuration",level:2},{value:"Setting Base Values",id:"setting-base-values",level:3},{value:"Common Values",id:"common-values",level:3},{value:"Integration with ActionHistory",id:"integration-with-actionhistory",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Testing Strategies",id:"testing-strategies",level:2},{value:"Reliability Testing",id:"reliability-testing",level:3},{value:"Edge Case Discovery",id:"edge-case-discovery",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"mock-stochasticity-in-brobot",children:"Mock Stochasticity in Brobot"})}),"\n",(0,s.jsx)(i.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(i.p,{children:"Brobot's mock mode includes a sophisticated stochasticity system that simulates the unpredictable nature of real-world GUI environments. This feature makes mock tests more realistic and helps catch edge cases that might occur in production."}),"\n",(0,s.jsx)(i.h2,{id:"the-mockfindstochasticmodifier-field",children:"The mockFindStochasticModifier Field"}),"\n",(0,s.jsxs)(i.p,{children:["Each ",(0,s.jsx)(i.code,{children:"State"})," in Brobot has a ",(0,s.jsx)(i.code,{children:"mockFindStochasticModifier"})," field that represents an additional probability factor for whether the state's images will be found during mock runs."]}),"\n",(0,s.jsx)(i.h3,{id:"purpose",children:"Purpose"}),"\n",(0,s.jsxs)(i.p,{children:["The ",(0,s.jsx)(i.code,{children:"mockFindStochasticModifier"})," field simulates environmental uncertainties that can affect GUI automation:"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Network failures"}),": Connection issues that prevent pages from loading"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Unexpected overlays"}),": Update windows, notifications, or popups that cover target elements"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Rendering issues"}),": Elements with transparent backgrounds or poor contrast that make detection unreliable"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Timing variations"}),": Elements that appear/disappear at unpredictable times"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"System interruptions"}),": OS-level dialogs, screen savers, or other interruptions"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"how-it-works",children:"How It Works"}),"\n",(0,s.jsxs)(i.p,{children:["When a ",(0,s.jsx)(i.code,{children:"StateImage"})," is searched for in a mock run, the probability of finding it depends on two factors:"]}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"ActionHistory Analysis"}),": The mock framework examines the ",(0,s.jsx)(i.code,{children:"ActionHistory"})," stored in the ",(0,s.jsx)(i.code,{children:"StateImage"}),", which records historical behavior of actions on that image. It compares:"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Past action outcomes (success/failure)"}),"\n",(0,s.jsx)(i.li,{children:"Environmental characteristics when the action was performed"}),"\n",(0,s.jsx)(i.li,{children:"Current environmental characteristics"}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:'The framework essentially asks: "What happened in the past when this action was performed on this image in similar environments?"'}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"mockFindStochasticModifier Factor"}),": This is an additional probability modifier that can deny the existence of the image, regardless of historical data. It acts as a random failure injection mechanism."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"usage-example",children:"Usage Example"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-java",children:"// In State.Builder\r\nState loginState = State.builder()\r\n    .withName(\"LoginScreen\")\r\n    .setBaseMockFindStochasticModifier(95)  // 95% chance of being available\r\n    .build();\r\n\r\n// During mock execution\r\n// If mockFindStochasticModifier = 95, there's a 5% chance\r\n// the state's images won't be found, simulating environmental issues\n"})}),"\n",(0,s.jsx)(i.h2,{id:"important-implementation-notes",children:"Important Implementation Notes"}),"\n",(0,s.jsx)(i.h3,{id:"when-not-to-modify-mockfindstochasticmodifier",children:"When NOT to Modify mockFindStochasticModifier"}),"\n",(0,s.jsxs)(i.p,{children:["The ",(0,s.jsx)(i.code,{children:"mockFindStochasticModifier"})," field should ",(0,s.jsx)(i.strong,{children:"NOT"})," be modified during normal state transitions:"]}),"\n",(0,s.jsxs)(i.p,{children:["\u274c ",(0,s.jsx)(i.strong,{children:"Don't do this:"})]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-java",children:"// In StateMemory.addActiveState()\r\nstate.setMockFindStochasticModifier(100);  // WRONG - Don't force availability\n"})}),"\n",(0,s.jsxs)(i.p,{children:["\u274c ",(0,s.jsx)(i.strong,{children:"Don't do this either:"})]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-java",children:"// In StateMemory.removeInactiveState()\r\nstate.setMockFindStochasticModifier(0);  // WRONG - This breaks future mock runs!\n"})}),"\n",(0,s.jsx)(i.h3,{id:"why-these-are-bugs",children:"Why These Are Bugs"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Setting to 100 on activation"}),": The state becoming active doesn't mean it will always be findable. Environmental issues can still occur."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Setting to 0 on deactivation"}),": This is particularly harmful because it means the state's images will ",(0,s.jsx)(i.strong,{children:"never"})," be found again in mock runs, breaking the mock's ability to navigate back to that state."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"correct-approach",children:"Correct Approach"}),"\n",(0,s.jsxs)(i.p,{children:["The ",(0,s.jsx)(i.code,{children:"mockFindStochasticModifier"})," should be:"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["Set during ",(0,s.jsx)(i.strong,{children:"state definition"})," based on the expected reliability of that state"]}),"\n",(0,s.jsxs)(i.li,{children:["Potentially adjusted by ",(0,s.jsx)(i.strong,{children:"mock configuration"})," for different test scenarios"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Never modified"})," by state activation/deactivation logic"]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"configuration",children:"Configuration"}),"\n",(0,s.jsx)(i.h3,{id:"setting-base-values",children:"Setting Base Values"}),"\n",(0,s.jsx)(i.p,{children:"Set the base mock find stochastic modifier when defining states:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-java",children:"@State\r\npublic class MyStates {\r\n\r\n    @State.Configure\r\n    public void configure(State.Builder builder) {\r\n        builder.setBaseMockFindStochasticModifier(90);  // 90% availability\r\n    }\r\n}\n"})}),"\n",(0,s.jsx)(i.h3,{id:"common-values",children:"Common Values"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"100"}),": Perfect availability (unrealistic, not recommended)"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"95-99"}),": Highly stable states (main navigation, home screens)"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"85-94"}),": Normal states (typical application screens)"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"70-84"}),": Less stable states (dynamic content, Ajax-heavy pages)"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"50-69"}),": Unreliable states (states with frequent overlays or interruptions)"]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"integration-with-actionhistory",children:"Integration with ActionHistory"}),"\n",(0,s.jsxs)(i.p,{children:["The stochasticity system works in conjunction with ",(0,s.jsx)(i.code,{children:"ActionHistory"}),":"]}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"ActionHistory"}),' provides historical context: "This click action succeeded 8 out of 10 times on this image"']}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"mockFindStochasticModifier"}),' adds environmental randomness: "But there\'s also a 10% chance the entire state is unavailable"']}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"Together, they create a realistic mock that can:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Reproduce historical patterns"}),"\n",(0,s.jsx)(i.li,{children:"Inject random failures"}),"\n",(0,s.jsx)(i.li,{children:"Test automation robustness"}),"\n",(0,s.jsx)(i.li,{children:"Validate error handling"}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Set realistic values"}),": Don't use 100% availability unless testing a specific scenario"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Document your choices"}),": Explain why certain states have lower availability"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Use different profiles"}),": Create test profiles with different stochasticity levels"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Monitor patterns"}),": If a state consistently fails in mocks, it might indicate a real reliability issue"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Don't modify at runtime"}),": Let the mock framework control the stochasticity"]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"testing-strategies",children:"Testing Strategies"}),"\n",(0,s.jsx)(i.h3,{id:"reliability-testing",children:"Reliability Testing"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-java",children:"// Test with reduced availability to stress-test error handling\r\n@Test\r\npublic void testWithUnreliableStates() {\r\n    // Configure all states to have 70% availability\r\n    mockConfig.setGlobalMockFindStochasticModifier(70);\r\n\r\n    // Run automation and verify it handles failures gracefully\r\n    automationResult = automation.run();\r\n\r\n    assertTrue(automationResult.hasRecoveryAttempts());\r\n    assertTrue(automationResult.isEventuallySuccessful());\r\n}\n"})}),"\n",(0,s.jsx)(i.h3,{id:"edge-case-discovery",children:"Edge Case Discovery"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-java",children:"// Use varying stochasticity to discover edge cases\r\n@ParameterizedTest\r\n@ValueSource(ints = {50, 70, 90, 95})\r\npublic void testWithVaryingReliability(int availability) {\r\n    state.setMockFindStochasticModifier(availability);\r\n    // Test behavior under different reliability conditions\r\n}\n"})}),"\n",(0,s.jsx)(i.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsxs)(i.p,{children:["The ",(0,s.jsx)(i.code,{children:"mockFindStochasticModifier"})," field is a powerful tool for creating realistic mock tests that expose potential issues before they occur in production. By simulating environmental uncertainties, it helps ensure your automation is robust and can handle the unpredictable nature of real-world GUI environments."]}),"\n",(0,s.jsxs)(i.p,{children:["Remember: This field is for ",(0,s.jsx)(i.strong,{children:"mock mode simulation only"})," and should not be confused with state activation logic. It represents the inherent unreliability of GUI environments, not the logical state of the application."]})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,i,t)=>{t.d(i,{R:()=>o,x:()=>a});var n=t(96540);const s={},r=n.createContext(s);function o(e){const i=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(r.Provider,{value:i},e.children)}}}]);
"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3340],{28453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>d});var t=i(96540);const a={},s=t.createContext(a);function r(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(s.Provider,{value:n},e.children)}},87774:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"core-library/guides/declarative-region-definition","title":"Declarative Region Definition","description":"Brobot 1.1.0 introduces a powerful declarative approach to defining search regions for StateImages. This guide explains how to define regions that are dynamically calculated relative to other state objects.","source":"@site/docs/03-core-library/guides/declarative-region-definition.md","sourceDirName":"03-core-library/guides","slug":"/core-library/guides/declarative-region-definition","permalink":"/brobot/docs/core-library/guides/declarative-region-definition","draft":false,"unlisted":false,"editUrl":"https://github.com/jspinak/brobot/edit/main/docs/docs/03-core-library/guides/declarative-region-definition.md","tags":[],"version":"current","sidebarPosition":15,"frontMatter":{"sidebar_position":15},"sidebar":"docSidebar","previous":{"title":"Advanced Illustration System","permalink":"/brobot/docs/core-library/guides/advanced-illustration-system"},"next":{"title":"Search Regions and Fixed Locations","permalink":"/brobot/docs/core-library/guides/search-regions-and-fixed-locations"}}');var a=i(74848),s=i(28453);const r={sidebar_position:15},d="Declarative Region Definition",o={},l=[{value:"Overview",id:"overview",level:2},{value:"SearchRegionOnObject",id:"searchregiononobject",level:2},{value:"Basic Usage",id:"basic-usage",level:2},{value:"Simple Relative Region",id:"simple-relative-region",level:3},{value:"With Adjustments",id:"with-adjustments",level:3},{value:"With Fixed Dimensions",id:"with-fixed-dimensions",level:3},{value:"Real-World Example: Claude Automator",id:"real-world-example-claude-automator",level:2},{value:"Builder Methods",id:"builder-methods",level:2},{value:"Basic Structure",id:"basic-structure",level:3},{value:"MatchAdjustmentOptions Builder",id:"matchadjustmentoptions-builder",level:3},{value:"Key Differences from Standard Match Adjustments",id:"key-differences-from-standard-match-adjustments",level:3},{value:"Cross-State References",id:"cross-state-references",level:2},{value:"How Cross-State Dependencies Work",id:"how-cross-state-dependencies-work",level:3},{value:"Immediate Search Region Updates",id:"immediate-search-region-updates",level:2},{value:"How Immediate Updates Work",id:"how-immediate-updates-work",level:3},{value:"Integration with State-Aware Scheduling",id:"integration-with-state-aware-scheduling",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Migration from Manual Approach",id:"migration-from-manual-approach",level:2},{value:"Implementation Architecture",id:"implementation-architecture",level:2},{value:"Core Components",id:"core-components",level:3},{value:"Initialization Flow",id:"initialization-flow",level:3},{value:"Runtime Flow (Updated in 1.1.0+)",id:"runtime-flow-updated-in-110",level:3},{value:"Fixed Regions and Declarative Regions",id:"fixed-regions-and-declarative-regions",level:2},{value:"Interaction with Fixed Regions",id:"interaction-with-fixed-regions",level:3},{value:"Automatic Fixed Region Clearing",id:"automatic-fixed-region-clearing",level:4},{value:"Best Practices for Fixed Regions",id:"best-practices-for-fixed-regions",level:4},{value:"Debugging Fixed Region Conflicts",id:"debugging-fixed-region-conflicts",level:4},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Region Not Found",id:"region-not-found",level:3},{value:"Incorrect Region Position",id:"incorrect-region-position",level:3},{value:"Dependencies Not Working",id:"dependencies-not-working",level:3},{value:"Fixed Region Overriding Declarative Region",id:"fixed-region-overriding-declarative-region",level:3},{value:"Performance Considerations",id:"performance-considerations",level:3},{value:"Complete Example: Real-World Usage",id:"complete-example-real-world-usage",level:2},{value:"Key Benefits of the New Implementation",id:"key-benefits-of-the-new-implementation",level:2},{value:"Summary",id:"summary",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"declarative-region-definition",children:"Declarative Region Definition"})}),"\n",(0,a.jsx)(n.p,{children:"Brobot 1.1.0 introduces a powerful declarative approach to defining search regions for StateImages. This guide explains how to define regions that are dynamically calculated relative to other state objects."}),"\n",(0,a.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(n.p,{children:"The declarative approach allows you to:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Define search regions relative to other state objects"}),"\n",(0,a.jsx)(n.li,{children:"Apply adjustments and fixed dimensions"}),"\n",(0,a.jsx)(n.li,{children:"Eliminate manual region calculations in your action code"}),"\n",(0,a.jsx)(n.li,{children:"Create more maintainable and reusable state definitions"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"searchregiononobject",children:"SearchRegionOnObject"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"SearchRegionOnObject"})," class enables dynamic region definition:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"public class SearchRegionOnObject {\n    private StateObject.Type targetType;     // Type of target object (IMAGE, REGION, etc.)\n    private String targetStateName;          // Name of the state containing the target\n    private String targetObjectName;         // Name of the specific object\n    private MatchAdjustmentOptions adjustments; // Position and size adjustments (reuses existing class)\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"adjustments"})," field uses the standard ",(0,a.jsx)(n.code,{children:"MatchAdjustmentOptions"})," class for consistency with other Brobot operations."]}),"\n",(0,a.jsx)(n.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,a.jsx)(n.h3,{id:"simple-relative-region",children:"Simple Relative Region"}),"\n",(0,a.jsx)(n.p,{children:"Define a search region relative to another StateImage:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'StateImage searchArea = new StateImage.Builder()\n    .addPatterns("search-icon.png")\n    .setName("SearchIcon")\n    .setSearchRegionOnObject(SearchRegionOnObject.builder()\n        .targetType(StateObject.Type.IMAGE)\n        .targetStateName("MainMenu")\n        .targetObjectName("MenuButton")\n        .build())\n    .build();\n'})}),"\n",(0,a.jsx)(n.h3,{id:"with-adjustments",children:"With Adjustments"}),"\n",(0,a.jsx)(n.p,{children:"Apply position and size adjustments to the derived region:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'StateImage icon = new StateImage.Builder()\n    .addPatterns("status-icon.png")\n    .setName("StatusIcon")\n    .setSearchRegionOnObject(SearchRegionOnObject.builder()\n        .targetType(StateObject.Type.IMAGE)\n        .targetStateName("Dashboard")\n        .targetObjectName("HeaderBar")\n        .adjustments(MatchAdjustmentOptions.builder()\n            .addX(10)    // Move 10 pixels right\n            .addY(-5)    // Move 5 pixels up\n            .addW(50)    // Expand width by 50 pixels\n            .addH(20)    // Expand height by 20 pixels\n            .build())\n        .build())\n    .build();\n'})}),"\n",(0,a.jsx)(n.h3,{id:"with-fixed-dimensions",children:"With Fixed Dimensions"}),"\n",(0,a.jsx)(n.p,{children:"Override the calculated dimensions with fixed values:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'StateImage button = new StateImage.Builder()\n    .addPatterns("submit-button.png")\n    .setName("SubmitButton")\n    .setSearchRegionOnObject(SearchRegionOnObject.builder()\n        .targetType(StateObject.Type.IMAGE)\n        .targetStateName("Form")\n        .targetObjectName("FormTitle")\n        .adjustments(MatchAdjustmentOptions.builder()\n            .addY(100)        // Move down 100 pixels\n            .absoluteW(200)   // Fixed width of 200 pixels\n            .absoluteH(50)    // Fixed height of 50 pixels\n            .build())\n        .build())\n    .build();\n'})}),"\n",(0,a.jsx)(n.h2,{id:"real-world-example-claude-automator",children:"Real-World Example: Claude Automator"}),"\n",(0,a.jsx)(n.p,{children:"The claude-automator project demonstrates this pattern effectively:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'@State\n@Getter\npublic class WorkingState {\n    \n    private final StateImage claudeIcon;\n    \n    public WorkingState() {\n        // The search region will be dynamically defined relative to the prompt\n        claudeIcon = new StateImage.Builder()\n            .addPatterns("working/claude-icon-1", \n                        "working/claude-icon-2", \n                        "working/claude-icon-3", \n                        "working/claude-icon-4")\n            .setName("ClaudeIcon")\n            .setSearchRegionOnObject(SearchRegionOnObject.builder()\n                    .targetType(StateObject.Type.IMAGE)\n                    .targetStateName("Prompt")\n                    .targetObjectName("ClaudePrompt")\n                    .adjustments(MatchAdjustmentOptions.builder()\n                            .addX(3)      // Slight offset to the right\n                            .addY(10)     // Below the prompt\n                            .addW(30)     // Wider search area\n                            .addH(55)     // Taller search area\n                            .build())\n                    .build())\n            .build();\n    }\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"This declarative approach eliminates the need for manual region calculations:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"// Before: Manual calculation in action code\nprivate void setupIconRegion(Region promptRegion) {\n    Region iconRegion = new Region(promptRegion);\n    iconRegion.adjust(3, 10, 30, 55);\n    workingState.getClaudeIcon().setSearchRegions(iconRegion);\n}\n\n// After: Automatic calculation based on declaration\n// No manual setup needed - just use the StateImage directly\nActionResult result = action.perform(findOptions, workingState.getClaudeIcon());\n"})}),"\n",(0,a.jsx)(n.h2,{id:"builder-methods",children:"Builder Methods"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"SearchRegionOnObject.builder()"})," provides a fluent API for configuration:"]}),"\n",(0,a.jsx)(n.h3,{id:"basic-structure",children:"Basic Structure"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'SearchRegionOnObject.builder()\n    .targetType(StateObject.Type.IMAGE)  // Required: Type of target\n    .targetStateName("StateName")        // Required: State containing target\n    .targetObjectName("ObjectName")      // Required: Name of target object\n    .adjustments(...)                    // Optional: Position/size adjustments using MatchAdjustmentOptions\n    .build()\n'})}),"\n",(0,a.jsx)(n.h3,{id:"matchadjustmentoptions-builder",children:"MatchAdjustmentOptions Builder"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:".adjustments(MatchAdjustmentOptions.builder()\n    .addX(10)         // Add to x position\n    .addY(20)         // Add to y position  \n    .addW(30)         // Add to width\n    .addH(40)         // Add to height\n    .absoluteW(200)   // Override with fixed width (optional)\n    .absoluteH(100)   // Override with fixed height (optional)\n    .targetPosition(Position.CENTER)  // Target position within region (optional)\n    .targetOffset(new Location(5, 5)) // Additional offset (optional)\n    .build())\n"})}),"\n",(0,a.jsx)(n.h3,{id:"key-differences-from-standard-match-adjustments",children:"Key Differences from Standard Match Adjustments"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"When used with SearchRegionOnObject, only position and dimension adjustments apply"}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"targetPosition"})," and ",(0,a.jsx)(n.code,{children:"targetOffset"})," are ignored for search region calculation"]}),"\n",(0,a.jsxs)(n.li,{children:["Use negative values in ",(0,a.jsx)(n.code,{children:"addX"}),"/",(0,a.jsx)(n.code,{children:"addY"})," to move left/up"]}),"\n",(0,a.jsxs)(n.li,{children:["Use ",(0,a.jsx)(n.code,{children:"absoluteW"}),"/",(0,a.jsx)(n.code,{children:"absoluteH"})," set to -1 (default) to not override dimensions"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"cross-state-references",children:"Cross-State References"}),"\n",(0,a.jsx)(n.p,{children:"SearchRegionOnObject supports referencing objects from different states:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// In LoginState\nStateImage loginButton = new StateImage.Builder()\n    .addPatterns("login-button.png")\n    .setName("LoginButton")\n    .build();\n\n// In DashboardState - reference login button location\nStateImage notification = new StateImage.Builder()\n    .addPatterns("notification.png")\n    .setName("Notification")\n    .setSearchRegionOnObject(new SearchRegionOnObject.Builder()\n        .targetType(StateObject.Type.IMAGE)\n        .targetStateName("Login")  // Different state\n        .targetObjectName("LoginButton")\n        .yAdjust(-50)  // Above the login button\n        .build())\n    .build();\n'})}),"\n",(0,a.jsx)(n.h3,{id:"how-cross-state-dependencies-work",children:"How Cross-State Dependencies Work"}),"\n",(0,a.jsx)(n.p,{children:"When you define a cross-state dependency:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Registration Phase"}),": When states are loaded, the ",(0,a.jsx)(n.code,{children:"SearchRegionDependencyInitializer"})," automatically registers all dependencies with the ",(0,a.jsx)(n.code,{children:"DynamicRegionResolver"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Runtime Resolution"}),": When a FIND operation succeeds:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["The ",(0,a.jsx)(n.code,{children:"FindPipeline"})," calls ",(0,a.jsx)(n.code,{children:"updateDependentSearchRegions()"})]}),"\n",(0,a.jsx)(n.li,{children:"All objects depending on the found object have their search regions updated"}),"\n",(0,a.jsx)(n.li,{children:"The updates apply the configured adjustments"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Automatic Updates"}),": Search regions are dynamically updated each time the target object is found in a new location."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Example flow:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"// 1. ClaudePrompt is found at location (100, 200)\n// 2. ClaudeIcon's search region is automatically updated to (103, 210, width+30, height+55)\n// 3. Next search for ClaudeIcon uses this updated region\n"})}),"\n",(0,a.jsx)(n.h2,{id:"immediate-search-region-updates",children:"Immediate Search Region Updates"}),"\n",(0,a.jsx)(n.p,{children:"Starting with Brobot 1.1.0, search regions are updated immediately when dependencies are found, ensuring that dependent objects always use the most current region information."}),"\n",(0,a.jsx)(n.h3,{id:"how-immediate-updates-work",children:"How Immediate Updates Work"}),"\n",(0,a.jsx)(n.p,{children:"When using declarative regions with dependencies:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"During Search"}),": StateImages are automatically ordered by dependencies"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Images without dependencies are searched first"}),"\n",(0,a.jsx)(n.li,{children:"Dependent images are searched after their dependencies"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"On Match Found"}),": As soon as a match is found:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"All objects depending on the found object have their regions updated immediately"}),"\n",(0,a.jsx)(n.li,{children:"Remaining objects in the current search batch are updated before being searched"}),"\n",(0,a.jsx)(n.li,{children:"This ensures dependent objects always search in the correct location"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Example Flow"}),":"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// Given this setup:\nStateImage prompt = new StateImage.Builder()\n    .addPatterns("prompt.png")\n    .setName("ClaudePrompt")\n    .build();\n\nStateImage icon = new StateImage.Builder()\n    .addPatterns("icon.png")\n    .setName("ClaudeIcon")\n    .setSearchRegionOnObject(SearchRegionOnObject.builder()\n        .targetType(StateObject.Type.IMAGE)\n        .targetStateName("Prompt")\n        .targetObjectName("ClaudePrompt")\n        .adjustments(MatchAdjustmentOptions.builder()\n            .addX(3).addY(10).addW(30).addH(55)\n            .build())\n        .build())\n    .build();\n\n// When searching for both:\naction.perform(findOptions, prompt, icon);\n\n// The execution order is:\n// 1. Search for ClaudePrompt (no dependencies)\n// 2. If ClaudePrompt found at (100, 200):\n//    - ClaudeIcon\'s search region immediately updated to (103, 210, w+30, h+55)\n// 3. Search for ClaudeIcon in the updated region\n'})}),"\n",(0,a.jsx)(n.p,{children:"This immediate update mechanism ensures:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Dependent objects are always searched in the correct location"}),"\n",(0,a.jsx)(n.li,{children:"No wasted searches in incorrect regions"}),"\n",(0,a.jsx)(n.li,{children:"Better performance through targeted searching"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"integration-with-state-aware-scheduling",children:"Integration with State-Aware Scheduling"}),"\n",(0,a.jsx)(n.p,{children:"The declarative approach works seamlessly with StateAwareScheduler:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'@Service\npublic class MonitoringService {\n    \n    private final StateAwareScheduler scheduler;\n    private final WorkingState workingState;\n    \n    public void startMonitoring() {\n        // Configure state checking\n        StateCheckConfiguration config = new StateCheckConfiguration.Builder()\n            .withRequiredStates(List.of("Prompt", "Working"))\n            .build();\n        \n        // Schedule monitoring - regions are resolved automatically\n        scheduler.scheduleWithStateCheck(\n            executor,\n            this::checkIcon,\n            config,\n            5, 2, TimeUnit.SECONDS\n        );\n    }\n    \n    private void checkIcon() {\n        // The search region is automatically calculated based on\n        // the current location of ClaudePrompt in PromptState\n        ActionResult result = action.perform(\n            new PatternFindOptions.Builder().build(),\n            workingState.getClaudeIcon()\n        );\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Use Descriptive Names"}),": Give clear names to both source and target objects"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'.targetObject("HeaderNavigationBar")  // Clear and specific\n'})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Document Adjustments"}),": Comment on why specific adjustments are used"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:".adjustments(0, 50, 0, 0)  // Below header, same width\n"})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Consider State Dependencies"}),": Ensure target states are loaded when needed"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'.withRequiredStates(List.of("SourceState", "TargetState"))\n'})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Use Fixed Dimensions Sparingly"}),": Prefer relative sizing for responsiveness"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"// Good: Relative adjustment\n.wAdjust(20)  // Slightly wider than source\n\n// Use fixed only when necessary\n.width(100)   // Fixed width for consistent button size\n"})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"migration-from-manual-approach",children:"Migration from Manual Approach"}),"\n",(0,a.jsx)(n.p,{children:"To migrate existing code:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Identify Manual Region Calculations"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"// Old approach\nRegion baseRegion = findResult.getRegion();\nRegion searchRegion = new Region(\n    baseRegion.x() + 10,\n    baseRegion.y() + 50,\n    baseRegion.w() + 20,\n    baseRegion.h()\n);\nstateImage.setSearchRegions(searchRegion);\n"})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Convert to Declarative Definition"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// New approach\nstateImage = new StateImage.Builder()\n    .addPatterns("pattern.png")\n    .setSearchRegionOnObject(SearchRegionOnObject.builder()\n        .targetType(StateObject.Type.IMAGE)\n        .targetStateName("Base")  // @State removes "State" suffix from class name\n        .targetObjectName("BaseImage")\n        .adjustments(MatchAdjustmentOptions.builder()\n            .addX(10)\n            .addY(50)\n            .addW(20)\n            .addH(0)\n            .build())\n        .build())\n    .build();\n'})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Remove Manual Region Management"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Delete region calculation code"}),"\n",(0,a.jsx)(n.li,{children:"Remove region storage variables"}),"\n",(0,a.jsx)(n.li,{children:"Simplify action methods"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"implementation-architecture",children:"Implementation Architecture"}),"\n",(0,a.jsx)(n.p,{children:"The declarative region system consists of several key components:"}),"\n",(0,a.jsx)(n.h3,{id:"core-components",children:"Core Components"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"SearchRegionOnObject"}),": The configuration object that defines the dependency"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Holds target state/object information"}),"\n",(0,a.jsx)(n.li,{children:"Contains adjustment and dimension settings"}),"\n",(0,a.jsx)(n.li,{children:"Attached to StateImages during state construction"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"SearchRegionDependencyRegistry"}),": Tracks all dependencies"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Maps source objects to their dependents"}),"\n",(0,a.jsx)(n.li,{children:"Provides lookup for dependent objects when sources are found"}),"\n",(0,a.jsx)(n.li,{children:"Thread-safe for concurrent access"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"DynamicRegionResolver"}),": Resolves and updates regions"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Calculates actual regions based on found objects"}),"\n",(0,a.jsx)(n.li,{children:"Updates dependent object search regions"}),"\n",(0,a.jsx)(n.li,{children:"Handles both same-state and cross-state dependencies"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"SearchRegionDependencyInitializer"}),": Initializes the system"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Listens for ",(0,a.jsx)(n.code,{children:"StatesRegisteredEvent"})]}),"\n",(0,a.jsx)(n.li,{children:"Collects all StateObjects with dependencies"}),"\n",(0,a.jsx)(n.li,{children:"Registers them with the DynamicRegionResolver"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"FindPipeline Integration"}),": Triggers updates"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Calls ",(0,a.jsx)(n.code,{children:"updateDependentSearchRegions()"})," after successful finds"]}),"\n",(0,a.jsx)(n.li,{children:"Ensures dependent regions are updated before next search"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"initialization-flow",children:"Initialization Flow"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Application Start\n    \u2193\nStates Loaded (@State classes instantiated)\n    \u2193\nStatesRegisteredEvent Published\n    \u2193\nSearchRegionDependencyInitializer Receives Event\n    \u2193\nCollects All StateObjects with SearchRegionOnObject\n    \u2193\nRegisters Dependencies with DynamicRegionResolver\n    \u2193\nSystem Ready for Dynamic Region Updates\n"})}),"\n",(0,a.jsx)(n.h3,{id:"runtime-flow-updated-in-110",children:"Runtime Flow (Updated in 1.1.0+)"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"FIND Operation Starts\n    \u2193\nFindPipeline Orders StateImages by Dependencies\n    \u2193\nSearch for Non-Dependent Images First\n    \u2193\nFor Each Match Found:\n    - Immediately Update All Dependent Search Regions\n    - Clear Fixed Regions if Outside New Region\n    - Update Remaining Images in Current Batch\n    \u2193\nContinue Searching Dependent Images\n    \u2193\nAll Images Use Updated Regions\n"})}),"\n",(0,a.jsx)(n.p,{children:"Key changes in 1.1.0+:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Dependency Ordering"}),": Images are sorted so dependencies are resolved first"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Immediate Updates"}),": Regions update as soon as dependencies are found"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Batch Processing"}),": Remaining images in a search batch are updated before being searched"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Fixed Region Management"}),": Fixed regions are cleared proactively, not reactively"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"fixed-regions-and-declarative-regions",children:"Fixed Regions and Declarative Regions"}),"\n",(0,a.jsx)(n.h3,{id:"interaction-with-fixed-regions",children:"Interaction with Fixed Regions"}),"\n",(0,a.jsxs)(n.p,{children:["Fixed regions are automatically set when a StateImage with ",(0,a.jsx)(n.code,{children:"fixed=true"})," is found for the first time. This optimization improves performance by limiting future searches to the exact location where the pattern was previously found."]}),"\n",(0,a.jsx)(n.p,{children:"However, fixed regions can conflict with declarative regions when the UI layout changes. Brobot 1.1.0+ includes intelligent fixed region management:"}),"\n",(0,a.jsx)(n.h4,{id:"automatic-fixed-region-clearing",children:"Automatic Fixed Region Clearing"}),"\n",(0,a.jsxs)(n.p,{children:["When a declarative region is calculated based on ",(0,a.jsx)(n.code,{children:"SearchRegionOnObject"}),":"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Fixed Region Check"}),": The system checks if there's an existing fixed region"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Containment Test"}),": It verifies if the fixed region is within the new declarative region"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Automatic Clearing"}),": If the fixed region is outside the declarative region, it's automatically cleared"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Region Update"}),": The search region is updated to use the declarative region"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Important"}),": Fixed regions are cleared immediately when a declarative region is applied. This happens as soon as the dependency is found, not when the dependent object is searched."]}),"\n",(0,a.jsx)(n.p,{children:"This ensures that declarative regions take precedence when the UI layout changes:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"// Example scenario:\n// 1. ClaudeIcon is found at (100, 200) and sets a fixed region\n// 2. User moves the window, ClaudePrompt is now at (500, 300)\n// 3. ClaudeIcon's declarative region is calculated as (503, 310, w+30, h+55)\n// 4. Fixed region (100, 200) is outside the new region \u2192 automatically cleared\n// 5. Next search uses the declarative region (503, 310, w+30, h+55)\n"})}),"\n",(0,a.jsx)(n.h4,{id:"best-practices-for-fixed-regions",children:"Best Practices for Fixed Regions"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Don't Set ActionHistory with Declarative Regions"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// \u274c WRONG: ActionHistory creates a fixed region that conflicts\nStateImage icon = new StateImage.Builder()\n    .addPatterns("icon.png")\n    .setSearchRegionOnObject(...)\n    .withActionHistory(MockActionHistoryBuilder.Presets.reliable(region))\n    .build();\n\n// \u2705 CORRECT: Let declarative regions manage the search area\nStateImage icon = new StateImage.Builder()\n    .addPatterns("icon.png")\n    .setSearchRegionOnObject(...)\n    .build();\n'})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Use Fixed Regions for Static UI Elements"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// Good for elements that never move\nStateImage logo = new StateImage.Builder()\n    .addPatterns("company-logo.png")\n    .setFixed(true)  // Will lock to first found location\n    .build();\n'})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Use Declarative Regions for Dynamic UI"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// Good for elements that move relative to others\nStateImage button = new StateImage.Builder()\n    .addPatterns("submit-button.png")\n    .setSearchRegionOnObject(...)  // Adapts to UI changes\n    .build();\n'})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"debugging-fixed-region-conflicts",children:"Debugging Fixed Region Conflicts"}),"\n",(0,a.jsx)(n.p,{children:"Enable debug logging to see when fixed regions are cleared:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-properties",children:"logging.level.io.github.jspinak.brobot.action.internal.region.DynamicRegionResolver=DEBUG\n"})}),"\n",(0,a.jsx)(n.p,{children:"Log output will show:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"INFO: Fixed region R[100,200,50,50] for ClaudeIcon is outside new declarative region R[503,310,80,105], clearing fixed region\n"})}),"\n",(0,a.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,a.jsx)(n.h3,{id:"region-not-found",children:"Region Not Found"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Verify target state and object names match exactly"}),"\n",(0,a.jsx)(n.li,{children:"Ensure target state is active when searching"}),"\n",(0,a.jsx)(n.li,{children:"Check that target object has been found at least once"}),"\n",(0,a.jsxs)(n.li,{children:["Enable logging: ",(0,a.jsx)(n.code,{children:"logging.level.io.github.jspinak.brobot.action.internal.region=DEBUG"})]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"incorrect-region-position",children:"Incorrect Region Position"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Log the resolved region for debugging:","\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'ActionResult result = action.perform(findOptions, stateImage);\nlog.info("Search region: {}", result.getSearchedRegion());\n'})}),"\n"]}),"\n",(0,a.jsx)(n.li,{children:"Adjust the adjustment values incrementally"}),"\n",(0,a.jsxs)(n.li,{children:["Consider using visual feedback:","\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"action.perform(new HighlightOptions.Builder().build(), stateImage);\n"})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"dependencies-not-working",children:"Dependencies Not Working"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Verify SearchRegionDependencyInitializer is being instantiated"}),"\n",(0,a.jsx)(n.li,{children:'Check logs for "Registered search region dependency" messages'}),"\n",(0,a.jsx)(n.li,{children:"Ensure Spring component scanning includes brobot packages"}),"\n",(0,a.jsx)(n.li,{children:"Verify target object names match exactly (case-sensitive)"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"fixed-region-overriding-declarative-region",children:"Fixed Region Overriding Declarative Region"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Check if you're setting ActionHistory on the StateImage (remove it)"}),"\n",(0,a.jsx)(n.li,{children:"Enable debug logging to see if fixed region is being cleared"}),"\n",(0,a.jsx)(n.li,{children:"Verify the declarative region is being calculated correctly"}),"\n",(0,a.jsxs)(n.li,{children:["Consider manually resetting the fixed region:","\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"stateImage.getPatterns().forEach(pattern -> {\n    pattern.getSearchRegions().resetFixedRegion();\n    pattern.setFixed(false);\n});\n"})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Region resolution happens on each search"}),"\n",(0,a.jsx)(n.li,{children:"Dependencies are registered once at startup"}),"\n",(0,a.jsx)(n.li,{children:"Updates only occur when source objects are found"}),"\n",(0,a.jsx)(n.li,{children:"Consider using fixed regions for static layouts"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"complete-example-real-world-usage",children:"Complete Example: Real-World Usage"}),"\n",(0,a.jsx)(n.p,{children:"Here's a complete example showing all the new features working together:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'@State(initial = true)\npublic class PromptState {\n    private final StateImage claudePrompt;\n    \n    public PromptState() {\n        claudePrompt = new StateImage.Builder()\n            .addPatterns("prompt/claude-prompt.png")\n            .setName("ClaudePrompt")\n            .build();\n    }\n}\n\n@State\npublic class WorkingState {\n    private final StateImage claudeIcon;\n    \n    public WorkingState() {\n        // Icon depends on prompt location\n        claudeIcon = new StateImage.Builder()\n            .addPatterns("working/claude-icon-1.png",\n                        "working/claude-icon-2.png")\n            .setName("ClaudeIcon")\n            .setFixed(true)  // Will be cleared when prompt moves\n            .setSearchRegionOnObject(SearchRegionOnObject.builder()\n                .targetType(StateObject.Type.IMAGE)\n                .targetStateName("Prompt")\n                .targetObjectName("ClaudePrompt")\n                .adjustments(MatchAdjustmentOptions.builder()\n                    .addX(3).addY(10).addW(30).addH(55)\n                    .build())\n                .build())\n            .build();\n    }\n}\n\n// In your automation code:\npublic class ClaudeAutomator {\n    @Autowired\n    private Action action;\n    \n    @Autowired\n    private PromptState promptState;\n    \n    @Autowired\n    private WorkingState workingState;\n    \n    public void findElements() {\n        // Search for both - dependency ordering happens automatically\n        ActionResult result = action.perform(\n            new PatternFindOptions.Builder().build(),\n            promptState.getClaudePrompt(),\n            workingState.getClaudeIcon()\n        );\n        \n        // What happens internally:\n        // 1. FindPipeline orders images: ClaudePrompt first (no dependencies)\n        // 2. ClaudePrompt is found at (100, 200)\n        // 3. ClaudeIcon\'s search region immediately updated to (103, 210, w+30, h+55)\n        // 4. ClaudeIcon\'s fixed region (if any) is cleared\n        // 5. ClaudeIcon is searched in the updated region\n        // 6. If found, ClaudeIcon sets a new fixed region at the found location\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"key-benefits-of-the-new-implementation",children:"Key Benefits of the New Implementation"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"No Manual Region Management"}),": Dependencies are resolved automatically"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Immediate Updates"}),": Search regions update as soon as dependencies are found"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Intelligent Fixed Region Handling"}),": Fixed regions cleared when they conflict with declarative regions"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Optimized Search Order"}),": Dependencies are searched in the correct order"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Better Performance"}),": Fewer false matches due to targeted searching"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsx)(n.p,{children:"Declarative region definition in Brobot 1.1.0+ provides:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Cleaner, more maintainable code"}),"\n",(0,a.jsx)(n.li,{children:"Dynamic adaptation to UI changes"}),"\n",(0,a.jsx)(n.li,{children:"Better separation of concerns"}),"\n",(0,a.jsx)(n.li,{children:"Seamless integration with state management"}),"\n",(0,a.jsx)(n.li,{children:"Immediate search region updates for optimal performance"}),"\n",(0,a.jsx)(n.li,{children:"Intelligent fixed region management"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"By defining regions declaratively, you create more robust automation that adapts to UI variations while keeping your action code focused on business logic rather than region calculations."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);
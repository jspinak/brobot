"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3969],{28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var a=t(96540);const r={},i=a.createContext(r);function s(e){const n=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(i.Provider,{value:n},e.children)}},55016:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"core-library/action-config/reusable-patterns","title":"Reusable Patterns","description":"Build a library of reusable automation patterns and components","source":"@site/docs/03-core-library/action-config/11-reusable-patterns.md","sourceDirName":"03-core-library/action-config","slug":"/core-library/action-config/reusable-patterns","permalink":"/brobot/docs/core-library/action-config/reusable-patterns","draft":false,"unlisted":false,"editUrl":"https://github.com/jspinak/brobot/edit/main/docs/docs/03-core-library/action-config/11-reusable-patterns.md","tags":[],"version":"current","sidebarPosition":11,"frontMatter":{"sidebar_position":11,"title":"Reusable Patterns","description":"Build a library of reusable automation patterns and components"},"sidebar":"docSidebar","previous":{"title":"Form Automation Patterns","permalink":"/brobot/docs/core-library/action-config/form-automation"},"next":{"title":"Complete Migration Guide","permalink":"/brobot/docs/core-library/action-config/migration-guide"}}');var r=t(74848),i=t(28453);const s={sidebar_position:11,title:"Reusable Patterns",description:"Build a library of reusable automation patterns and components"},o="Reusable Automation Patterns",l={},c=[{value:"Pattern Library Architecture",id:"pattern-library-architecture",level:2},{value:"Base Pattern Interface",id:"base-pattern-interface",level:3},{value:"Common UI Patterns",id:"common-ui-patterns",level:2},{value:"Login Pattern",id:"login-pattern",level:3},{value:"Search Pattern",id:"search-pattern",level:3},{value:"Menu Navigation Pattern",id:"menu-navigation-pattern",level:3},{value:"Composite Patterns",id:"composite-patterns",level:2},{value:"Form Submission Pattern",id:"form-submission-pattern",level:3},{value:"Pattern Factories",id:"pattern-factories",level:2},{value:"Dynamic Pattern Creation",id:"dynamic-pattern-creation",level:3},{value:"Pattern Composition",id:"pattern-composition",level:2},{value:"Sequential Pattern Executor",id:"sequential-pattern-executor",level:3},{value:"Conditional Pattern Executor",id:"conditional-pattern-executor",level:3},{value:"Testing Patterns",id:"testing-patterns",level:2},{value:"Pattern Test Framework",id:"pattern-test-framework",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Design for Reusability",id:"1-design-for-reusability",level:3},{value:"2. Implement Validation",id:"2-implement-validation",level:3},{value:"3. Handle Errors Gracefully",id:"3-handle-errors-gracefully",level:3},{value:"4. Document Patterns",id:"4-document-patterns",level:3},{value:"5. Version Patterns",id:"5-version-patterns",level:3},{value:"Next Steps",id:"next-steps",level:2}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"reusable-automation-patterns",children:"Reusable Automation Patterns"})}),"\n",(0,r.jsx)(n.p,{children:"Creating reusable patterns is key to building maintainable and scalable automation solutions. This guide shows how to create modular, composable automation components that can be shared across projects."}),"\n",(0,r.jsx)(n.h2,{id:"pattern-library-architecture",children:"Pattern Library Architecture"}),"\n",(0,r.jsx)(n.h3,{id:"base-pattern-interface",children:"Base Pattern Interface"}),"\n",(0,r.jsx)(n.p,{children:"Start with a common interface for all patterns:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'public interface AutomationPattern {\n    String getName();\n    String getDescription();\n    boolean execute(PatternContext context);\n    boolean validate(PatternContext context);\n}\n\npublic class PatternContext {\n    private final Map<String, Object> parameters = new HashMap<>();\n    private final Map<String, StateImage> images = new HashMap<>();\n    private final Map<String, ObjectCollection> collections = new HashMap<>();\n    \n    public PatternContext withParameter(String key, Object value) {\n        parameters.put(key, value);\n        return this;\n    }\n    \n    public PatternContext withImage(String key, StateImage image) {\n        images.put(key, image);\n        return this;\n    }\n    \n    public PatternContext withCollection(String key, ObjectCollection collection) {\n        collections.put(key, collection);\n        return this;\n    }\n    \n    // Getters with type safety\n    @SuppressWarnings("unchecked")\n    public <T> T getParameter(String key, Class<T> type) {\n        return (T) parameters.get(key);\n    }\n    \n    public StateImage getImage(String key) {\n        return images.get(key);\n    }\n    \n    public ObjectCollection getCollection(String key) {\n        return collections.get(key);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"common-ui-patterns",children:"Common UI Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"login-pattern",children:"Login Pattern"}),"\n",(0,r.jsx)(n.p,{children:"A reusable login pattern that works across different applications:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'public class LoginPattern implements AutomationPattern {\n    private static final String USERNAME_FIELD = "usernameField";\n    private static final String PASSWORD_FIELD = "passwordField";\n    private static final String LOGIN_BUTTON = "loginButton";\n    private static final String SUCCESS_INDICATOR = "successIndicator";\n    \n    @Override\n    public String getName() {\n        return "Standard Login Flow";\n    }\n    \n    @Override\n    public String getDescription() {\n        return "Handles username/password login with success verification";\n    }\n    \n    @Override\n    public boolean validate(PatternContext context) {\n        // Validate required elements\n        return context.getImage(USERNAME_FIELD) != null &&\n               context.getImage(PASSWORD_FIELD) != null &&\n               context.getImage(LOGIN_BUTTON) != null &&\n               context.getParameter("username", String.class) != null &&\n               context.getParameter("password", String.class) != null;\n    }\n    \n    @Override\n    public boolean execute(PatternContext context) {\n        if (!validate(context)) {\n            throw new IllegalArgumentException("Invalid context for LoginPattern");\n        }\n        \n        String username = context.getParameter("username", String.class);\n        String password = context.getParameter("password", String.class);\n        \n        // Build the login chain\n        ActionChainOptions loginChain = new ActionChainOptions.Builder(\n            // Click username field\n            new ClickOptions.Builder()\n                .setPauseAfterEnd(0.3)\n                .build())\n            // Clear and type username\n            .then(new TypeOptions.Builder()\n                .setText(username)\n                .setClearFirst(true)\n                .build())\n            // Tab to password field\n            .then(new TypeOptions.Builder()\n                .setText("\\t")\n                .build())\n            // Type password\n            .then(new TypeOptions.Builder()\n                .setText(password)\n                .build())\n            // Click login button\n            .then(new ClickOptions.Builder()\n                .setPauseAfterEnd(1.0)\n                .build())\n            .build();\n        \n        // Execute the chain\n        ActionResult result = executeChain(loginChain,\n            context.getImage(USERNAME_FIELD).asObjectCollection(),\n            new ObjectCollection.Builder().withStrings(username).build(),\n            new ObjectCollection.Builder().withStrings("\\t").build(),\n            new ObjectCollection.Builder().withStrings(password).build(),\n            context.getImage(LOGIN_BUTTON).asObjectCollection()\n        );\n        \n        if (!result.isSuccess()) {\n            return false;\n        }\n        \n        // Verify success if indicator provided\n        StateImage successIndicator = context.getImage(SUCCESS_INDICATOR);\n        if (successIndicator != null) {\n            return waitForImage(successIndicator, 5.0);\n        }\n        \n        return true;\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"search-pattern",children:"Search Pattern"}),"\n",(0,r.jsx)(n.p,{children:"A flexible search pattern for various search interfaces:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'public class SearchPattern implements AutomationPattern {\n    \n    @Override\n    public boolean execute(PatternContext context) {\n        StateImage searchField = context.getImage("searchField");\n        StateImage searchButton = context.getImage("searchButton");\n        String searchTerm = context.getParameter("searchTerm", String.class);\n        boolean pressEnter = context.getParameter("pressEnter", Boolean.class);\n        \n        // Click search field\n        if (!click(searchField)) {\n            return false;\n        }\n        \n        // Clear existing text\n        clearField();\n        \n        // Type search term\n        if (!type(searchTerm)) {\n            return false;\n        }\n        \n        // Submit search\n        if (pressEnter) {\n            return type("\\n");\n        } else if (searchButton != null) {\n            return click(searchButton);\n        }\n        \n        return false;\n    }\n    \n    private void clearField() {\n        // Ctrl+A and Delete\n        ActionChainOptions clearChain = new ActionChainOptions.Builder(\n            new KeyDownOptions.Builder()\n                .setKey("ctrl")\n                .build())\n            .then(new TypeOptions.Builder()\n                .setText("a")\n                .build())\n            .then(new KeyUpOptions.Builder()\n                .setKey("ctrl")\n                .build())\n            .then(new TypeOptions.Builder()\n                .setText("\\b")\n                .build())\n            .build();\n        \n        executeChain(clearChain);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"menu-navigation-pattern",children:"Menu Navigation Pattern"}),"\n",(0,r.jsx)(n.p,{children:"Navigate through hierarchical menus:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'public class MenuNavigationPattern implements AutomationPattern {\n    \n    @Override\n    public boolean execute(PatternContext context) {\n        List<String> menuPath = context.getParameter("menuPath", List.class);\n        Double pauseBetween = context.getParameter("pauseBetween", Double.class);\n        \n        if (pauseBetween == null) {\n            pauseBetween = 0.5;\n        }\n        \n        // Build dynamic chain for menu navigation\n        ActionChainOptions.Builder chainBuilder = null;\n        \n        for (int i = 0; i < menuPath.size(); i++) {\n            String menuItem = menuPath.get(i);\n            StateImage menuImage = context.getImage(menuItem);\n            \n            if (menuImage == null) {\n                logger.error("Menu item not found: {}", menuItem);\n                return false;\n            }\n            \n            // First action\n            if (chainBuilder == null) {\n                chainBuilder = new ActionChainOptions.Builder(\n                    new ClickOptions.Builder()\n                        .setPauseAfterEnd(pauseBetween)\n                        .build()\n                );\n            } else {\n                // Subsequent actions\n                chainBuilder.then(new ClickOptions.Builder()\n                    .setPauseAfterEnd(pauseBetween)\n                    .build());\n            }\n        }\n        \n        if (chainBuilder == null) {\n            return false;\n        }\n        \n        // Execute the navigation chain\n        return executeMenuChain(chainBuilder.build(), menuPath, context);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"composite-patterns",children:"Composite Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"form-submission-pattern",children:"Form Submission Pattern"}),"\n",(0,r.jsx)(n.p,{children:"Combines multiple patterns for complex form handling:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'public class FormSubmissionPattern implements AutomationPattern {\n    private final Map<String, FieldPattern> fieldPatterns = new HashMap<>();\n    \n    public FormSubmissionPattern() {\n        // Register field type handlers\n        fieldPatterns.put("text", new TextFieldPattern());\n        fieldPatterns.put("dropdown", new DropdownPattern());\n        fieldPatterns.put("checkbox", new CheckboxPattern());\n        fieldPatterns.put("radio", new RadioButtonPattern());\n    }\n    \n    @Override\n    public boolean execute(PatternContext context) {\n        List<FieldDefinition> fields = context.getParameter("fields", List.class);\n        StateImage submitButton = context.getImage("submitButton");\n        \n        // Process each field\n        for (FieldDefinition field : fields) {\n            FieldPattern pattern = fieldPatterns.get(field.getType());\n            \n            if (pattern == null) {\n                logger.error("Unknown field type: {}", field.getType());\n                return false;\n            }\n            \n            // Create field context\n            PatternContext fieldContext = new PatternContext()\n                .withImage("field", field.getImage())\n                .withParameter("value", field.getValue())\n                .withParameter("options", field.getOptions());\n            \n            if (!pattern.execute(fieldContext)) {\n                logger.error("Failed to fill field: {}", field.getName());\n                return false;\n            }\n        }\n        \n        // Submit form\n        return click(submitButton);\n    }\n    \n    public static class FieldDefinition {\n        private final String name;\n        private final String type;\n        private final StateImage image;\n        private final Object value;\n        private final Map<String, Object> options;\n        \n        // Constructor and getters...\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"pattern-factories",children:"Pattern Factories"}),"\n",(0,r.jsx)(n.h3,{id:"dynamic-pattern-creation",children:"Dynamic Pattern Creation"}),"\n",(0,r.jsx)(n.p,{children:"Create patterns dynamically based on configuration:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'public class PatternFactory {\n    private final Map<String, Class<? extends AutomationPattern>> patternRegistry;\n    \n    public PatternFactory() {\n        patternRegistry = new HashMap<>();\n        registerDefaultPatterns();\n    }\n    \n    private void registerDefaultPatterns() {\n        register("login", LoginPattern.class);\n        register("search", SearchPattern.class);\n        register("menu", MenuNavigationPattern.class);\n        register("form", FormSubmissionPattern.class);\n    }\n    \n    public void register(String name, Class<? extends AutomationPattern> patternClass) {\n        patternRegistry.put(name, patternClass);\n    }\n    \n    public AutomationPattern create(String name) {\n        Class<? extends AutomationPattern> patternClass = patternRegistry.get(name);\n        \n        if (patternClass == null) {\n            throw new IllegalArgumentException("Unknown pattern: " + name);\n        }\n        \n        try {\n            return patternClass.getDeclaredConstructor().newInstance();\n        } catch (Exception e) {\n            throw new RuntimeException("Failed to create pattern: " + name, e);\n        }\n    }\n    \n    public AutomationPattern createFromConfig(PatternConfig config) {\n        AutomationPattern pattern = create(config.getType());\n        \n        // Apply any custom configuration\n        if (pattern instanceof ConfigurablePattern) {\n            ((ConfigurablePattern) pattern).configure(config);\n        }\n        \n        return pattern;\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"pattern-composition",children:"Pattern Composition"}),"\n",(0,r.jsx)(n.h3,{id:"sequential-pattern-executor",children:"Sequential Pattern Executor"}),"\n",(0,r.jsx)(n.p,{children:"Execute multiple patterns in sequence:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'public class SequentialPatternExecutor {\n    \n    public boolean executeSequence(List<PatternExecution> executions) {\n        for (PatternExecution execution : executions) {\n            logger.info("Executing pattern: {}", execution.getPattern().getName());\n            \n            if (!execution.getPattern().execute(execution.getContext())) {\n                logger.error("Pattern failed: {}", execution.getPattern().getName());\n                \n                if (!execution.isContinueOnFailure()) {\n                    return false;\n                }\n            }\n        }\n        \n        return true;\n    }\n    \n    public static class PatternExecution {\n        private final AutomationPattern pattern;\n        private final PatternContext context;\n        private final boolean continueOnFailure;\n        \n        // Constructor and getters...\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"conditional-pattern-executor",children:"Conditional Pattern Executor"}),"\n",(0,r.jsx)(n.p,{children:"Execute patterns based on conditions:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public class ConditionalPatternExecutor {\n    \n    public boolean executeConditional(ConditionalExecution execution) {\n        // Evaluate condition\n        if (!execution.getCondition().evaluate()) {\n            // Execute else pattern if provided\n            if (execution.getElsePattern() != null) {\n                return execution.getElsePattern().execute(execution.getContext());\n            }\n            return true; // No else pattern, consider success\n        }\n        \n        // Execute main pattern\n        return execution.getPattern().execute(execution.getContext());\n    }\n    \n    public interface PatternCondition {\n        boolean evaluate();\n    }\n    \n    public static class ImageExistsCondition implements PatternCondition {\n        private final StateImage image;\n        \n        @Override\n        public boolean evaluate() {\n            return find(image);\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"testing-patterns",children:"Testing Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"pattern-test-framework",children:"Pattern Test Framework"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'public abstract class PatternTest {\n    protected PatternFactory factory;\n    protected MockActionExecutor mockExecutor;\n    \n    @Before\n    public void setUp() {\n        factory = new PatternFactory();\n        mockExecutor = new MockActionExecutor();\n    }\n    \n    protected void assertPatternSuccess(String patternName, PatternContext context) {\n        AutomationPattern pattern = factory.create(patternName);\n        assertTrue("Pattern validation failed", pattern.validate(context));\n        assertTrue("Pattern execution failed", pattern.execute(context));\n    }\n    \n    protected void assertPatternFailure(String patternName, PatternContext context) {\n        AutomationPattern pattern = factory.create(patternName);\n        assertFalse("Pattern should have failed", pattern.execute(context));\n    }\n}\n\npublic class LoginPatternTest extends PatternTest {\n    \n    @Test\n    public void testSuccessfulLogin() {\n        PatternContext context = new PatternContext()\n            .withImage("usernameField", mockImage("username"))\n            .withImage("passwordField", mockImage("password"))\n            .withImage("loginButton", mockImage("login"))\n            .withParameter("username", "testuser")\n            .withParameter("password", "testpass");\n        \n        assertPatternSuccess("login", context);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"1-design-for-reusability",children:"1. Design for Reusability"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Use generic parameter names"}),"\n",(0,r.jsx)(n.li,{children:"Provide sensible defaults"}),"\n",(0,r.jsx)(n.li,{children:"Make patterns configurable"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"2-implement-validation",children:"2. Implement Validation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"@Override\npublic boolean validate(PatternContext context) {\n    // Check all required parameters\n    // Verify image availability\n    // Validate parameter types\n    return true;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-handle-errors-gracefully",children:"3. Handle Errors Gracefully"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'try {\n    return executePattern(context);\n} catch (Exception e) {\n    logger.error("Pattern execution failed", e);\n    return handlePatternError(e);\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"4-document-patterns",children:"4. Document Patterns"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@PatternDoc(\n    name = "Login Pattern",\n    description = "Handles standard username/password login flows",\n    requiredImages = {"usernameField", "passwordField", "loginButton"},\n    requiredParams = {"username", "password"},\n    optionalImages = {"successIndicator"},\n    example = "context.withParameter(\'username\', \'user\').withParameter(\'password\', \'pass\')"\n)\npublic class LoginPattern implements AutomationPattern {\n    // Implementation\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"5-version-patterns",children:"5. Version Patterns"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public interface VersionedPattern extends AutomationPattern {\n    String getVersion();\n    boolean isCompatibleWith(String version);\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Explore ",(0,r.jsx)(n.a,{href:"/brobot/docs/core-library/action-config/migration-guide",children:"Migration Guide"})," for updating legacy patterns"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}}}]);
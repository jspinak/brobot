"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3894],{28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var i=n(96540);const s={},o=i.createContext(s);function r(e){const t=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:t},e.children)}},43607:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/transitions-c388f3c755a4df88c4c15f76e021e687.png"},90069:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>l,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"getting-started/transitions","title":"Transitions","description":"Introduction","source":"@site/versioned_docs/version-1.0.7/01-getting-started/transitions.md","sourceDirName":"01-getting-started","slug":"/getting-started/transitions","permalink":"/brobot/docs/1.0.7/getting-started/transitions","draft":false,"unlisted":false,"editUrl":"https://github.com/jspinak/brobot/edit/main/docs/versioned_docs/version-1.0.7/01-getting-started/transitions.md","tags":[],"version":"1.0.7","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Transitions"},"sidebar":"docSidebar","previous":{"title":"States","permalink":"/brobot/docs/1.0.7/getting-started/states"},"next":{"title":"The Action Hierarchy","permalink":"/brobot/docs/1.0.7/getting-started/action-hierarchy"}}');var s=n(74848),o=n(28453);const r={sidebar_position:4,title:"Transitions"},a="Transitions",d={},c=[{value:"Introduction",id:"introduction",level:2},{value:"The Brobot Implementation: FromTransition and ToTransition",id:"the-brobot-implementation-fromtransition-and-totransition",level:2},{value:"Defining Transitions in Code",id:"defining-transitions-in-code",level:3},{value:"The Formal Model (Under the Hood)",id:"the-formal-model-under-the-hood",level:2},{value:"Dynamic Transitions for Hidden States",id:"dynamic-transitions-for-hidden-states",level:2}];function h(e){const t={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"transitions",children:"Transitions"})}),"\n",(0,s.jsx)(t.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsxs)(t.p,{children:['While States define "where you can be" in a GUI, ',(0,s.jsx)(t.strong,{children:"Transitions"}),' define "how you get there." Every State that is reachable needs an associated ',(0,s.jsx)(t.code,{children:"StateTransitions"})," class that defines the pathways to and from other states."]}),"\n",(0,s.jsx)(t.p,{children:'Formally, a transition is a process or a sequence of actions that changes the GUI from one state to another.  They form the "edges" of the state graph and are the building blocks used by the framework\'s pathfinder to navigate the application.'}),"\n",(0,s.jsx)(t.h2,{id:"the-brobot-implementation-fromtransition-and-totransition",children:"The Brobot Implementation: FromTransition and ToTransition"}),"\n",(0,s.jsxs)(t.p,{children:["Brobot implements this concept by splitting transitions into two types: ",(0,s.jsx)(t.strong,{children:"FromTransitions"})," and ",(0,s.jsx)(t.strong,{children:"ToTransitions"}),".  This two-part system provides a clear and reusable structure for managing navigation logic."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.img,{alt:"Transition Diagram",src:n(43607).A+"",width:"623",height:"196"}),"\n",(0,s.jsx)(t.em,{children:"This diagram is based on Figure 8 from the research paper."})]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"FromTransition"}),": This handles the process of leaving the ",(0,s.jsx)(t.em,{children:"current"})," state to go to another state. For example, to go from ",(0,s.jsx)(t.code,{children:"State A"})," to ",(0,s.jsx)(t.code,{children:"State B"}),", the FromTransition ",(0,s.jsx)(t.code,{children:"A -> B"})," is called. It contains the specific actions needed to initiate the move from State A."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"ToTransition"}),": This handles the final steps of arriving at a new state, regardless of which state started the process. There can be multiple FromTransitions going to ",(0,s.jsx)(t.code,{children:"State B"})," from different states, but there is only one ToTransition for ",(0,s.jsx)(t.code,{children:"State B"}),". This ",(0,s.jsx)(t.code,{children:"-> B"})," transition contains generic actions that must always run to confirm ",(0,s.jsx)(t.code,{children:"State B"})," is active."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"defining-transitions-in-code",children:"Defining Transitions in Code"}),"\n",(0,s.jsxs)(t.p,{children:["In the ",(0,s.jsx)(t.code,{children:"StateTransitions"})," Builder, you define these two types of transitions using specific commands:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"addTransitionFinish"})," creates the ToTransition. The method passed to it is typically named ",(0,s.jsx)(t.code,{children:"finishTransition()"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"addTransition"})," creates a FromTransition. The methods passed to it can have any name and contain the actions for that specific path."]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"// From the DoT test application in the paper \npublic class WorldTransitions {\n    // ...\n    StateTransitions transitions =\n        new StateTransitions.Builder(WORLD) // Defines transitions from the WORLD state\n            .addTransitionFinish(this::finishTransition) // This is the ToTransition for WORLD\n            .addTransition(new StateTransition.Builder() // This is a FromTransition\n                .addToActivate(ISLAND) // The target state is ISLAND\n                .setFunction(this::goToIsland) // The method with the actions\n                .build())\n            .build();\n    // ...\n}\n"})}),"\n",(0,s.jsx)(t.h2,{id:"the-formal-model-under-the-hood",children:"The Formal Model (Under the Hood)"}),"\n",(0,s.jsxs)(t.p,{children:["The academic paper provides a formal definition for a transition as a tuple ",(0,s.jsxs)(t.strong,{children:["t = (A, S",(0,s.jsx)("sub",{children:"t"}),(0,s.jsx)("sup",{children:"def"}),")"]}),"."]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"A"})," is a ",(0,s.jsx)(t.strong,{children:"process"}),", which is a sequence of one or more actions ",(0,s.jsx)(t.code,{children:"(a\xb9, a\xb2, ..., a\u207f)"}),".  This corresponds to the method you pass to the builder (e.g., ",(0,s.jsx)(t.code,{children:"goToIsland"}),")."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsxs)(t.strong,{children:["S",(0,s.jsx)("sub",{children:"t"}),(0,s.jsx)("sup",{children:"def"})]})," is the ",(0,s.jsx)(t.strong,{children:"intended state information"}),".  This is an explicit definition of which states should become active or inactive if the transition succeeds. This makes state management more robust and predictable, as the framework doesn't have to guess the outcome.  This corresponds to builder methods like ",(0,s.jsx)(t.code,{children:".addToActivate(ISLAND)"}),"."]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"dynamic-transitions-for-hidden-states",children:"Dynamic Transitions for Hidden States"}),"\n",(0,s.jsx)(t.p,{children:'In addition to these statically defined transitions, Brobot also supports dynamic transitions to handle common UI patterns like menus and pop-ups. When a state opens and covers another, the covered state is registered as "hidden."'}),"\n",(0,s.jsxs)(t.p,{children:["You can then define a transition with a dynamic target called ",(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.code,{children:"PREVIOUS"})}),". When this transition is executed (e.g., by closing the menu), the framework intelligently navigates back to whatever state was most recently hidden, without you needing to pre-define every possible combination."]})]})}function l(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}}}]);
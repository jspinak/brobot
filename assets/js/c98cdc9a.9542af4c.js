"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8509],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var i=t(96540);const a={},s=i.createContext(a);function r(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(s.Provider,{value:n},e.children)}},48815:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"core-library/guides/dynamic-transitions","title":"Dynamic Transitions and Hidden States","description":"Overview","source":"@site/docs/03-core-library/guides/dynamic-transitions.md","sourceDirName":"03-core-library/guides","slug":"/core-library/guides/dynamic-transitions","permalink":"/brobot/docs/core-library/guides/dynamic-transitions","draft":false,"unlisted":false,"editUrl":"https://github.com/jspinak/brobot/edit/main/docs/docs/03-core-library/guides/dynamic-transitions.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7,"title":"Dynamic Transitions and Hidden States"},"sidebar":"docSidebar","previous":{"title":"Processes as Objects","permalink":"/brobot/docs/core-library/guides/processes-as-objects"},"next":{"title":"Pathfinding and Path Costs","permalink":"/brobot/docs/core-library/guides/pathfinding-and-costs"}}');var a=t(74848),s=t(28453);const r={sidebar_position:7,title:"Dynamic Transitions and Hidden States"},o="Dynamic Transitions and Hidden States",l={},c=[{value:"Overview",id:"overview",level:2},{value:"The Problem",id:"the-problem",level:2},{value:"The Solution: Hidden States",id:"the-solution-hidden-states",level:2},{value:"Special Marker Classes",id:"special-marker-classes",level:2},{value:"\u2705 Currently Implemented",id:"-currently-implemented",level:3},{value:"\u26a0\ufe0f Future Consideration",id:"\ufe0f-future-consideration",level:3},{value:"Understanding Each Special State Type",id:"understanding-each-special-state-type",level:2},{value:"PreviousState - Return to Hidden State",id:"previousstate---return-to-hidden-state",level:3},{value:"CurrentState - Self-Transitions",id:"currentstate---self-transitions",level:3},{value:"ExpectedState - Runtime-Determined (Not Yet Implemented)",id:"expectedstate---runtime-determined-not-yet-implemented",level:3},{value:"Understanding UnknownState (Not a Special Marker)",id:"understanding-unknownstate-not-a-special-marker",level:2},{value:"How UnknownState Works",id:"how-unknownstate-works",level:3},{value:"Complete Working Example: Special States",id:"complete-working-example-special-states",level:2},{value:"Modal Dialog State with PreviousState",id:"modal-dialog-state-with-previousstate",level:3},{value:"Modal Dialog Transitions Using PreviousState",id:"modal-dialog-transitions-using-previousstate",level:3},{value:"Main Page with CurrentState Self-Transitions",id:"main-page-with-currentstate-self-transitions",level:3},{value:"Generic Data Grid Example with Self-Transitions",id:"generic-data-grid-example-with-self-transitions",level:3},{value:"Multi-Level Overlays",id:"multi-level-overlays",level:3},{value:"Decision Guide",id:"decision-guide",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Use PreviousState for True Overlays",id:"1-use-previousstate-for-true-overlays",level:3},{value:"2. Use CurrentState for In-Page Actions",id:"2-use-currentstate-for-in-page-actions",level:3},{value:"3. Provide Fallbacks",id:"3-provide-fallbacks",level:3},{value:"4. Clear Visual Indicators",id:"4-clear-visual-indicators",level:3},{value:"5. Handle Edge Cases",id:"5-handle-edge-cases",level:3},{value:"Framework Components",id:"framework-components",level:2},{value:"Special Marker Classes",id:"special-marker-classes-1",level:3},{value:"TransitionSetProcessor",id:"transitionsetprocessor",level:3},{value:"SetHiddenStates",id:"sethiddenstates",level:3},{value:"StateMemory",id:"statememory",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Hidden State Not Found",id:"hidden-state-not-found",level:3},{value:"Self-Transitions Not Working",id:"self-transitions-not-working",level:3},{value:"Multiple States Claiming to be Active",id:"multiple-states-claiming-to-be-active",level:3},{value:"Migration from Old Annotations",id:"migration-from-old-annotations",level:2},{value:"Summary",id:"summary",level:2},{value:"Complete Tutorial and Example Project",id:"complete-tutorial-and-example-project",level:2},{value:"Related Documentation",id:"related-documentation",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"dynamic-transitions-and-hidden-states",children:"Dynamic Transitions and Hidden States"})}),"\n",(0,a.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsxs)(n.p,{children:["A common challenge in GUI automation is dealing with dynamic overlays like menus, dialogs, and pop-ups that can appear at any time and cover other UI elements. Brobot handles this elegantly through its ",(0,a.jsx)(n.strong,{children:"Hidden States"})," mechanism and ",(0,a.jsx)(n.strong,{children:"Dynamic Transitions"})," using special marker classes."]}),"\n",(0,a.jsx)(n.h2,{id:"the-problem",children:"The Problem"}),"\n",(0,a.jsx)(n.p,{children:"Consider a typical application with:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"A main window with various screens (Home, Settings, Profile, etc.)"}),"\n",(0,a.jsx)(n.li,{children:"A menu that can be opened from any screen"}),"\n",(0,a.jsx)(n.li,{children:"Dialogs that can appear over any state"}),"\n",(0,a.jsx)(n.li,{children:"Pop-ups that temporarily cover content"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"When a menu opens over the Settings screen, the Settings state becomes temporarily inaccessible. When the menu is closed, you want to return to Settings. But what if the menu was opened from the Home screen instead? The same action that transitions from Menu to Settings would also transition from Menu to Home. If transitions were hard-coded, it would create ambiguity in the pathfinding algorithm."}),"\n",(0,a.jsx)(n.h2,{id:"the-solution-hidden-states",children:"The Solution: Hidden States"}),"\n",(0,a.jsx)(n.p,{children:"Brobot solves this with the Hidden States mechanism:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Automatic Registration"}),': When a state opens and covers another, the covered state is automatically registered as "hidden"']}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Dynamic Tracking"}),": The framework maintains a stack of hidden states for each active state"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Smart Navigation"}),": Special marker classes enable dynamic transitions back to hidden states"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"special-marker-classes",children:"Special Marker Classes"}),"\n",(0,a.jsx)(n.p,{children:"Brobot provides special marker classes for dynamic transitions:"}),"\n",(0,a.jsx)(n.h3,{id:"-currently-implemented",children:"\u2705 Currently Implemented"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"PreviousState"})}),": Returns to the most recently hidden state (fully functional)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"CurrentState"})}),": Targets the currently active state for self-transitions (fully functional)"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"\ufe0f-future-consideration",children:"\u26a0\ufe0f Future Consideration"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"ExpectedState"})}),": Would navigate to an expected state determined at runtime (not yet implemented)"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"understanding-each-special-state-type",children:"Understanding Each Special State Type"}),"\n",(0,a.jsx)(n.h3,{id:"previousstate---return-to-hidden-state",children:"PreviousState - Return to Hidden State"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"What it does"}),": Returns to whatever state was covered by an overlay."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Real-world examples"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Closing a modal dialog returns to the page that opened it"}),"\n",(0,a.jsx)(n.li,{children:"Exiting fullscreen video returns to the article or gallery"}),"\n",(0,a.jsx)(n.li,{children:"Dismissing a popup menu returns to the underlying screen"}),"\n",(0,a.jsx)(n.li,{children:"Closing a lightbox returns to the product page or article"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'@TransitionSet(state = ModalDialog.class)\npublic class ModalDialogTransitions {\n\n    @OutgoingTransition(\n        activate = {PreviousState.class},  // Returns to whatever opened this modal\n        pathCost = 0,\n        description = "Close modal and return to previous state"\n    )\n    public boolean closeModal() {\n        return action.click(closeButton).isSuccess();\n    }\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"When to use PreviousState"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Modal dialogs that can appear over any page"}),"\n",(0,a.jsx)(n.li,{children:"Popup menus and dropdowns"}),"\n",(0,a.jsx)(n.li,{children:"Lightboxes and image viewers"}),"\n",(0,a.jsx)(n.li,{children:"Fullscreen modes"}),"\n",(0,a.jsx)(n.li,{children:"Temporary overlays"}),"\n",(0,a.jsx)(n.li,{children:"Help tooltips"}),"\n",(0,a.jsx)(n.li,{children:"Quick-view product previews"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"currentstate---self-transitions",children:"CurrentState - Self-Transitions"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"What it does"}),": Performs an action while staying in the same state. The UI might change slightly, but you remain conceptually in the same place. Also useful when transitioning between overlapping states where both remain active."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Tutorial Example - Island Capture"}),":\nIn the tutorial-basics example, the Island state overlays the World state. To capture multiple islands, instead of directly calling transition methods (which bypasses the state management system), use CurrentState:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'@TransitionSet(state = IslandState.class)\npublic class IslandTransitions {\n\n    // Better approach - using CurrentState for re-entry\n    @OutgoingTransition(\n        activate = {CurrentState.class},  // Re-enter Island state\n        pathCost = 0,\n        description = "Capture new island (re-enter Island from World)"\n    )\n    public boolean captureNewIsland() {\n        // Since both World and Island are active (Island overlays World),\n        // this transition from World back to Island to capture another island\n        // This properly uses the state management system\n        return action.click(worldState.getNextIsland()).isSuccess();\n    }\n\n    // Traditional approach - avoid this pattern\n    public void getNewIsland() {\n        // This bypasses the state management system\n        fromWorld();  // Direct method call - not recommended\n    }\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Other Real-world examples"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Pagination (loading more results)"}),"\n",(0,a.jsx)(n.li,{children:"Sorting or filtering lists"}),"\n",(0,a.jsx)(n.li,{children:"Refreshing data"}),"\n",(0,a.jsx)(n.li,{children:"Expanding/collapsing sections"}),"\n",(0,a.jsx)(n.li,{children:"Form validation errors"}),"\n",(0,a.jsx)(n.li,{children:"Toggling view modes"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'@TransitionSet(state = SearchResultsPage.class)\npublic class SearchResultsTransitions {\n\n    @OutgoingTransition(\n        activate = {CurrentState.class},  // Stay on search results\n        pathCost = 2,\n        description = "Load more results"\n    )\n    public boolean loadMoreResults() {\n        // Clicking "Load More" adds results but stays on same page\n        return action.click(loadMoreButton).isSuccess();\n    }\n\n    @OutgoingTransition(\n        activate = {CurrentState.class},\n        pathCost = 3,\n        description = "Sort results by price"\n    )\n    public boolean sortByPrice() {\n        // Sorting rearranges items but doesn\'t leave the page\n        action.click(sortDropdown);\n        return action.click(priceOption).isSuccess();\n    }\n\n    @OutgoingTransition(\n        activate = {CurrentState.class},\n        pathCost = 5,\n        description = "Refresh search results"\n    )\n    public boolean refreshResults() {\n        // F5 refreshes but stays on same page\n        return action.type("{F5}").isSuccess();\n    }\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"When to use CurrentState"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Actions that modify the current page without navigation"}),"\n",(0,a.jsx)(n.li,{children:"Data refresh operations"}),"\n",(0,a.jsx)(n.li,{children:"In-page interactions (sorting, filtering, pagination)"}),"\n",(0,a.jsx)(n.li,{children:"UI state changes (expand/collapse, show/hide)"}),"\n",(0,a.jsx)(n.li,{children:"Form submissions that stay on the same page (validation errors)"}),"\n",(0,a.jsx)(n.li,{children:"Re-entering an active state from another active state (overlapping states)"}),"\n",(0,a.jsx)(n.li,{children:"Game scenarios where capturing items doesn't change the active state"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"expectedstate---runtime-determined-not-yet-implemented",children:"ExpectedState - Runtime-Determined (Not Yet Implemented)"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Concept"}),": Would allow transitions where the target state is determined at runtime based on conditions like user preferences, roles, or application state."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Current alternatives"}),': Most "expected state" scenarios can be handled today using:']}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Multiple transitions with different path costs"}),":"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"@OutgoingTransition(activate = {AdminDashboard.class}, pathCost = 0)\npublic boolean loginAsAdmin() {\n    if (!user.isAdmin()) return false;\n    return performLogin();\n}\n\n@OutgoingTransition(activate = {UserHome.class}, pathCost = 0)\npublic boolean loginAsUser() {\n    if (user.isAdmin()) return false;\n    return performLogin();\n}\n"})}),"\n",(0,a.jsxs)(n.ol,{start:"2",children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Conditional logic in transition methods"}),":"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"@OutgoingTransition(activate = {HomePage.class}, pathCost = 0)\npublic boolean navigateToHome() {\n    // The HomePage state can handle different user types internally\n    return action.click(homeButton).isSuccess();\n}\n"})}),"\n",(0,a.jsxs)(n.ol,{start:"3",children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"State detection after transition"}),":"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"// Let the framework detect which state we ended up in\n@OutgoingTransition(activate = {HomePage.class}, pathCost = 10)\npublic boolean attemptNavigation() {\n    action.click(navigationButton);\n    // Framework will verify actual state after transition\n    return true;\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"understanding-unknownstate-not-a-special-marker",children:"Understanding UnknownState (Not a Special Marker)"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Important"}),": ",(0,a.jsx)(n.code,{children:"UnknownState"})," is NOT a special marker class. It's an actual state that exists in every Brobot project."]}),"\n",(0,a.jsx)(n.h3,{id:"how-unknownstate-works",children:"How UnknownState Works"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"You don't navigate TO UnknownState"})," - you end up there when state detection fails"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"UnknownState has outgoing transitions"})," - these are your recovery mechanisms"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"It's your safety net"})," - ensures automation can always recover"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// CORRECT: UnknownState has outgoing transitions for recovery\n@TransitionSet(state = UnknownState.class)\npublic class UnknownStateTransitions {\n\n    @OutgoingTransition(\n        activate = {HomePage.class},\n        pathCost = 10,\n        description = "Recover to home"\n    )\n    public boolean recoverToHome() {\n        // Try to get back to a known state\n        action.type("{ESC}");  // Close any popups\n        return action.click(homeButton).isSuccess();\n    }\n\n    @OutgoingTransition(\n        activate = {LoginPage.class},\n        pathCost = 20,\n        description = "Recover to login if session expired"\n    )\n    public boolean recoverToLogin() {\n        // Navigate to login page\n        return action.goToUrl(loginUrl).isSuccess();\n    }\n}\n\n// INCORRECT: Never transition TO UnknownState\n// @OutgoingTransition(activate = {UnknownState.class}) // \u274c DON\'T DO THIS\n'})}),"\n",(0,a.jsx)(n.h2,{id:"complete-working-example-special-states",children:"Complete Working Example: Special States"}),"\n",(0,a.jsxs)(n.p,{children:["The following is a complete, tested example from the special-states-example project that demonstrates PreviousState and CurrentState in action. The full project is available at ",(0,a.jsx)(n.code,{children:"examples/03-core-library/guides/dynamic-transitions/special-states-example/"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"modal-dialog-state-with-previousstate",children:"Modal Dialog State with PreviousState"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'package com.example.specialstates.states;\n\nimport org.springframework.stereotype.Component;\n\nimport io.github.jspinak.brobot.annotations.State;\nimport io.github.jspinak.brobot.model.state.StateImage;\n\nimport lombok.Getter;\nimport lombok.extern.slf4j.Slf4j;\n\n/**\n * Modal dialog state that overlays the main page. This state hides whatever state was active before\n * it.\n */\n@State(description = "Modal dialog overlay")\n@Component\n@Getter\n@Slf4j\npublic class ModalDialogState {\n\n    private final StateImage dialogTitle;\n    private final StateImage confirmButton;\n    private final StateImage cancelButton;\n    private final StateImage closeButton;\n\n    public ModalDialogState() {\n        log.info("Initializing ModalDialogState");\n\n        dialogTitle =\n                new StateImage.Builder().addPatterns("dialogTitle").setName("dialogTitle").build();\n\n        confirmButton =\n                new StateImage.Builder().addPatterns("confirmBtn").setName("confirmButton").build();\n\n        cancelButton =\n                new StateImage.Builder().addPatterns("cancelBtn").setName("cancelButton").build();\n\n        closeButton =\n                new StateImage.Builder()\n                        .addPatterns("closeBtn", "xButton")\n                        .setName("closeButton")\n                        .build();\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"modal-dialog-transitions-using-previousstate",children:"Modal Dialog Transitions Using PreviousState"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'package com.example.specialstates.transitions;\n\nimport org.springframework.stereotype.Component;\n\nimport com.example.specialstates.states.ModalDialogState;\n\nimport io.github.jspinak.brobot.action.Action;\nimport io.github.jspinak.brobot.annotations.IncomingTransition;\nimport io.github.jspinak.brobot.annotations.OutgoingTransition;\nimport io.github.jspinak.brobot.annotations.TransitionSet;\nimport io.github.jspinak.brobot.model.state.special.PreviousState;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.extern.slf4j.Slf4j;\n\n/**\n * Transitions for the ModalDialog state. Uses PreviousState to return to whatever state was hidden\n * by the modal.\n */\n@TransitionSet(state = ModalDialogState.class)\n@Component\n@RequiredArgsConstructor\n@Slf4j\npublic class ModalDialogTransitions {\n\n    private final ModalDialogState modalDialogState;\n    private final Action action;\n\n    @IncomingTransition\n    public boolean verifyArrival() {\n        log.info("Verifying arrival at ModalDialog");\n        // In mock mode, always return true\n        return true;\n    }\n\n    @OutgoingTransition(\n            activate = {PreviousState.class}, // Return to whatever state was hidden\n            staysVisible = false, // Modal closes completely\n            pathCost = 0,\n            description = "Confirm and close modal, returning to previous state")\n    public boolean confirmAndClose() {\n        log.info("Confirming and closing modal - returning to PreviousState");\n        log.info("This should return to whatever state was hidden (MainPage or SettingsPage)");\n        // In mock mode, just return true\n        return true;\n    }\n\n    @OutgoingTransition(\n            activate = {PreviousState.class}, // Return to whatever state was hidden\n            staysVisible = false, // Modal closes completely\n            pathCost = 0,\n            description = "Cancel and close modal, returning to previous state")\n    public boolean cancelAndClose() {\n        log.info("Cancelling and closing modal - returning to PreviousState");\n        log.info("This should return to whatever state was hidden (MainPage or SettingsPage)");\n        // In mock mode, just return true\n        return true;\n    }\n\n    @OutgoingTransition(\n            activate = {PreviousState.class}, // Return to whatever state was hidden\n            staysVisible = false, // Modal closes completely\n            pathCost = 0,\n            description = "Close modal with X button, returning to previous state")\n    public boolean closeModal() {\n        log.info("Closing modal with X button - returning to PreviousState");\n        log.info("This should return to whatever state was hidden (MainPage or SettingsPage)");\n        // In mock mode, just return true\n        return true;\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"main-page-with-currentstate-self-transitions",children:"Main Page with CurrentState Self-Transitions"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'package com.example.specialstates.transitions;\n\nimport org.springframework.stereotype.Component;\n\nimport com.example.specialstates.states.MainPageState;\nimport com.example.specialstates.states.ModalDialogState;\nimport com.example.specialstates.states.SettingsPageState;\n\nimport io.github.jspinak.brobot.action.Action;\nimport io.github.jspinak.brobot.annotations.IncomingTransition;\nimport io.github.jspinak.brobot.annotations.OutgoingTransition;\nimport io.github.jspinak.brobot.annotations.TransitionSet;\nimport io.github.jspinak.brobot.model.state.special.CurrentState;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.extern.slf4j.Slf4j;\n\n/** Transitions for the MainPage state. Includes self-transitions using CurrentState. */\n@TransitionSet(state = MainPageState.class)\n@Component\n@RequiredArgsConstructor\n@Slf4j\npublic class MainPageTransitions {\n\n    private final MainPageState mainPageState;\n    private final Action action;\n\n    @IncomingTransition\n    public boolean verifyArrival() {\n        log.info("Verifying arrival at MainPage");\n        // In mock mode, always return true\n        return true;\n    }\n\n    @OutgoingTransition(\n            activate = {ModalDialogState.class},\n            staysVisible = true, // MainPage stays visible behind modal\n            pathCost = 0,\n            description = "Open modal dialog over main page")\n    public boolean openModal() {\n        log.info("Opening modal dialog from MainPage");\n        // In mock mode, just return true\n        return true;\n    }\n\n    @OutgoingTransition(\n            activate = {SettingsPageState.class},\n            pathCost = 1,\n            description = "Navigate to settings page")\n    public boolean toSettings() {\n        log.info("Navigating from MainPage to Settings");\n        return true;\n    }\n\n    @OutgoingTransition(\n            activate = {CurrentState.class}, // Self-transition\n            pathCost = 2,\n            description = "Refresh main page")\n    public boolean refresh() {\n        log.info("Refreshing MainPage (self-transition using CurrentState)");\n        // This demonstrates a self-transition\n        return true;\n    }\n\n    @OutgoingTransition(\n            activate = {CurrentState.class}, // Self-transition\n            pathCost = 3,\n            description = "Load next page of results")\n    public boolean nextPage() {\n        log.info("Loading next page of results (self-transition using CurrentState)");\n        // Another self-transition example\n        return true;\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"generic-data-grid-example-with-self-transitions",children:"Generic Data Grid Example with Self-Transitions"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'@TransitionSet(state = DataGridState.class)\n@Component\npublic class DataGridTransitions {\n    private final DataGridState grid;\n    private final Action action;\n\n    @OutgoingTransition(\n        activate = {CurrentState.class},  // Stay in same state\n        pathCost = 5,\n        description = "Load next page of data"\n    )\n    public boolean nextPage() {\n        return action.click(grid.getNextPageButton()).isSuccess();\n    }\n\n    @OutgoingTransition(\n        activate = {CurrentState.class},\n        pathCost = 5,\n        description = "Load previous page of data"\n    )\n    public boolean previousPage() {\n        return action.click(grid.getPrevPageButton()).isSuccess();\n    }\n\n    @OutgoingTransition(\n        activate = {CurrentState.class},\n        pathCost = 3,\n        description = "Sort by column"\n    )\n    public boolean sortByColumn() {\n        return action.click(grid.getColumnHeader()).isSuccess();\n    }\n\n    @OutgoingTransition(\n        activate = {CurrentState.class},\n        pathCost = 2,\n        description = "Apply filter"\n    )\n    public boolean applyFilter() {\n        action.type(grid.getFilterInput(), filterText);\n        return action.click(grid.getApplyButton()).isSuccess();\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"multi-level-overlays",children:"Multi-Level Overlays"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"// Settings can be covered by Menu\n@State\npublic class SettingsPage {\n    // Settings page elements\n}\n\n// Menu can cover any page\n@State\npublic class MenuOverlay {\n    // Menu elements\n}\n\n// Help can cover the Menu\n@State\npublic class HelpDialog {\n    // Help dialog elements\n}\n\n// Transitions maintain the hidden state stack\n@TransitionSet(state = HelpDialog.class)\npublic class HelpDialogTransitions {\n    @OutgoingTransition(activate = {PreviousState.class}, pathCost = 0)\n    public boolean closeHelp() {\n        // Returns to Menu (which is covering Settings)\n        return action.click(closeButton).isSuccess();\n    }\n}\n\n@TransitionSet(state = MenuOverlay.class)\npublic class MenuTransitions {\n    @OutgoingTransition(activate = {PreviousState.class}, pathCost = 0)\n    public boolean closeMenu() {\n        // Returns to Settings (or whatever was covered)\n        return action.click(closeButton).isSuccess();\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"decision-guide",children:"Decision Guide"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Which transition type should I use?\n\n1. Does the action change the page/screen?\n   NO \u2192 Use CurrentState (self-transition)\n   YES \u2192 Continue to #2\n\n2. Is this closing an overlay that covers other content?\n   YES \u2192 Use PreviousState (return to hidden)\n   NO \u2192 Continue to #3\n\n3. Do I know at compile-time where this will go?\n   YES \u2192 Use a regular state class (HomeState.class, etc.)\n   NO \u2192 Consider the alternatives mentioned for ExpectedState\n"})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(n.h3,{id:"1-use-previousstate-for-true-overlays",children:"1. Use PreviousState for True Overlays"}),"\n",(0,a.jsx)(n.p,{children:"Dynamic transitions work best for UI elements that truly overlay others:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Modal dialogs"}),"\n",(0,a.jsx)(n.li,{children:"Dropdown menus"}),"\n",(0,a.jsx)(n.li,{children:"Pop-up notifications"}),"\n",(0,a.jsx)(n.li,{children:"Sidebars that slide over content"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"2-use-currentstate-for-in-page-actions",children:"2. Use CurrentState for In-Page Actions"}),"\n",(0,a.jsx)(n.p,{children:"Self-transitions are perfect for actions that don't leave the current context:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Pagination"}),"\n",(0,a.jsx)(n.li,{children:"Sorting and filtering"}),"\n",(0,a.jsx)(n.li,{children:"Data refresh"}),"\n",(0,a.jsx)(n.li,{children:"UI toggles"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"3-provide-fallbacks",children:"3. Provide Fallbacks"}),"\n",(0,a.jsx)(n.p,{children:"Always have a fallback plan if dynamic transitions might fail:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"@TransitionSet(state = MenuState.class)\npublic class MenuTransitions {\n\n    @OutgoingTransition(activate = {PreviousState.class}, pathCost = 0)\n    public boolean closeToPrevious() {\n        // Primary: try to return to previous\n        return action.click(closeButton).isSuccess();\n    }\n\n    @OutgoingTransition(activate = {HomePage.class}, pathCost = 10)\n    public boolean closeToHome() {\n        // Fallback: go to home if previous fails\n        return action.click(homeButton).isSuccess();\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"4-clear-visual-indicators",children:"4. Clear Visual Indicators"}),"\n",(0,a.jsx)(n.p,{children:"Ensure overlays have clear visual indicators for state detection:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"@State\npublic class DialogState {\n    @StateImage\n    private StateImage dialogHeader;  // Unique to this dialog\n\n    @StateImage\n    private StateImage darkOverlay;   // Common overlay indicator\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"5-handle-edge-cases",children:"5. Handle Edge Cases"}),"\n",(0,a.jsx)(n.p,{children:"Consider edge cases in your transitions:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"What if the previous state no longer exists?"}),"\n",(0,a.jsx)(n.li,{children:"What if multiple overlays are stacked?"}),"\n",(0,a.jsx)(n.li,{children:"What if the application crashed and restarted?"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"framework-components",children:"Framework Components"}),"\n",(0,a.jsx)(n.h3,{id:"special-marker-classes-1",children:"Special Marker Classes"}),"\n",(0,a.jsxs)(n.p,{children:["Located in ",(0,a.jsx)(n.code,{children:"io.github.jspinak.brobot.model.state.special"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"// PreviousState.java\npublic final class PreviousState {\n    public static final Long ID = SpecialStateType.PREVIOUS.getId(); // -2L\n    private PreviousState() {} // Cannot be instantiated\n}\n\n// CurrentState.java\npublic final class CurrentState {\n    public static final Long ID = SpecialStateType.CURRENT.getId(); // -3L\n    private CurrentState() {} // Cannot be instantiated\n}\n\n// ExpectedState.java (marker exists but not yet functional)\npublic final class ExpectedState {\n    public static final Long ID = SpecialStateType.EXPECTED.getId(); // -4L\n    private ExpectedState() {} // Cannot be instantiated\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"transitionsetprocessor",children:"TransitionSetProcessor"}),"\n",(0,a.jsx)(n.p,{children:"The processor recognizes special marker classes and handles them appropriately:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"@Component\npublic class TransitionSetProcessor {\n    // Detects when to = PreviousState.class or CurrentState.class\n    // Sets special state IDs instead of regular state names\n    // Enables dynamic resolution at runtime\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"sethiddenstates",children:"SetHiddenStates"}),"\n",(0,a.jsx)(n.p,{children:"Manages the registration and tracking of hidden states:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"@Component\npublic class SetHiddenStates {\n    // Automatically invoked when states change\n    public void setHiddenStates(State coveringState, Set<State> coveredStates) {\n        // Registers which states are hidden by the covering state\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"statememory",children:"StateMemory"}),"\n",(0,a.jsx)(n.p,{children:"Maintains the history of state transitions and hidden states:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'@Component\npublic class StateMemory {\n    // Tracks the sequence of state activations\n    // Used to determine the "previous" state for dynamic transitions\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,a.jsx)(n.h3,{id:"hidden-state-not-found",children:"Hidden State Not Found"}),"\n",(0,a.jsx)(n.p,{children:"If a dynamic transition fails to find the previous state:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Check that states are properly detecting overlays"}),"\n",(0,a.jsx)(n.li,{children:"Verify StateImage definitions don't overlap incorrectly"}),"\n",(0,a.jsx)(n.li,{children:"Ensure the covering state is properly registered"}),"\n",(0,a.jsx)(n.li,{children:"Check logs for state transition history"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"self-transitions-not-working",children:"Self-Transitions Not Working"}),"\n",(0,a.jsx)(n.p,{children:"If CurrentState transitions aren't working:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Verify the action actually completes"}),"\n",(0,a.jsx)(n.li,{children:"Check that the state detection still passes after the action"}),"\n",(0,a.jsx)(n.li,{children:"Ensure the UI change doesn't trigger a different state detection"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"multiple-states-claiming-to-be-active",children:"Multiple States Claiming to be Active"}),"\n",(0,a.jsx)(n.p,{children:"This can happen with poor state definition:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Make StateImages more specific"}),"\n",(0,a.jsx)(n.li,{children:"Use unique identifiers for each state"}),"\n",(0,a.jsx)(n.li,{children:"Adjust pattern matching thresholds"}),"\n",(0,a.jsx)(n.li,{children:"Consider using state priorities"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"migration-from-old-annotations",children:"Migration from Old Annotations"}),"\n",(0,a.jsxs)(n.p,{children:["If you have old code using the deprecated ",(0,a.jsx)(n.code,{children:"@Transition"})," annotation:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"// OLD (no longer supported)\n@Transition(from = MenuState.class, to = PreviousState.class)\n\n// NEW\n@TransitionSet(state = MenuState.class)\npublic class MenuTransitions {\n    @OutgoingTransition(to = PreviousState.class, pathCost = 0)\n    public boolean closeToPrevious() {\n        // Implementation\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsx)(n.p,{children:"Brobot's special state transitions provide powerful patterns for handling dynamic UI behavior:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"PreviousState"}),": Perfect for overlays that need to return to whatever they covered"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"CurrentState"}),": Ideal for actions that modify the current page without navigation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"ExpectedState"}),": Future consideration for runtime-determined navigation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"UnknownState"}),": Not a target, but a safety net with recovery transitions"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"These special states make your automation more resilient and adaptable to the dynamic nature of modern applications."}),"\n",(0,a.jsx)(n.h2,{id:"complete-tutorial-and-example-project",children:"Complete Tutorial and Example Project"}),"\n",(0,a.jsx)(n.p,{children:"A complete, runnable example demonstrating all special state concepts is available:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"/docs/core-library/tutorials/tutorial-special-states",children:"Special States Tutorial"})})," - Step-by-step tutorial with full source code"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Example Project"}),": ",(0,a.jsx)(n.code,{children:"examples/03-core-library/guides/dynamic-transitions/special-states-example/"})]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/getting-started/transitions",children:"Transitions Overview"})," - General transition concepts"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/getting-started/core-concepts#handling-dynamic-overlays-hidden-states",children:"Core Concepts"})," - Brief hidden states overview"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/getting-started/states",children:"States Overview"})," - Understanding states in Brobot"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/core-library/guides/state-aware-scheduling",children:"State-Aware Scheduling"})," - Advanced state scheduling patterns"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);
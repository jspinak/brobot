"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[694],{17351:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"theoretical-foundations/introduction","title":"Introduction","description":"This documentation describes the theoretical foundations and core concepts behind the Brobot framework, which are based on the principles of model-based GUI automation. This approach was designed to solve the long-standing challenges of fragility and complexity that plague traditional GUI automation methods.","source":"@site/versioned_docs/version-1.0.7/05-theoretical-foundations/introduction.md","sourceDirName":"05-theoretical-foundations","slug":"/theoretical-foundations/introduction","permalink":"/brobot/docs/1.0.7/theoretical-foundations/introduction","draft":false,"unlisted":false,"editUrl":"https://github.com/jspinak/brobot/edit/main/docs/versioned_docs/version-1.0.7/05-theoretical-foundations/introduction.md","tags":[],"version":"1.0.7","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Introduction"},"sidebar":"docSidebar","previous":{"title":"Theoretical Foundations","permalink":"/brobot/docs/1.0.7/category/theoretical-foundations"},"next":{"title":"Core Concepts of the Model-Based Approach","permalink":"/brobot/docs/1.0.7/theoretical-foundations/core-concepts"}}');var o=i(74848),a=i(28453);const s={sidebar_position:1,title:"Introduction"},r="Introduction",l={},d=[{value:"The Challenge with Traditional GUI Automation",id:"the-challenge-with-traditional-gui-automation",level:2},{value:"Script Fragility",id:"script-fragility",level:3},{value:"The Complexity-Robustness Tradeoff",id:"the-complexity-robustness-tradeoff",level:3},{value:"The Model-Based Solution",id:"the-model-based-solution",level:2},{value:"Academic Foundation",id:"academic-foundation",level:3},{value:"Core Principles",id:"core-principles",level:3},{value:"Citation",id:"citation",level:3},{value:"Further Reading",id:"further-reading",level:3}];function c(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"introduction",children:"Introduction"})}),"\n",(0,o.jsx)(t.p,{children:"This documentation describes the theoretical foundations and core concepts behind the Brobot framework, which are based on the principles of model-based GUI automation. This approach was designed to solve the long-standing challenges of fragility and complexity that plague traditional GUI automation methods."}),"\n",(0,o.jsx)(t.h2,{id:"the-challenge-with-traditional-gui-automation",children:"The Challenge with Traditional GUI Automation"}),"\n",(0,o.jsx)(t.p,{children:"Traditional visual GUI automation suffers from fundamental limitations that have impeded its adoption for complex, real-world applications."}),"\n",(0,o.jsx)(t.h3,{id:"script-fragility",children:"Script Fragility"}),"\n",(0,o.jsxs)(t.p,{children:['The "Achilles heel" of visual GUI test automation is ',(0,o.jsx)(t.strong,{children:"script fragility"}),", which is the tendency for automation to fail due to even minor changes in the GUI environment. This fragility is a persistent problem, with research showing very little progress over twenty years. Failures are often caused by factors such as image recognition errors, unexpected application delays, dynamic content, and GUI changes between versions. The impact is significant, with studies showing that a large percentage of test failures are due to script fragility rather than actual software defects."]}),"\n",(0,o.jsx)(t.h3,{id:"the-complexity-robustness-tradeoff",children:"The Complexity-Robustness Tradeoff"}),"\n",(0,o.jsx)(t.p,{children:"The fundamental challenge in addressing script fragility is the inverse relationship between robustness and code complexity. To make a traditional script more robust, a developer must add an exponential amount of code to handle alternative paths and potential failures. This creates a practical ceiling on the complexity of tasks that can be reliably automated, as the maintenance cost becomes prohibitive."}),"\n",(0,o.jsx)(t.h2,{id:"the-model-based-solution",children:"The Model-Based Solution"}),"\n",(0,o.jsx)(t.p,{children:'Model-based GUI automation addresses these challenges by fundamentally changing the approach. Instead of writing sequential scripts, the developer builds an explicit model of the GUI environment, creating a "digital twin" that the framework can use to navigate and interact with the application intelligently.'}),"\n",(0,o.jsx)(t.h3,{id:"academic-foundation",children:"Academic Foundation"}),"\n",(0,o.jsx)(t.p,{children:"The Brobot framework is based on the research paper:"}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:'"Model-based GUI Automation"'}),"\n",(0,o.jsx)(t.em,{children:"Joshua Spinak, 2025"})]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"This research establishes the theoretical framework for:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"A formal model of the GUI environment based on states, elements, and transitions."}),"\n",(0,o.jsx)(t.li,{children:"A system architecture separating domain-specific knowledge from strategic, problem-agnostic knowledge."}),"\n",(0,o.jsx)(t.li,{children:"A robust path-traversal system to handle GUI stochasticity through dynamic pathfinding."}),"\n",(0,o.jsx)(t.li,{children:"Verification and validation of the automation code itself through mocking and simulation."}),"\n"]}),"\n",(0,o.jsx)(t.h3,{id:"core-principles",children:"Core Principles"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Explicit Modeling"}),": The developer creates a ",(0,o.jsx)(t.code,{children:"state structure"})," (\u03a9) that explicitly maps the GUI's states and transitions. This moves implicit knowledge into a formal model, making the system easier to maintain and scale."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Robust Navigation"}),": The framework uses a ",(0,o.jsx)(t.code,{children:"Path Traversal Model"})," (\xa7) to find and execute the best path to a target state. If an action fails, it dynamically recalculates a new path, making the system resilient to unexpected events."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Systematic Testing"}),": The model-based approach enables, for the first time, integration and unit testing of GUI automation code. By simulating the GUI from an ",(0,o.jsx)(t.code,{children:"Action History"}),", the automation can be tested without a live environment, ensuring reliability and quality."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(t.h3,{id:"citation",children:"Citation"}),"\n",(0,o.jsx)(t.p,{children:"If you use Brobot or its underlying concepts in academic work, please cite the foundational paper:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-bibtex",children:"@article{spinak2025model,\n\xa0 title={Model-based GUI Automation},\n\xa0 author={Spinak, Joshua},\n\xa0 journal={Software and Systems Modeling},\n\xa0 year={2025},\n\xa0 publisher={Springer}\n}\n"})}),"\n",(0,o.jsx)(t.h3,{id:"further-reading",children:"Further Reading"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"./overall-model",children:"The Overall Model"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"./states",children:"States"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"./transitions",children:"Transitions"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"./testing-automation",children:"Testing the Automation"})}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},28453:(e,t,i)=>{i.d(t,{R:()=>s,x:()=>r});var n=i(96540);const o={},a=n.createContext(o);function s(e){const t=n.useContext(a);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);
"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7669],{26255:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"core-library/guides/state-aware-scheduling","title":"State-Aware Scheduling","description":"Overview","source":"@site/docs/03-core-library/guides/state-aware-scheduling.md","sourceDirName":"03-core-library/guides","slug":"/core-library/guides/state-aware-scheduling","permalink":"/brobot/docs/core-library/guides/state-aware-scheduling","draft":false,"unlisted":false,"editUrl":"https://github.com/jspinak/brobot/edit/main/docs/docs/03-core-library/guides/state-aware-scheduling.md","tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"sidebar_position":10,"title":"State-Aware Scheduling"},"sidebar":"docSidebar","previous":{"title":"Region Building with Position Integration","permalink":"/brobot/docs/core-library/guides/screen-adaptive-regions"},"next":{"title":"Advanced Illustration System","permalink":"/brobot/docs/core-library/guides/advanced-illustration-system"}}');var a=i(74848),r=i(28453);const s={sidebar_position:10,title:"State-Aware Scheduling"},l="State-Aware Scheduling",o={},c=[{value:"Overview",id:"overview",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"The Challenge",id:"the-challenge",level:3},{value:"The Solution",id:"the-solution",level:3},{value:"Implementation",id:"implementation",level:2},{value:"How StateAwareScheduler Works",id:"how-stateawarescheduler-works",level:3},{value:"Using StateAwareScheduler",id:"using-stateawarescheduler",level:3},{value:"Configuration Options",id:"configuration-options",level:3},{value:"Configuration Parameters",id:"configuration-parameters",level:4},{value:"Check Modes",id:"check-modes",level:4},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Basic Monitoring Task",id:"basic-monitoring-task",level:3},{value:"Complex Workflow Automation",id:"complex-workflow-automation",level:3},{value:"Error Recovery Automation",id:"error-recovery-automation",level:3},{value:"Integration with MonitoringService",id:"integration-with-monitoringservice",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Choose Appropriate Required States",id:"1-choose-appropriate-required-states",level:3},{value:"2. Configure Rebuild Behavior Carefully",id:"2-configure-rebuild-behavior-carefully",level:3},{value:"3. Handle State Check Failures",id:"3-handle-state-check-failures",level:3},{value:"4. Use Property Configuration",id:"4-use-property-configuration",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Issues",id:"common-issues",level:3},{value:"Debug Logging",id:"debug-logging",level:3},{value:"Future Enhancements",id:"future-enhancements",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"state-aware-scheduling",children:"State-Aware Scheduling"})}),"\n",(0,a.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(n.p,{children:"State-aware scheduling extends Brobot's scheduling capabilities to automatically validate and manage active states before executing scheduled tasks. This ensures that automation runs with the correct GUI context and can recover from unexpected state changes."}),"\n",(0,a.jsx)(n.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,a.jsx)(n.h3,{id:"the-challenge",children:"The Challenge"}),"\n",(0,a.jsx)(n.p,{children:"Traditional scheduled tasks in GUI automation face several challenges:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"GUI state may change unexpectedly between task executions"}),"\n",(0,a.jsx)(n.li,{children:"Applications may crash or navigate to unexpected screens"}),"\n",(0,a.jsx)(n.li,{children:"Background processes may alter the interface"}),"\n",(0,a.jsx)(n.li,{children:"User interactions may interfere with automation"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"the-solution",children:"The Solution"}),"\n",(0,a.jsx)(n.p,{children:"State-aware scheduling addresses these challenges by:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Validating required states before each task execution"}),"\n",(0,a.jsx)(n.li,{children:"Automatically rebuilding states when necessary"}),"\n",(0,a.jsx)(n.li,{children:"Providing configurable behavior for different scenarios"}),"\n",(0,a.jsx)(n.li,{children:"Maintaining separation between scheduling and state management concerns"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,a.jsx)(n.h3,{id:"how-stateawarescheduler-works",children:"How StateAwareScheduler Works"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"StateAwareScheduler"})," automatically performs state validation before each task execution. When you schedule a task with state checking, the scheduler internally:"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Validates that all required states are active based on your configuration"}),"\n",(0,a.jsxs)(n.li,{children:["Optionally rebuilds states if they're missing (when ",(0,a.jsx)(n.code,{children:"rebuildOnMismatch"})," is true)"]}),"\n",(0,a.jsx)(n.li,{children:"Executes your task only after successful state validation"}),"\n",(0,a.jsxs)(n.li,{children:["Handles errors based on your ",(0,a.jsx)(n.code,{children:"skipIfStatesMissing"})," setting"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"using-stateawarescheduler",children:"Using StateAwareScheduler"}),"\n",(0,a.jsxs)(n.p,{children:["Here's how to use the ",(0,a.jsx)(n.code,{children:"StateAwareScheduler"})," in your own service:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'@Component\n@RequiredArgsConstructor\npublic class MyAutomationService {\n    private final StateAwareScheduler stateAwareScheduler;\n    private final ScheduledExecutorService scheduler =\n        Executors.newScheduledThreadPool(1);\n\n    public void startAutomation() {\n        // Configure what states must be active\n        StateAwareScheduler.StateCheckConfiguration config =\n            new StateAwareScheduler.StateCheckConfiguration.Builder()\n                .withRequiredStates(List.of("Dashboard", "LoggedIn"))\n                .withRebuildOnMismatch(true)\n                .build();\n\n        // Schedule your task with automatic state checking\n        ScheduledFuture<?> future = stateAwareScheduler.scheduleWithStateCheck(\n            scheduler,\n            this::myAutomationTask,  // Your task\n            config,                   // State requirements\n            0,                       // Initial delay\n            10,                      // Period\n            TimeUnit.SECONDS\n        );\n    }\n\n    private void myAutomationTask() {\n        // This runs AFTER states are validated\n        // Dashboard and LoggedIn states are guaranteed to be checked\n        log.info("Running automation with verified states");\n    }\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The state validation happens automatically before your task runs. Depending on your ",(0,a.jsx)(n.code,{children:"checkMode"})," configuration:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"CHECK_ALL"}),": Validates all required states every time"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"CHECK_INACTIVE_ONLY"}),": Only validates states that are currently inactive (more efficient)"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"configuration-options",children:"Configuration Options"}),"\n",(0,a.jsx)(n.p,{children:"Configure state checking behavior with the builder pattern:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'StateAwareScheduler.StateCheckConfiguration config = new StateAwareScheduler.StateCheckConfiguration.Builder()\n    .withRequiredStates(List.of("MainMenu", "Dashboard"))\n    .withRebuildOnMismatch(true)\n    .withSkipIfStatesMissing(false)\n    .withCheckMode(StateAwareScheduler.StateCheckConfiguration.CheckMode.CHECK_INACTIVE_ONLY)\n    .withMaxIterations(100)  // Optional: limit iterations\n    .build();\n'})}),"\n",(0,a.jsx)(n.h4,{id:"configuration-parameters",children:"Configuration Parameters"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Parameter"}),(0,a.jsx)(n.th,{children:"Type"}),(0,a.jsx)(n.th,{children:"Default"}),(0,a.jsx)(n.th,{children:"Description"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"requiredStates"})}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"List<String>"})}),(0,a.jsx)(n.td,{children:"Empty"}),(0,a.jsx)(n.td,{children:"States that must be active before task execution"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"rebuildOnMismatch"})}),(0,a.jsx)(n.td,{children:"boolean"}),(0,a.jsx)(n.td,{children:"true"}),(0,a.jsx)(n.td,{children:"Whether to rebuild states if requirements not met"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"skipIfStatesMissing"})}),(0,a.jsx)(n.td,{children:"boolean"}),(0,a.jsx)(n.td,{children:"false"}),(0,a.jsx)(n.td,{children:"Skip task execution if states cannot be validated"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"checkMode"})}),(0,a.jsx)(n.td,{children:"CheckMode"}),(0,a.jsx)(n.td,{children:"CHECK_INACTIVE_ONLY"}),(0,a.jsx)(n.td,{children:"CHECK_ALL checks all states, CHECK_INACTIVE_ONLY only checks inactive ones"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"maxIterations"})}),(0,a.jsx)(n.td,{children:"int"}),(0,a.jsx)(n.td,{children:"-1 (unlimited)"}),(0,a.jsx)(n.td,{children:"Maximum number of task executions before stopping"})]})]})]}),"\n",(0,a.jsx)(n.h4,{id:"check-modes",children:"Check Modes"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"CHECK_ALL"}),": Validates all required states every time, regardless of current active status"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"CHECK_INACTIVE_ONLY"}),": Only validates states that are currently inactive (more efficient)"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,a.jsx)(n.h3,{id:"basic-monitoring-task",children:"Basic Monitoring Task"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'@Service\npublic class ApplicationMonitor {\n    private final StateAwareScheduler stateAwareScheduler;\n    private final ScheduledExecutorService scheduler = \n        Executors.newScheduledThreadPool(1);\n    \n    @PostConstruct\n    public void startMonitoring() {\n        StateAwareScheduler.StateCheckConfiguration config = new StateAwareScheduler.StateCheckConfiguration.Builder()\n                .withRequiredStates(List.of("Application"))\n                .withRebuildOnMismatch(true)\n                .build();\n        \n        stateAwareScheduler.scheduleWithStateCheck(\n                scheduler,\n                this::checkApplicationHealth,\n                config,\n                5, // initial delay\n                10, // period\n                TimeUnit.SECONDS\n        );\n    }\n    \n    private void checkApplicationHealth() {\n        // This runs only after automatic state validation\n        // The scheduler has already verified "Application" state is active\n        // No need to manually check states here\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"complex-workflow-automation",children:"Complex Workflow Automation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'@Component\npublic class DataSyncAutomation {\n    \n    public void setupPeriodicSync() {\n        // Different configurations for different stages\n        StateAwareScheduler.StateCheckConfiguration loginConfig = new StateAwareScheduler.StateCheckConfiguration.Builder()\n                .withRequiredStates(List.of("LoginScreen"))\n                .withRebuildOnMismatch(true)\n                .withSkipIfStatesMissing(true) // Skip if can\'t find login\n                .build();\n\n        StateAwareScheduler.StateCheckConfiguration dataConfig = new StateAwareScheduler.StateCheckConfiguration.Builder()\n                .withRequiredStates(List.of("DataDashboard", "SyncPanel"))\n                .withRebuildOnMismatch(false) // Don\'t rebuild, just skip\n                .withSkipIfStatesMissing(true)\n                .build();\n        \n        // Chain multiple state-aware tasks\n        CompletableFuture.runAsync(() -> {\n            performStateAwareTask(loginConfig, this::performLogin);\n        }).thenRun(() -> {\n            performStateAwareTask(dataConfig, this::syncData);\n        });\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"error-recovery-automation",children:"Error Recovery Automation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'@Service\npublic class ErrorRecoveryService {\n    \n    public void setupErrorMonitoring() {\n        StateAwareScheduler.StateCheckConfiguration config = new StateAwareScheduler.StateCheckConfiguration.Builder()\n                .withRequiredStates(List.of("NormalOperation"))\n                .withRebuildOnMismatch(true)\n                .build();\n        \n        // Check every 30 seconds for error states\n        stateAwareScheduler.scheduleWithStateCheck(\n                scheduler,\n                this::checkAndRecoverFromErrors,\n                config,\n                0, 30, TimeUnit.SECONDS\n        );\n    }\n    \n    private void checkAndRecoverFromErrors() {\n        // If we\'re here, normal operation state was validated\n        // Now check for any error dialogs\n        if (stateDetector.findState("ErrorDialog").isPresent()) {\n            handleErrorDialog();\n            // State will be rebuilt on next cycle\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"integration-with-monitoringservice",children:"Integration with MonitoringService"}),"\n",(0,a.jsxs)(n.p,{children:["State-aware scheduling complements the existing ",(0,a.jsx)(n.code,{children:"MonitoringService"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'@Component\npublic class EnhancedMonitoring {\n    private final MonitoringService monitoringService;\n    private final StateAwareScheduler stateAwareScheduler;\n    \n    public void startStateAwareMonitoring() {\n        // Create state validation hook\n        Runnable stateCheck = stateAwareScheduler.createStateCheckHook(\n            new StateAwareScheduler.StateCheckConfiguration.Builder()\n                .withRequiredStates(List.of("Application"))\n                .build()\n        );\n        \n        // Combine with monitoring service\n        monitoringService.startContinuousTask(\n            () -> {\n                stateCheck.run(); // Validate states first\n                performMonitoringTask();\n            },\n            () -> isApplicationRunning(),\n            5 // delay seconds\n        );\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(n.h3,{id:"1-choose-appropriate-required-states",children:"1. Choose Appropriate Required States"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// Too specific - might fail unnecessarily\n.withRequiredStates(List.of("MainMenu", "SubMenu", "SpecificDialog"))\n\n// Better - focus on essential states\n.withRequiredStates(List.of("Application", "MainWorkflow"))\n'})}),"\n",(0,a.jsx)(n.h3,{id:"2-configure-rebuild-behavior-carefully",children:"2. Configure Rebuild Behavior Carefully"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"// For critical workflows - always rebuild\n.withRebuildOnMismatch(true)\n.withSkipIfStatesMissing(false)\n\n// For optional tasks - skip if states missing\n.withRebuildOnMismatch(false)\n.withSkipIfStatesMissing(true)\n"})}),"\n",(0,a.jsx)(n.h3,{id:"3-handle-state-check-failures",children:"3. Handle State Check Failures"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"public void scheduleWithFallback() {\n    try {\n        stateAwareScheduler.scheduleWithStateCheck(\n            scheduler, mainTask, mainConfig, 0, 10, TimeUnit.SECONDS\n        );\n    } catch (IllegalStateException e) {\n        // Fallback to simpler state requirements\n        stateAwareScheduler.scheduleWithStateCheck(\n            scheduler, fallbackTask, fallbackConfig, 0, 10, TimeUnit.SECONDS\n        );\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"4-use-property-configuration",children:"4. Use Property Configuration"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-properties",children:"# application.properties\napp.monitoring.required-states=Dashboard,Navigation\napp.monitoring.rebuild-on-mismatch=true\napp.monitoring.check-interval=5\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'@Value("${app.monitoring.required-states}")\nprivate List<String> requiredStates;\n\n@Value("${app.monitoring.rebuild-on-mismatch}")\nprivate boolean rebuildOnMismatch;\n'})}),"\n",(0,a.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"State Detection Overhead"}),": State checking adds overhead to each task execution"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Rebuild Cost"}),": Full state rebuilding can be expensive - use judiciously"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Frequency Balance"}),": Balance checking frequency with performance impact"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// High-frequency task with minimal state checking\nStateAwareScheduler.StateCheckConfiguration lightConfig = new StateAwareScheduler.StateCheckConfiguration.Builder()\n    .withRequiredStates(List.of("MainApp")) // Single state check\n    .withRebuildOnMismatch(false)          // No rebuild\n    .build();\n\n// Low-frequency task with thorough checking\nStateAwareScheduler.StateCheckConfiguration thoroughConfig = new StateAwareScheduler.StateCheckConfiguration.Builder()\n    .withRequiredStates(List.of("App", "Module", "Feature"))\n    .withRebuildOnMismatch(true)\n    .build();\n'})}),"\n",(0,a.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,a.jsx)(n.h3,{id:"common-issues",children:"Common Issues"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"States Not Found"}),": Ensure state names match exactly"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Excessive Rebuilding"}),": Consider reducing rebuild frequency"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Task Skipping"}),": Check logs for state validation failures"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"debug-logging",children:"Debug Logging"}),"\n",(0,a.jsx)(n.p,{children:"Enable debug logging to troubleshoot state checking:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-properties",children:"logging.level.com.yourapp.scheduling=DEBUG\nlogging.level.io.github.jspinak.brobot.statemanagement=DEBUG\n"})}),"\n",(0,a.jsx)(n.h2,{id:"future-enhancements",children:"Future Enhancements"}),"\n",(0,a.jsx)(n.p,{children:"Potential improvements to state-aware scheduling:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Machine Learning Integration"}),": Predict state changes and pre-validate"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"State Change Events"}),": React to state changes rather than polling"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Hierarchical State Checking"}),": Check parent states before children"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Performance Optimization"}),": Cache state detection results"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Advanced Recovery"}),": Custom recovery strategies per state"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsx)(n.p,{children:"State-aware scheduling provides a robust foundation for reliable GUI automation by:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Ensuring correct state context before task execution"}),"\n",(0,a.jsx)(n.li,{children:"Automatically recovering from state mismatches"}),"\n",(0,a.jsx)(n.li,{children:"Maintaining clean separation of concerns"}),"\n",(0,a.jsx)(n.li,{children:"Providing flexible configuration options"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"This pattern is especially valuable for long-running automation, background monitoring, and complex workflows where GUI state integrity is critical."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>l});var t=i(96540);const a={},r=t.createContext(a);function s(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);
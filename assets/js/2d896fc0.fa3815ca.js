"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8365],{28453:(n,i,e)=>{e.d(i,{R:()=>o,x:()=>a});var t=e(96540);const s={},r=t.createContext(s);function o(n){const i=t.useContext(r);return t.useMemo(function(){return"function"==typeof n?n(i):{...i,...n}},[i,n])}function a(n){let i;return i=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:o(n.components),t.createElement(r.Provider,{value:i},n.children)}},43607:(n,i,e)=>{e.d(i,{A:()=>t});const t=e.p+"assets/images/transitions-c388f3c755a4df88c4c15f76e021e687.png"},91768:(n,i,e)=>{e.r(i),e.d(i,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"getting-started/transitions","title":"Transitions","description":"Introduction","source":"@site/docs/01-getting-started/transitions.md","sourceDirName":"01-getting-started","slug":"/getting-started/transitions","permalink":"/brobot/docs/getting-started/transitions","draft":false,"unlisted":false,"editUrl":"https://github.com/jspinak/brobot/edit/main/docs/docs/01-getting-started/transitions.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Transitions"},"sidebar":"docSidebar","previous":{"title":"States","permalink":"/brobot/docs/getting-started/states"},"next":{"title":"The Action Hierarchy","permalink":"/brobot/docs/getting-started/action-hierarchy"}}');var s=e(74848),r=e(28453);const o={sidebar_position:4,title:"Transitions"},a="Transitions",l={},d=[{value:"Introduction",id:"introduction",level:2},{value:"The Brobot Implementation: FromTransition and ToTransition",id:"the-brobot-implementation-fromtransition-and-totransition",level:2},{value:"Defining Transitions in Code",id:"defining-transitions-in-code",level:3},{value:"Complete Example: Traditional vs Modern",id:"complete-example-traditional-vs-modern",level:2},{value:"Traditional Approach",id:"traditional-approach",level:3},{value:"Modern Approach",id:"modern-approach",level:3},{value:"The Formal Model (Under the Hood)",id:"the-formal-model-under-the-hood",level:2},{value:"Modern Approach: Using @TransitionSet Annotation",id:"modern-approach-using-transitionset-annotation",level:2},{value:"@TransitionSet Annotation",id:"transitionset-annotation",level:3},{value:"Annotation Types",id:"annotation-types",level:3},{value:"@TransitionSet",id:"transitionset",level:4},{value:"@FromTransition",id:"fromtransition",level:4},{value:"@ToTransition",id:"totransition",level:4},{value:"Key Benefits of @TransitionSet",id:"key-benefits-of-transitionset",level:3},{value:"Comparison: Traditional vs Modern",id:"comparison-traditional-vs-modern",level:3},{value:"When to Use Each Approach",id:"when-to-use-each-approach",level:3},{value:"Dynamic Transitions for Hidden States",id:"dynamic-transitions-for-hidden-states",level:2},{value:"Dynamic Transitions with @Transition",id:"dynamic-transitions-with-transition",level:3}];function c(n){const i={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"transitions",children:"Transitions"})}),"\n",(0,s.jsx)(i.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsxs)(i.p,{children:['While States define "where you can be" in a GUI, ',(0,s.jsx)(i.strong,{children:"Transitions"}),' define "how you get there." Every State that is reachable needs an associated ',(0,s.jsx)(i.code,{children:"StateTransitions"})," class that defines the pathways to and from other states."]}),"\n",(0,s.jsx)(i.p,{children:'Formally, a transition is a process or a sequence of actions that changes the GUI from one state to another.  They form the "edges" of the state graph and are the building blocks used by the framework\'s pathfinder to navigate the application.'}),"\n",(0,s.jsx)(i.h2,{id:"the-brobot-implementation-fromtransition-and-totransition",children:"The Brobot Implementation: FromTransition and ToTransition"}),"\n",(0,s.jsxs)(i.p,{children:["Brobot implements this concept by splitting transitions into two types: ",(0,s.jsx)(i.strong,{children:"FromTransitions"})," and ",(0,s.jsx)(i.strong,{children:"ToTransitions"}),".  This two-part system provides a clear and reusable structure for managing navigation logic."]}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.img,{alt:"Transition Diagram",src:e(43607).A+"",width:"623",height:"196"}),"\n",(0,s.jsx)(i.em,{children:"This diagram is based on Figure 8 from the research paper."})]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"FromTransition"}),": This handles the process of leaving the ",(0,s.jsx)(i.em,{children:"current"})," state to go to another state. For example, to go from ",(0,s.jsx)(i.code,{children:"State A"})," to ",(0,s.jsx)(i.code,{children:"State B"}),", the FromTransition ",(0,s.jsx)(i.code,{children:"A -> B"})," is called. It contains the specific actions needed to initiate the move from State A."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"ToTransition"}),": This handles the final steps of arriving at a new state, regardless of which state started the process. There can be multiple FromTransitions going to ",(0,s.jsx)(i.code,{children:"State B"})," from different states, but there is only one ToTransition for ",(0,s.jsx)(i.code,{children:"State B"}),". This ",(0,s.jsx)(i.code,{children:"-> B"})," transition contains generic actions that must always run to confirm ",(0,s.jsx)(i.code,{children:"State B"})," is active."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"defining-transitions-in-code",children:"Defining Transitions in Code"}),"\n",(0,s.jsxs)(i.p,{children:["In the ",(0,s.jsx)(i.code,{children:"StateTransitions"})," Builder, you define these two types of transitions using specific commands:"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"addTransitionFinish"})," creates the ToTransition. The method passed to it is typically named ",(0,s.jsx)(i.code,{children:"finishTransition()"}),"."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"addTransition"})," creates a FromTransition. The methods passed to it can have any name and contain the actions for that specific path."]}),"\n"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-java",children:"// From the DoT test application in the paper \npublic class WorldTransitions {\n    // ...\n    StateTransitions transitions =\n        new StateTransitions.Builder(WORLD) // Defines transitions from the WORLD state\n            .addTransitionFinish(this::finishTransition) // This is the ToTransition for WORLD\n            .addTransition(new StateTransition.Builder() // This is a FromTransition\n                .addToActivate(ISLAND) // The target state is ISLAND\n                .setFunction(this::goToIsland) // The method with the actions\n                .build())\n            .build();\n    // ...\n}\n"})}),"\n",(0,s.jsx)(i.h2,{id:"complete-example-traditional-vs-modern",children:"Complete Example: Traditional vs Modern"}),"\n",(0,s.jsx)(i.h3,{id:"traditional-approach",children:"Traditional Approach"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-java",children:"// WorldTransitions.java\n@Component\n@RequiredArgsConstructor\npublic class WorldTransitions {\n    private final WorldState worldState;\n    private final Action action;\n    \n    public StateTransitions getStateTransitions() {\n        return new StateTransitions.Builder(WORLD)\n            .addTransitionFinish(this::finishTransition)\n            .addTransition(new StateTransition.Builder()\n                .addToActivate(ISLAND)\n                .setFunction(this::goToIsland)\n                .build())\n            .build();\n    }\n    \n    private boolean goToIsland() {\n        return action.click(worldState.getIslandPortal()).isSuccess();\n    }\n    \n    private boolean finishTransition() {\n        return action.find(worldState.getWorldMap()).isSuccess();\n    }\n}\n"})}),"\n",(0,s.jsx)(i.h3,{id:"modern-approach",children:"Modern Approach"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-java",children:"// WorldToIslandTransition.java\n@Transition(from = WorldState.class, to = IslandState.class)\n@RequiredArgsConstructor\npublic class WorldToIslandTransition {\n    private final WorldState worldState;\n    private final Action action;\n    \n    public boolean execute() {\n        return action.click(worldState.getIslandPortal()).isSuccess();\n    }\n}\n\n// ToWorldTransition.java (replaces finishTransition)\n@Transition(to = WorldState.class)\n@RequiredArgsConstructor\npublic class ToWorldTransition {\n    private final WorldState worldState;\n    private final Action action;\n    \n    public boolean execute() {\n        // Verify we're in the World state\n        return action.find(worldState.getWorldMap()).isSuccess();\n    }\n}\n"})}),"\n",(0,s.jsx)(i.h2,{id:"the-formal-model-under-the-hood",children:"The Formal Model (Under the Hood)"}),"\n",(0,s.jsxs)(i.p,{children:["The academic paper provides a formal definition for a transition as a tuple ",(0,s.jsxs)(i.strong,{children:["t = (A, S",(0,s.jsx)("sub",{children:"t"}),(0,s.jsx)("sup",{children:"def"}),")"]}),"."]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"A"})," is a ",(0,s.jsx)(i.strong,{children:"process"}),", which is a sequence of one or more actions ",(0,s.jsx)(i.code,{children:"(a\xb9, a\xb2, ..., a\u207f)"}),".  This corresponds to the method you pass to the builder (e.g., ",(0,s.jsx)(i.code,{children:"goToIsland"}),")."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsxs)(i.strong,{children:["S",(0,s.jsx)("sub",{children:"t"}),(0,s.jsx)("sup",{children:"def"})]})," is the ",(0,s.jsx)(i.strong,{children:"intended state information"}),".  This is an explicit definition of which states should become active or inactive if the transition succeeds. This makes state management more robust and predictable, as the framework doesn't have to guess the outcome.  This corresponds to builder methods like ",(0,s.jsx)(i.code,{children:".addToActivate(ISLAND)"}),"."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"modern-approach-using-transitionset-annotation",children:"Modern Approach: Using @TransitionSet Annotation"}),"\n",(0,s.jsx)(i.p,{children:"Brobot 1.2.0+ introduces a cohesive, method-level annotation approach that groups all transitions for a state in one class. This maintains high cohesion while providing clear, annotation-based configuration."}),"\n",(0,s.jsx)(i.h3,{id:"transitionset-annotation",children:"@TransitionSet Annotation"}),"\n",(0,s.jsxs)(i.p,{children:["The ",(0,s.jsx)(i.code,{children:"@TransitionSet"})," annotation marks a class as containing all transitions for a specific state:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-java",children:'@TransitionSet(state = PricingState.class)\n@RequiredArgsConstructor\n@Slf4j\npublic class PricingTransitions {\n    private final MenuState menuState;\n    private final HomepageState homepageState;\n    private final PricingState pricingState;\n    private final Action action;\n    \n    @FromTransition(from = MenuState.class, priority = 1)\n    public boolean fromMenu() {\n        log.info("Navigating from Menu to Pricing");\n        return action.click(menuState.getPricingButton()).isSuccess();\n    }\n    \n    @FromTransition(from = HomepageState.class, priority = 2)\n    public boolean fromHomepage() {\n        log.info("Navigating from Homepage to Pricing");\n        return action.click(homepageState.getPricingLink()).isSuccess();\n    }\n    \n    @ToTransition\n    public boolean verifyArrival() {\n        log.info("Verifying arrival at Pricing state");\n        return action.find(pricingState.getStartForFreeButton()).isSuccess();\n    }\n}\n'})}),"\n",(0,s.jsx)(i.h3,{id:"annotation-types",children:"Annotation Types"}),"\n",(0,s.jsx)(i.h4,{id:"transitionset",children:"@TransitionSet"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"state"}),": The state class these transitions belong to"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"name"}),": Optional state name override"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"description"}),": Documentation for the transition set"]}),"\n"]}),"\n",(0,s.jsx)(i.h4,{id:"fromtransition",children:"@FromTransition"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"from"}),": The source state class"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"priority"}),": Transition priority (higher = preferred)"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"description"}),": Documentation"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"timeout"}),": Timeout in seconds"]}),"\n"]}),"\n",(0,s.jsx)(i.h4,{id:"totransition",children:"@ToTransition"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"description"}),": Documentation"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"timeout"}),": Verification timeout"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"required"}),": Whether verification must succeed"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"key-benefits-of-transitionset",children:"Key Benefits of @TransitionSet"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"High Cohesion"}),": All transitions for a state in ONE class"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Clear Separation"}),": FromTransitions handle navigation, ToTransition verifies arrival"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Natural Organization"}),": Easy to find all paths to/from a state"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Spring Integration"}),": Full dependency injection support"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Type Safety"}),": Class-based state references"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Reduced Boilerplate"}),": Method-level annotations are concise"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"comparison-traditional-vs-modern",children:"Comparison: Traditional vs Modern"}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Aspect"}),(0,s.jsx)(i.th,{children:"Traditional StateTransitions"}),(0,s.jsx)(i.th,{children:"Modern @TransitionSet"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Organization"})}),(0,s.jsx)(i.td,{children:"All transitions in one builder"}),(0,s.jsx)(i.td,{children:"All transitions in one class with methods"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Cohesion"})}),(0,s.jsx)(i.td,{children:"High (single class)"}),(0,s.jsx)(i.td,{children:"High (single class)"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"FromTransitions"})}),(0,s.jsx)(i.td,{children:"addTransition() calls"}),(0,s.jsx)(i.td,{children:"@FromTransition methods"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"ToTransition"})}),(0,s.jsx)(i.td,{children:"addTransitionFinish()"}),(0,s.jsx)(i.td,{children:"@ToTransition method"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Registration"})}),(0,s.jsx)(i.td,{children:"Manual in listener"}),(0,s.jsx)(i.td,{children:"Automatic with Spring"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Type Safety"})}),(0,s.jsx)(i.td,{children:"String-based names"}),(0,s.jsx)(i.td,{children:"Class-based references"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Spring Integration"})}),(0,s.jsx)(i.td,{children:"Partial"}),(0,s.jsx)(i.td,{children:"Full integration"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"Clarity"})}),(0,s.jsx)(i.td,{children:"Builder pattern complexity"}),(0,s.jsx)(i.td,{children:"Clear method annotations"})]})]})]}),"\n",(0,s.jsx)(i.h3,{id:"when-to-use-each-approach",children:"When to Use Each Approach"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Use @TransitionSet (Modern)"})," for:"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"New projects starting with Brobot 1.2.0+"}),"\n",(0,s.jsx)(i.li,{children:"Projects that value cohesion and organization"}),"\n",(0,s.jsx)(i.li,{children:"Better Spring Boot integration"}),"\n",(0,s.jsx)(i.li,{children:"Cleaner, more maintainable code"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Use StateTransitions (Traditional)"})," for:"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Legacy projects that haven't migrated"}),"\n",(0,s.jsx)(i.li,{children:"Dynamic transition generation at runtime"}),"\n",(0,s.jsx)(i.li,{children:"Complex programmatic transition logic"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"dynamic-transitions-for-hidden-states",children:"Dynamic Transitions for Hidden States"}),"\n",(0,s.jsx)(i.p,{children:'In addition to these statically defined transitions, Brobot also supports dynamic transitions to handle common UI patterns like menus and pop-ups. When a state opens and covers another, the covered state is registered as "hidden."'}),"\n",(0,s.jsxs)(i.p,{children:["You can then define a transition with a dynamic target called ",(0,s.jsx)(i.strong,{children:(0,s.jsx)(i.code,{children:"PREVIOUS"})}),". When this transition is executed (e.g., by closing the menu), the framework intelligently navigates back to whatever state was most recently hidden, without you needing to pre-define every possible combination."]}),"\n",(0,s.jsx)(i.h3,{id:"dynamic-transitions-with-transition",children:"Dynamic Transitions with @Transition"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-java",children:'@Transition(\n    from = MenuState.class,\n    to = PreviousState.class,  // Special marker class for dynamic transitions\n    description = "Close menu and return to previous state"\n)\n@RequiredArgsConstructor\npublic class CloseMenuTransition {\n    private final MenuState menuState;\n    private final Action action;\n    \n    public boolean execute() {\n        // Click close button or press ESC\n        return action.click(menuState.getCloseButton()).isSuccess();\n    }\n}\n'})})]})}function h(n={}){const{wrapper:i}={...(0,r.R)(),...n.components};return i?(0,s.jsx)(i,{...n,children:(0,s.jsx)(c,{...n})}):c(n)}}}]);
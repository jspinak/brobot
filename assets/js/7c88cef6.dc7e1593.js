"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5881],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>s});var i=t(96540);const a={},o=i.createContext(a);function r(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(o.Provider,{value:n},e.children)}},82095:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"core-library/tutorials/tutorial-claude-automator/automation","title":"Continuous Monitoring Automation","description":"Overview","source":"@site/docs/03-core-library/tutorials/tutorial-claude-automator/automation.md","sourceDirName":"03-core-library/tutorials/tutorial-claude-automator","slug":"/core-library/tutorials/tutorial-claude-automator/automation","permalink":"/brobot/docs/core-library/tutorials/tutorial-claude-automator/automation","draft":false,"unlisted":false,"editUrl":"https://github.com/jspinak/brobot/edit/main/docs/docs/03-core-library/tutorials/tutorial-claude-automator/automation.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docSidebar","previous":{"title":"Claude Automator Example","permalink":"/brobot/docs/category/claude-automator-example"},"next":{"title":"Spring Configuration and Wiring","permalink":"/brobot/docs/core-library/tutorials/tutorial-claude-automator/configuration"}}');var a=t(74848),o=t(28453);const r={},s="Continuous Monitoring Automation",l={},c=[{value:"Overview",id:"overview",level:2},{value:"ClaudeMonitoringAutomation.java",id:"claudemonitoringautomationjava",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"1. Scheduled Monitoring",id:"1-scheduled-monitoring",level:3},{value:"2. State Management",id:"2-state-management",level:3},{value:"3. Enhanced Navigation",id:"3-enhanced-navigation",level:3},{value:"Alternative Implementation Patterns",id:"alternative-implementation-patterns",level:2},{value:"Event-Driven Approach",id:"event-driven-approach",level:3},{value:"Reactive Approach",id:"reactive-approach",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Monitoring Strategies",id:"monitoring-strategies",level:2},{value:"Quick Check (Current Implementation)",id:"quick-check-current-implementation",level:3},{value:"Deep Check Alternative",id:"deep-check-alternative",level:3},{value:"State-Aware Scheduling",id:"state-aware-scheduling",level:2},{value:"Enhanced Monitoring with State Validation",id:"enhanced-monitoring-with-state-validation",level:3},{value:"StateAwareScheduler Component",id:"stateawarescheduler-component",level:3},{value:"Configuration Options",id:"configuration-options",level:3},{value:"Enhanced Claude Automation Example",id:"enhanced-claude-automation-example",level:3},{value:"Benefits of State-Aware Scheduling",id:"benefits-of-state-aware-scheduling",level:3},{value:"Configuration Properties",id:"configuration-properties",level:3},{value:"Use Cases",id:"use-cases",level:3},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"continuous-monitoring-automation",children:"Continuous Monitoring Automation"})}),"\n",(0,a.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(n.p,{children:"The automation continuously monitors Claude's interface, detecting when the AI has finished responding and automatically reopening the Working state to continue the conversation."}),"\n",(0,a.jsx)(n.h2,{id:"claudemonitoringautomationjava",children:"ClaudeMonitoringAutomation.java"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'package com.claude.automator.automation;\n\nimport com.claude.automator.states.WorkingState;\nimport io.github.jspinak.brobot.action.Action;\nimport io.github.jspinak.brobot.action.basic.find.PatternFindOptions;\nimport io.github.jspinak.brobot.navigation.service.StateService;\nimport io.github.jspinak.brobot.navigation.service.StateMemory;\nimport io.github.jspinak.brobot.navigation.transition.StateNavigator;\nimport jakarta.annotation.PostConstruct;\nimport jakarta.annotation.PreDestroy;\nimport lombok.RequiredArgsConstructor;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.stereotype.Service;\n\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\n@Service\n@RequiredArgsConstructor\n@Slf4j\npublic class ClaudeMonitoringAutomation {\n    private final StateService stateService;\n    private final StateMemory stateMemory;\n    private final StateNavigator stateNavigator;\n    private final Action action;\n    private final WorkingState workingState;\n    \n    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);\n    private volatile boolean running = false;\n    \n    @PostConstruct\n    public void startMonitoring() {\n        log.info("Starting Claude monitoring automation");\n        running = true;\n        \n        // Check every 2 seconds\n        scheduler.scheduleWithFixedDelay(this::checkClaudeIconStatus, \n                5, 2, TimeUnit.SECONDS);\n    }\n    \n    @PreDestroy\n    public void stopMonitoring() {\n        log.info("Stopping Claude monitoring automation");\n        running = false;\n        scheduler.shutdown();\n        \n        try {\n            if (!scheduler.awaitTermination(5, TimeUnit.SECONDS)) {\n                scheduler.shutdownNow();\n            }\n        } catch (InterruptedException e) {\n            scheduler.shutdownNow();\n            Thread.currentThread().interrupt();\n        }\n    }\n    \n    private void checkClaudeIconStatus() {\n        if (!running) return;\n        \n        try {\n            // Check if Working state is active\n            Long workingStateId = workingState.getState().getId();\n            if (!stateMemory.getActiveStates().contains(workingStateId)) {\n                log.debug("Working state is not active, skipping check");\n                return;\n            }\n            \n            // Quick find to check if icon is still visible\n            PatternFindOptions quickFind = new PatternFindOptions.Builder()\n                    .setPauseBeforeBegin(0.5)\n                    .build();\n            \n            boolean iconFound = action.perform(quickFind, workingState.getClaudeIcon()).isSuccess();\n            \n            if (!iconFound) {\n                log.info("Claude icon disappeared - removing Working state and reopening");\n                \n                // Remove Working from active states\n                stateMemory.removeInactiveState(workingStateId);\n                \n                // Reopen Working state using enhanced StateNavigator\n                boolean success = stateNavigator.openState(WorkingState.Name.WORKING);\n                \n                if (success) {\n                    log.info("Successfully reopened Working state");\n                } else {\n                    log.error("Failed to reopen Working state");\n                }\n            } else {\n                log.debug("Claude icon still visible");\n            }\n        } catch (Exception e) {\n            log.error("Error during Claude icon monitoring", e);\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,a.jsx)(n.h3,{id:"1-scheduled-monitoring",children:"1. Scheduled Monitoring"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"scheduler.scheduleWithFixedDelay(\n    this::checkClaudeIconStatus,  // Method to run\n    5,                            // Initial delay (seconds)\n    2,                            // Period between runs (seconds)\n    TimeUnit.SECONDS\n);\n"})}),"\n",(0,a.jsx)(n.h3,{id:"2-state-management",children:"2. State Management"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"// Check if state is active\nif (!stateMemory.getActiveStates().contains(stateId)) {\n    // State is not active\n}\n\n// Remove state from active states\nstateMemory.removeInactiveState(stateId);\n"})}),"\n",(0,a.jsx)(n.h3,{id:"3-enhanced-navigation",children:"3. Enhanced Navigation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"// Use StateEnum for type-safe navigation\nboolean success = stateNavigator.openState(WorkingState.Name.WORKING);\n"})}),"\n",(0,a.jsx)(n.h2,{id:"alternative-implementation-patterns",children:"Alternative Implementation Patterns"}),"\n",(0,a.jsx)(n.h3,{id:"event-driven-approach",children:"Event-Driven Approach"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"@Component\npublic class EventDrivenAutomation {\n    @EventListener\n    public void onStateChange(StateChangeEvent event) {\n        if (event.getState().equals(WorkingState.Name.WORKING)) {\n            // React to state changes\n        }\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"reactive-approach",children:"Reactive Approach"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"@Component\npublic class ReactiveAutomation {\n    public Flux<Boolean> monitorClaudeIcon() {\n        return Flux.interval(Duration.ofSeconds(2))\n            .map(tick -> checkIconStatus())\n            .filter(iconMissing -> iconMissing)\n            .doOnNext(missing -> reopenWorkingState());\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Graceful Shutdown"}),": Always implement proper cleanup"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Thread Safety"}),": Use ",(0,a.jsx)(n.code,{children:"volatile"})," for shared state"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Error Handling"}),": Never let exceptions kill the monitoring thread"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Logging"}),": Use appropriate log levels (debug for frequent checks)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Performance"}),": Adjust check frequency based on requirements"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"monitoring-strategies",children:"Monitoring Strategies"}),"\n",(0,a.jsx)(n.h3,{id:"quick-check-current-implementation",children:"Quick Check (Current Implementation)"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Fast icon detection"}),"\n",(0,a.jsx)(n.li,{children:"Minimal resource usage"}),"\n",(0,a.jsx)(n.li,{children:"Good for responsive UIs"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"deep-check-alternative",children:"Deep Check Alternative"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"// More thorough validation\nActionResult result = action.perform(\n    new PatternFindOptions.Builder()\n        .setSearchRegion(SearchRegions.DESKTOP)\n        .setSimilarity(0.95)\n        .build(),\n    workingState.getClaudeIcon()\n);\n"})}),"\n",(0,a.jsx)(n.h2,{id:"state-aware-scheduling",children:"State-Aware Scheduling"}),"\n",(0,a.jsx)(n.h3,{id:"enhanced-monitoring-with-state-validation",children:"Enhanced Monitoring with State Validation"}),"\n",(0,a.jsx)(n.p,{children:"The framework now supports state-aware scheduling, which automatically validates and manages active states at the beginning of each scheduled cycle."}),"\n",(0,a.jsx)(n.h3,{id:"stateawarescheduler-component",children:"StateAwareScheduler Component"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'@Component\n@RequiredArgsConstructor\npublic class StateAwareScheduler {\n    private final StateDetector stateDetector;\n    private final StateMemory stateMemory;\n    private final StateService stateService;\n    \n    public void scheduleWithStateCheck(\n            ScheduledExecutorService scheduler,\n            Runnable task,\n            StateCheckConfiguration config,\n            long initialDelay,\n            long period,\n            TimeUnit unit) {\n        \n        scheduler.scheduleAtFixedRate(() -> {\n            try {\n                performStateCheck(config);\n                task.run();\n            } catch (Exception e) {\n                log.error("Error in state-aware scheduled task", e);\n            }\n        }, initialDelay, period, unit);\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"configuration-options",children:"Configuration Options"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'StateCheckConfiguration config = new StateCheckConfiguration.Builder()\n    .withRequiredStates(List.of("Prompt", "Working"))  // States that must be active\n    .withRebuildOnMismatch(true)                       // Auto-rebuild if states missing\n    .withSkipIfStatesMissing(false)                    // Continue even if states missing\n    .build();\n'})}),"\n",(0,a.jsx)(n.h3,{id:"enhanced-claude-automation-example",children:"Enhanced Claude Automation Example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'@Service\n@RequiredArgsConstructor\n@Slf4j\npublic class ClaudeMonitoringAutomationV2 {\n    private final StateAwareScheduler stateAwareScheduler;\n    // ... other dependencies ...\n    \n    @PostConstruct\n    public void startMonitoring() {\n        // Configure state validation\n        StateCheckConfiguration stateConfig = new StateCheckConfiguration.Builder()\n                .withRequiredStates(List.of("Prompt", "Working"))\n                .withRebuildOnMismatch(true)\n                .build();\n        \n        // Schedule with automatic state checking\n        stateAwareScheduler.scheduleWithStateCheck(\n                scheduler,\n                this::getClaudeWorking,\n                stateConfig,\n                initialDelay,\n                checkInterval,\n                TimeUnit.SECONDS\n        );\n    }\n    \n    private void getClaudeWorking() {\n        // Task runs after state validation\n        // States are guaranteed to be checked/rebuilt\n        if (selectClaudePrompt()) {\n            checkClaudeIconStatus();\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"benefits-of-state-aware-scheduling",children:"Benefits of State-Aware Scheduling"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Automatic State Validation"}),": Ensures required states are active before task execution"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Self-Healing"}),": Can automatically rebuild states if they're missing"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Separation of Concerns"}),": State management logic is isolated from business logic"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Configurable Behavior"}),": Flexible options for different scenarios"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Error Recovery"}),": Handles state mismatches gracefully"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"configuration-properties",children:"Configuration Properties"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-properties",children:"# State-Aware Scheduling Configuration\nclaude.automator.monitoring.required-states=Prompt,Working\nclaude.automator.monitoring.rebuild-on-mismatch=true\nclaude.automator.monitoring.initial-delay=5\nclaude.automator.monitoring.check-interval=2\n"})}),"\n",(0,a.jsx)(n.h3,{id:"use-cases",children:"Use Cases"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"GUI State Validation"}),": Ensure expected GUI states before automation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Recovery from Crashes"}),": Automatically detect and recover lost states"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Complex Workflows"}),": Maintain state integrity in multi-step processes"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Background Monitoring"}),": Keep automation aligned with application state"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,a.jsx)(n.p,{children:"Finally, we'll wire everything together with Spring configuration to create a complete working application."})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);
"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9877],{28453:(t,e,i)=>{i.d(e,{R:()=>a,x:()=>r});var n=i(96540);const s={},o=n.createContext(s);function a(t){const e=n.useContext(o);return n.useMemo(function(){return"function"==typeof t?t(e):{...e,...t}},[e,t])}function r(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(s):t.components||s:a(t.components),n.createElement(o.Provider,{value:e},t.children)}},82394:(t,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"theoretical-foundations/testing-automation","title":"Testing the Automation","description":"A fundamental innovation of model-based GUI automation is its ability to enable systematic testing of the automation code itself. This introduces standard software engineering practices like unit and integration testing into a domain where they were previously considered infeasible.","source":"@site/docs/05-theoretical-foundations/testing-automation.md","sourceDirName":"05-theoretical-foundations","slug":"/theoretical-foundations/testing-automation","permalink":"/brobot/docs/theoretical-foundations/testing-automation","draft":false,"unlisted":false,"editUrl":"https://github.com/jspinak/brobot/edit/main/docs/docs/05-theoretical-foundations/testing-automation.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7,"title":"Testing the Automation"},"sidebar":"docSidebar","previous":{"title":"Transitions","permalink":"/brobot/docs/theoretical-foundations/transitions"},"next":{"title":"Integrations","permalink":"/brobot/docs/category/integrations"}}');var s=i(74848),o=i(28453);const a={sidebar_position:7,title:"Testing the Automation"},r="Testing the Automation",l={},c=[{value:"Integration Testing Through Mocking",id:"integration-testing-through-mocking",level:2},{value:"Unit Testing",id:"unit-testing",level:2},{value:"Model Validation",id:"model-validation",level:2}];function d(t){const e={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...t.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"testing-the-automation",children:"Testing the Automation"})}),"\n",(0,s.jsx)(e.p,{children:"A fundamental innovation of model-based GUI automation is its ability to enable systematic testing of the automation code itself. This introduces standard software engineering practices like unit and integration testing into a domain where they were previously considered infeasible."}),"\n",(0,s.jsx)(e.p,{children:"It is important to distinguish between:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Testing Automation"}),": Testing the automation code itself. This is what the model-based approach enables."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Automated Testing"}),": Using an automation application to test external software."]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"integration-testing-through-mocking",children:"Integration Testing Through Mocking"}),"\n",(0,s.jsxs)(e.p,{children:["In model-based GUI automation, integration testing is achieved by mocking GUI interactions. During a mock run, the automation does not interact with the live GUI environment (",(0,s.jsx)("span",{class:"math-inline",children:"\\Xi"}),", ",(0,s.jsx)("span",{class:"math-inline",children:"\\Theta"}),")."]}),"\n",(0,s.jsxs)(e.p,{children:["Instead, it operates on a predefined ",(0,s.jsx)(e.strong,{children:"Action History (AH)"})," that contains recorded outcomes of previous GUI interactions."]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["The mock action function (",(0,s.jsx)(e.code,{children:"f_a^{mock}"}),") replaces the live GUI with the set of active states as its input."]}),"\n",(0,s.jsx)(e.li,{children:"When an action is to be executed, the framework finds a matching historical action from the Action History."}),"\n",(0,s.jsx)(e.li,{children:"The historical results are then used as the results of the current action, simulating a live interaction."}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"This allows for testing the entire system's behavior and state transitions without needing a live, and often stochastic, GUI environment."}),"\n",(0,s.jsx)(e.h2,{id:"unit-testing",children:"Unit Testing"}),"\n",(0,s.jsx)(e.p,{children:"Unit testing requires deterministic verification of individual components. The framework uses a hybrid approach for this:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"For observation actions"})," (like finding an image), the test runs against a fixed scene, such as a static screenshot (",(0,s.jsx)("span",{class:"math-inline",children:"\\Xi_{x}"}),"). This allows for the validation of real image recognition functionality in a reproducible way."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"For all other actions"})," (like clicks or keyboard inputs), the results are simulated using selected historical data from action snapshots, just like in integration testing."]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"This hybrid model ensures that tests are fully reproducible while still validating critical functionality."}),"\n",(0,s.jsx)(e.h2,{id:"model-validation",children:"Model Validation"}),"\n",(0,s.jsx)(e.p,{children:"This testing capability serves a dual purpose. It not only validates the automation instructions but also verifies the accuracy of the state structure (\u03a9) itself. Mock run failures can point to errors or gaps in the model, such as:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"A missing transition between two states."}),"\n",(0,s.jsx)(e.li,{children:"An incomplete set of elements required for a transition."}),"\n",(0,s.jsx)(e.li,{children:"An inadequately defined state."}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"This allows for the iterative improvement and development of an increasingly accurate model of the GUI environment."})]})}function h(t={}){const{wrapper:e}={...(0,o.R)(),...t.components};return e?(0,s.jsx)(e,{...t,children:(0,s.jsx)(d,{...t})}):d(t)}}}]);
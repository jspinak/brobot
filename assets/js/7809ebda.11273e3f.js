"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3391],{22598:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"testing/integration-testing","title":"Integration Testing","description":"Integration testing in Brobot simulates the complete application environment and workflow. Unlike unit testing which focuses on individual components, integration testing validates entire automation sequences using mock execution to ensure robustness and reliability.","source":"@site/docs/04-testing/integration-testing.md","sourceDirName":"04-testing","slug":"/testing/integration-testing","permalink":"/brobot/docs/testing/integration-testing","draft":false,"unlisted":false,"editUrl":"https://github.com/jspinak/brobot/edit/main/docs/docs/04-testing/integration-testing.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"docSidebar","previous":{"title":"Testing Overview","permalink":"/brobot/docs/testing/testing-intro"},"next":{"title":"Mock Mode Guide","permalink":"/brobot/docs/testing/mock-mode-guide"}}');var s=e(74848),o=e(28453);const r={sidebar_position:2},a="Integration Testing",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Configuration",id:"configuration",level:2},{value:"Configuration via Properties",id:"configuration-via-properties",level:3},{value:"Test Configuration",id:"test-configuration",level:3},{value:"Mock Execution Architecture",id:"mock-execution-architecture",level:2},{value:"How Mocking Works",id:"how-mocking-works",level:3},{value:"Mock Timing Configuration",id:"mock-timing-configuration",level:3},{value:"State Object Initialization",id:"state-object-initialization",level:2},{value:"Action History Setup",id:"action-history-setup",level:3},{value:"State Structure Builder Integration",id:"state-structure-builder-integration",level:3},{value:"API Migration Note",id:"api-migration-note",level:3},{value:"Log Output Analysis",id:"log-output-analysis",level:3},{value:"Test Assertions and Validation",id:"test-assertions-and-validation",level:2},{value:"Modern Assertion Patterns",id:"modern-assertion-patterns",level:3},{value:"Performance Assertions",id:"performance-assertions",level:3},{value:"Custom Test Matchers",id:"custom-test-matchers",level:3},{value:"Best Practices",id:"best-practices",level:2}];function d(n){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"integration-testing",children:"Integration Testing"})}),"\n",(0,s.jsx)(t.p,{children:"Integration testing in Brobot simulates the complete application environment and workflow. Unlike unit testing which focuses on individual components, integration testing validates entire automation sequences using mock execution to ensure robustness and reliability."}),"\n",(0,s.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(t.p,{children:"Integration testing provides:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Full application simulation"})," without GUI interaction"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Stochastic modeling"})," of real-world variability"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"State transition validation"})," across complex workflows"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Risk assessment"})," for automation reliability"]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"configuration",children:"Configuration"}),"\n",(0,s.jsx)(t.h3,{id:"configuration-via-properties",children:"Configuration via Properties"}),"\n",(0,s.jsx)(t.p,{children:"Enable integration testing through configuration:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-properties",children:"# Enable mock mode for integration testing\nbrobot.core.mock=true\n\n# Mock timing configuration\nbrobot.mock.time-find-first=0.1\nbrobot.mock.time-find-all=0.2\nbrobot.mock.time-click=0.05\nbrobot.mock.time-drag=0.3\n\n# Testing settings\nbrobot.testing.iteration=1\nbrobot.testing.send-logs=true\n\n# Dataset collection (optional)\nbrobot.dataset.build=false\nbrobot.dataset.path=dataset/\n"})}),"\n",(0,s.jsx)(t.p,{children:"Or using YAML:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",children:"brobot:\n  core:\n    mock: true\n  mock:\n    time-find-first: 0.1\n    time-find-all: 0.2\n    time-click: 0.05\n    time-drag: 0.3\n  testing:\n    iteration: 1\n    send-logs: true\n"})}),"\n",(0,s.jsx)(t.h3,{id:"test-configuration",children:"Test Configuration"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:'@SpringBootTest\n@TestPropertySource(properties = "brobot.core.mock=true")\npublic class IntegrationTestConfig {\n    // Configuration handled automatically by Spring Boot\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"mock-execution-architecture",children:"Mock Execution Architecture"}),"\n",(0,s.jsx)(t.p,{children:"Brobot's mocking system provides comprehensive simulation of GUI automation:"}),"\n",(0,s.jsx)(t.h3,{id:"how-mocking-works",children:"How Mocking Works"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Action Interception"}),": All GUI actions (click, find, drag) are intercepted at the wrapper level"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Realistic Timing"}),": Mock operations use configurable delays to simulate real execution"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Stochastic Results"}),": Actions return probabilistic outcomes based on historical data"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Transparent Operation"}),": Application code runs identically in mock and live modes"]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"mock-timing-configuration",children:"Mock Timing Configuration"}),"\n",(0,s.jsx)(t.p,{children:"Configure mock timings via properties:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-properties",children:"# Configure realistic timings for different actions\nbrobot.mock.time-find-first=0.1\nbrobot.mock.time-find-all=0.3\nbrobot.mock.time-click=0.05\nbrobot.mock.time-drag=0.4\nbrobot.mock.time-move=0.2\n"})}),"\n",(0,s.jsx)(t.p,{children:"Or per-test configuration:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:'@Test\n@TestPropertySource(properties = {\n    "brobot.mock.time-find-first=0.1",\n    "brobot.mock.time-click=0.05"\n})\nvoid testWithCustomTimings() {\n    // Test uses configured mock timings\n}\n'})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"wrappers",src:e(76359).A+"",width:"1920",height:"1080"})}),"\n",(0,s.jsx)(t.p,{children:"Mocking can uncover errors in the code in the same way that traditional testing, for\nexample JUnit testing, does. You don't have to wait 30 minutes to realize that you\nforgot to name the new image you saved, and your application can't find it. This\nhappens instantly."}),"\n",(0,s.jsx)(t.p,{children:"Mocking also provides insight into how robust your code is. Parts of the code with\nnarrow paths (little redundancy in making a transition from state A to state B)\nmay perform poorly if a state has a low probability of appearing. You can introduce\nprocess flow errors into the mocks, including sending your process to an unknown state,\nto see how your app will behave."}),"\n",(0,s.jsx)(t.h2,{id:"state-object-initialization",children:"State Object Initialization"}),"\n",(0,s.jsx)(t.h3,{id:"action-history-setup",children:"Action History Setup"}),"\n",(0,s.jsx)(t.p,{children:"State objects should be initialized with realistic action histories for proper mock behavior. The modern approach uses ActionConfig-based snapshots:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:'@Component\npublic class StateInitializer {\n    \n    public StateImage createLoginButton() {\n        return new StateImage.Builder()\n            .addPattern("login_button")\n            .setName("LoginButton")\n            .build();\n    }\n    \n    // Add action history snapshots to patterns\n    public void initializeActionHistory(StateImage stateImage) {\n        Pattern pattern = stateImage.getPatterns().get(0);\n        ActionHistory history = pattern.getActionHistory();\n        \n        // Add find snapshots with modern ActionConfig\n        history.addSnapshot(createFindSnapshot());\n        history.addSnapshot(createClickSnapshot());\n    }\n    \n    private ActionRecord createFindSnapshot() {\n        return new ActionRecord.Builder()\n            .setActionConfig(new PatternFindOptions.Builder()\n                .setStrategy(PatternFindOptions.Strategy.BEST)\n                .setSimilarity(0.95)\n                .build())\n            .addMatch(new Match.Builder()\n                .setRegion(100, 200, 80, 30)\n                .setSimScore(0.95)\n                .build())\n            .setActionSuccess(true)\n            .build();\n    }\n    \n    private ActionRecord createClickSnapshot() {\n        return new ActionRecord.Builder()\n            .setActionConfig(new ClickOptions.Builder()\n                .setClickType(ClickOptions.Type.LEFT)\n                .build())\n            .setActionSuccess(true)\n            .build();\n    }\n}\n'})}),"\n",(0,s.jsx)(t.h3,{id:"state-structure-builder-integration",children:"State Structure Builder Integration"}),"\n",(0,s.jsx)(t.p,{children:"When using the State Structure Builder, mock data is automatically generated:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Screenshot Analysis"}),": Captures current application screens"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Image Recognition"}),": Analyzes UI elements and their properties"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"History Generation"}),": Creates realistic action histories from analysis"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Code Generation"}),": Produces Java code with pre-configured mock data"]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:'// Generated by State Structure Builder\npublic class GeneratedStates {\n    \n    public static StateImage getSubmitButton() {\n        StateImage submitButton = new StateImage.Builder()\n            .addPattern("submit_button")\n            .setName("SubmitButton")\n            .build();\n            \n        // Initialize with auto-generated action histories\n        initializeActionHistory(submitButton);\n        return submitButton;\n    }\n    \n    private static void initializeActionHistory(StateImage stateImage) {\n        Pattern pattern = stateImage.getPatterns().get(0);\n        ActionHistory history = pattern.getActionHistory();\n        \n        // Generated from actual screenshot analysis\n        history.addSnapshot(createSnapshot(0.98, 245, 356, 120, 35));\n        history.addSnapshot(createSnapshot(0.96, 245, 356, 120, 35));\n        history.addSnapshot(createSnapshot(0.89, 245, 356, 120, 35));\n    }\n    \n    private static ActionRecord createSnapshot(double score, int x, int y, int w, int h) {\n        return new ActionRecord.Builder()\n            .setActionConfig(new PatternFindOptions.Builder()\n                .setStrategy(PatternFindOptions.Strategy.BEST)\n                .build())\n            .addMatch(new Match.Builder()\n                .setRegion(x, y, w, h)\n                .setSimScore(score)\n                .build())\n            .setActionSuccess(true)\n            .build();\n    }\n}\n'})}),"\n",(0,s.jsx)(t.h3,{id:"api-migration-note",children:"API Migration Note"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Important"}),": The ActionHistory class is currently in a transitional state. While the modern ActionConfig system is the recommended approach, ActionHistory still uses ",(0,s.jsx)(t.code,{children:"ActionOptions.Action"})," internally for backward compatibility. The examples above show the intended modern API pattern that will be fully supported in future versions."]}),"\n",(0,s.jsx)(t.p,{children:"Current ActionHistory methods that still use the legacy API:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.code,{children:"getRandomSnapshot(ActionOptions.Action action)"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.code,{children:"getRandomSnapshot(ActionOptions.Action action, Long state)"})}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"For now, when working with ActionHistory directly, you may need to use adapter patterns or continue using ActionOptions.Action until the migration is complete."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"private static List<ActionResult> getFindHistorySubmitButton() {\n    // Generated from actual screenshot analysis\n    return Arrays.asList(\n        createActionResult(0.98, 245, 356, 120, 35),\n        createActionResult(0.96, 245, 356, 120, 35),\n        createActionResult(0.89, 245, 356, 120, 35)\n    );\n}\n"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:'\n## Logging and Monitoring\n\n### Comprehensive Test Logging\n\nMock execution provides detailed logging for debugging and analysis:\n\n```java\n@SpringBootTest\n@TestPropertySource(properties = {\n    "brobot.core.mock=true",\n    "brobot.testing.send-logs=true",\n    "brobot.logging.verbosity=VERBOSE"\n})\npublic class IntegrationTestWithLogging {\n    \n    private static final Logger logger = LoggerFactory.getLogger(IntegrationTestWithLogging.class);\n    \n    @Autowired\n    private Action action;\n    \n    @Autowired\n    private StateImageRepository stateImageRepo;\n    \n    @Test\n    public void testCompleteWorkflow() {\n        logger.info("Starting integration test workflow");\n        \n        // Mock execution provides full logging\n        PatternFindOptions findOptions = new PatternFindOptions.Builder()\n            .setStrategy(PatternFindOptions.Strategy.BEST)\n            .build();\n        \n        StateImage loginButton = stateImageRepo.get("login_button");\n        ActionResult loginResult = action.perform(findOptions, loginButton);\n        logger.info("Login result: {} matches found", loginResult.size());\n        \n        ClickOptions clickOptions = new ClickOptions.Builder().build();\n        action.perform(clickOptions, loginButton);\n        \n        StateImage dashboardMenu = stateImageRepo.get("dashboard_menu");\n        ActionResult navigationResult = action.perform(findOptions, dashboardMenu);\n        logger.info("Navigation result: success={}", navigationResult.isSuccess());\n        \n        // Process data with multiple finds\n        PatternFindOptions findAllOptions = new PatternFindOptions.Builder()\n            .setStrategy(PatternFindOptions.Strategy.ALL)\n            .build();\n        StateImage dataRows = stateImageRepo.get("data_rows");\n        ActionResult dataResult = action.perform(findAllOptions, dataRows);\n        logger.info("Data processing completed with {} operations", dataResult.size());\n    }\n}\n'})}),"\n",(0,s.jsx)(t.h3,{id:"log-output-analysis",children:"Log Output Analysis"}),"\n",(0,s.jsx)(t.p,{children:"Mock runs produce detailed output including:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Action Timing"}),": Simulated execution durations"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Decision Points"}),": State transition logic"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Match Results"}),": Simulated find operation outcomes"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Error Conditions"}),": Exception handling and recovery"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Performance Metrics"}),": Mock operation statistics"]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"[INFO] Starting integration test workflow\n[DEBUG] Mock FIND operation: login_button.png -> 1 match (score: 0.95, time: 120ms)\n[DEBUG] Mock CLICK operation: (100,200) -> SUCCESS (time: 50ms)\n[INFO] Login result: 1 matches found\n[DEBUG] State transition: LOGIN -> DASHBOARD (probability: 0.95)\n[DEBUG] Mock FIND operation: dashboard_menu.png -> 2 matches (time: 200ms)\n[INFO] Navigation result: success=true\n"})}),"\n",(0,s.jsx)(t.h2,{id:"test-assertions-and-validation",children:"Test Assertions and Validation"}),"\n",(0,s.jsx)(t.h3,{id:"modern-assertion-patterns",children:"Modern Assertion Patterns"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:'public class IntegrationTestAssertions {\n    \n    @Test\n    public void testWorkflowReliability() {\n        // Test multiple mock runs for consistency\n        List<ActionResult> results = new ArrayList<>();\n        \n        // Configure action for workflow\n        PatternFindOptions findOptions = new PatternFindOptions.Builder()\n            .setStrategy(PatternFindOptions.Strategy.BEST)\n            .setSimilarity(0.85)\n            .then(new ClickOptions.Builder().build())  // Chain find with click\n            .build();\n        \n        StateImage criticalButton = stateImageRepo.get("critical_button");\n        \n        for (int i = 0; i < 10; i++) {\n            // Each iteration uses configuration properties\n            ActionResult result = action.perform(findOptions, criticalButton);\n            results.add(result);\n        }\n        \n        // Assert workflow reliability\n        long successCount = results.stream()\n            .filter(ActionResult::isSuccess)\n            .count();\n            \n        double successRate = (double) successCount / results.size();\n        assertTrue(successRate >= 0.8, \n            String.format("Workflow success rate %.2f below threshold 0.8", successRate));\n    }\n    \n    @Test\n    public void testStateTransitionProbabilities() {\n        // Test state transition reliability\n        Map<String, Integer> transitionCounts = new HashMap<>();\n        \n        State loginState = stateRepository.get("LOGIN");\n        StateImage dashboardLink = loginState.getStateImages().stream()\n            .filter(img -> img.getName().equals("dashboard_link"))\n            .findFirst().orElseThrow();\n        \n        PatternFindOptions findAndClick = new PatternFindOptions.Builder()\n            .setStrategy(PatternFindOptions.Strategy.BEST)\n            .then(new ClickOptions.Builder().build())\n            .build();\n        \n        for (int i = 0; i < 100; i++) {\n            ActionResult result = action.perform(findAndClick, dashboardLink);\n            String outcome = result.isSuccess() ? "SUCCESS" : "FAILURE";\n            transitionCounts.merge(outcome, 1, Integer::sum);\n        }\n        \n        // Verify expected probability distribution\n        double successRate = (double) transitionCounts.getOrDefault("SUCCESS", 0) / 100;\n        assertTrue(successRate >= 0.85, "State transition success rate too low");\n        assertTrue(successRate <= 0.98, "State transition success rate unrealistically high");\n    }\n    \n    @Test\n    public void testErrorRecovery() {\n        // Test recovery mechanisms with retry logic\n        StateImage problematicElement = stateImageRepo.get("problematic_element");\n        \n        // Configure action with retry\n        PatternFindOptions findWithRetry = new PatternFindOptions.Builder()\n            .setStrategy(PatternFindOptions.Strategy.BEST)\n            .setMaxIterations(3)  // Retry up to 3 times\n            .setPauseBeforeRetry(0.5)\n            .build();\n        \n        ActionResult result = action.perform(findWithRetry, problematicElement);\n        \n        // In mock mode, the retry behavior is simulated\n        // Check that appropriate retries were attempted\n        assertTrue(result.getAttempts() <= 3, "Too many retry attempts");\n        \n        // For successful recovery after retries\n        if (result.isSuccess()) {\n            assertTrue(result.getAttempts() > 1, "Recovery should have required retries");\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(t.h3,{id:"performance-assertions",children:"Performance Assertions"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:'@Test\npublic void testPerformanceCharacteristics() {\n    long startTime = System.currentTimeMillis();\n    \n    // Complex workflow with multiple actions\n    PatternFindOptions complexFind = new PatternFindOptions.Builder()\n        .setStrategy(PatternFindOptions.Strategy.ALL)\n        .setSimilarity(0.9)\n        .then(new DefineRegionOptions.Builder()\n            .setDefineAs(DefineRegionOptions.DefineAs.INSIDE_ANCHORS)\n            .build())\n        .then(new ClickOptions.Builder()\n            .setClickType(ClickOptions.Type.DOUBLE)\n            .build())\n        .build();\n    \n    StateImage complexElement = stateImageRepo.get("complex_element");\n    ActionResult result = action.perform(complexFind, complexElement);\n    \n    long duration = System.currentTimeMillis() - startTime;\n    \n    // Assert mock timing is realistic\n    assertTrue(duration >= 500, "Mock execution too fast - unrealistic");\n    assertTrue(duration <= 2000, "Mock execution too slow - check configuration");\n    \n    // Assert result quality\n    assertTrue(result.isSuccess());\n    assertFalse(result.isEmpty());\n}\n'})}),"\n",(0,s.jsx)(t.h3,{id:"custom-test-matchers",children:"Custom Test Matchers"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:'public class BrobotMatchers {\n    \n    public static Matcher<ActionResult> hasMinimumMatches(int minCount) {\n        return new TypeSafeMatcher<ActionResult>() {\n            @Override\n            protected boolean matchesSafely(ActionResult result) {\n                return result.size() >= minCount;\n            }\n            \n            @Override\n            public void describeTo(Description description) {\n                description.appendText("ActionResult with at least ").appendValue(minCount).appendText(" matches");\n            }\n        };\n    }\n    \n    public static Matcher<ActionResult> hasSuccessfulExecution() {\n        return new TypeSafeMatcher<ActionResult>() {\n            @Override\n            protected boolean matchesSafely(ActionResult result) {\n                return result.isSuccess() && !result.isEmpty();\n            }\n            \n            @Override\n            public void describeTo(Description description) {\n                description.appendText("successful ActionResult with matches");\n            }\n        };\n    }\n}\n\n// Usage in tests\n@Test\npublic void testWithCustomMatchers() {\n    PatternFindOptions findOptions = new PatternFindOptions.Builder()\n        .setStrategy(PatternFindOptions.Strategy.ALL)\n        .build();\n    \n    StateImage buttons = stateImageRepo.get("buttons");\n    ActionResult result = action.perform(findOptions, buttons);\n    \n    assertThat(result, hasMinimumMatches(2));\n    assertThat(result, hasSuccessfulExecution());\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Modern API Usage"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Use ActionConfig subclasses (PatternFindOptions, ClickOptions, etc.) instead of ActionOptions"}),"\n",(0,s.jsx)(t.li,{children:"Configure actions through properties files rather than programmatic setup"}),"\n",(0,s.jsxs)(t.li,{children:["Leverage action chaining with ",(0,s.jsx)(t.code,{children:".then()"})," for complex workflows"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Realistic Mock Data"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Use actual screenshot analysis to generate mock histories"}),"\n",(0,s.jsx)(t.li,{children:"Include both success and failure scenarios with ActionRecord snapshots"}),"\n",(0,s.jsx)(t.li,{children:"Model realistic timing and variability through ActionConfig"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Comprehensive Testing"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Test complete workflows, not just individual actions"}),"\n",(0,s.jsx)(t.li,{children:"Include error conditions and recovery paths"}),"\n",(0,s.jsx)(t.li,{children:"Validate state transitions and probabilities"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Performance Considerations"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Configure realistic mock timings via properties"}),"\n",(0,s.jsx)(t.li,{children:"Test for performance regressions"}),"\n",(0,s.jsx)(t.li,{children:"Monitor mock execution efficiency"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Continuous Integration"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Run integration tests in CI/CD pipelines"}),"\n",(0,s.jsx)(t.li,{children:"Use deterministic random seeds for reproducible results"}),"\n",(0,s.jsx)(t.li,{children:"Archive test logs and reports for analysis"}),"\n"]}),"\n"]}),"\n"]})]})}function u(n={}){const{wrapper:t}={...(0,o.R)(),...n.components};return t?(0,s.jsx)(t,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},28453:(n,t,e)=>{e.d(t,{R:()=>r,x:()=>a});var i=e(96540);const s={},o=i.createContext(s);function r(n){const t=i.useContext(o);return i.useMemo(function(){return"function"==typeof n?n(t):{...t,...n}},[t,n])}function a(n){let t;return t=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:r(n.components),i.createElement(o.Provider,{value:t},n.children)}},76359:(n,t,e)=>{e.d(t,{A:()=>i});const i=e.p+"assets/images/wrappers-8f5e2e7afa7fb9b1452c20daaa9e6e83.jpeg"}}]);
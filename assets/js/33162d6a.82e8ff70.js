"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3337],{28453:(e,t,i)=>{i.d(t,{R:()=>a,x:()=>r});var n=i(96540);const s={},o=n.createContext(s);function a(e){const t=n.useContext(o);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),n.createElement(o.Provider,{value:t},e.children)}},52938:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>a,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"core-library/tutorials/tutorial-basics/mock-results","title":"Mock Results","description":"This tutorial was originally created for an earlier version of Brobot but has been updated for version 1.1.0. The original code examples are available in documentation versions 1.0.6 and 1.0.7.","source":"@site/docs/03-core-library/tutorials/tutorial-basics/mock-results.md","sourceDirName":"03-core-library/tutorials/tutorial-basics","slug":"/core-library/tutorials/tutorial-basics/mock-results","permalink":"/brobot/docs/core-library/tutorials/tutorial-basics/mock-results","draft":false,"unlisted":false,"editUrl":"https://github.com/jspinak/brobot/edit/main/docs/docs/03-core-library/tutorials/tutorial-basics/mock-results.md","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9},"sidebar":"docSidebar","previous":{"title":"Save Labeled Images","permalink":"/brobot/docs/core-library/tutorials/tutorial-basics/save-labeled-image"},"next":{"title":"Live Results","permalink":"/brobot/docs/core-library/tutorials/tutorial-basics/live-results"}}');var s=i(74848),o=i(28453);const a={sidebar_position:9},r="Mock Results",l={},c=[{value:"Console Output",id:"console-output",level:2},{value:"Playing with the Mock",id:"playing-with-the-mock",level:2}];function d(e){const t={admonition:"admonition",br:"br",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"mock-results",children:"Mock Results"})}),"\n",(0,s.jsx)(t.admonition,{title:"Version Note",type:"info",children:(0,s.jsx)(t.p,{children:"This tutorial was originally created for an earlier version of Brobot but has been updated for version 1.1.0. The original code examples are available in documentation versions 1.0.6 and 1.0.7."})}),"\n",(0,s.jsx)(t.h2,{id:"console-output",children:"Console Output"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["add WORLD to active states\nOpen State ISLAND\nFind path: [WORLD] -> ISLAND\n_(score)",(0,s.jsx)(t.em,{children:"Paths Found"}),"\n(2)-> WORLD -> ISLAND\n|CLICK WORLD.searchButton| Find.FIRST 36:05 found=true [click] wait-0,2 [click] CLICK \u2713\nstates to activate: [ISLAND]\n|FIND ISLAND.island type text| Find.FIRST 36:05 found=true + add ISLAND to active states FIND \u2713\n\u2713 Transition WORLD->ISLAND successful.\nActive States: [WORLD, ISLAND]"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"|CLICK WORLD.searchButton| Find.FIRST 36:05 found=true [click] wait-0,2 [click] CLICK \u2713\n|FIND wait-3,0 Find.ALL_WORDS FIND \u2713\ntext = Mines\n|DEFINE Define as: MATCH| DEFINE \u2713\nSave file with base path DOTislands/labeledImages/Mines"}),"\n",(0,s.jsx)(t.p,{children:"|CLICK WORLD.searchButton| Find.FIRST 36:09 found=true [click] wait-0,2 [click] CLICK \u2713\n|FIND wait-3,0 Find.ALL_WORDS FIND \u2713\ntext = Farms\nSave file with base path DOTislands/labeledImages/Farms"}),"\n",(0,s.jsx)(t.p,{children:"|CLICK WORLD.searchButton| Find.FIRST 36:12 found=true [click] wait-0,2 [click] CLICK \u2713\n|FIND wait-3,0 Find.ALL_WORDS FIND \u2713\ntext = Lakes\nSave file with base path DOTislands/labeledImages/Lakes"}),"\n",(0,s.jsxs)(t.p,{children:["... ",(0,s.jsx)("i",{children:"this repeats 100 times (if you entered 100 as the max images to save)"})]}),"\n",(0,s.jsx)(t.h2,{id:"playing-with-the-mock",children:"Playing with the Mock"}),"\n",(0,s.jsx)(t.p,{children:"You can now play around with the code to see what mock results you get.\nAs opposed to writing an automation application without mocking capabilities,\nyou don't have to wait for real execution to see the effects of any changes. Go\nahead and make the following changes:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["Comment out StateTransitions, for example IslandTransitions by\ncommenting out the line in the IslandTransitions class that adds\nits StateTransitions to the repository:",(0,s.jsx)(t.br,{}),"\n","//stateTransitionsRepository.add(transitions);",(0,s.jsx)(t.br,{}),"\n","Run the code again to see the results. Notice how you get immediate feedback\nthat there is a mistake and know that you forgot to include a Transition.\nWithout mocking, you would have to wait until this transition occurs to get\nan error. Depending on the size and complexity of your application, this could\ntake a long time. With mocking it happens immediately, similar to normal\nintegration testing."]}),"\n",(0,s.jsx)(t.li,{children:"Change the name of one of the image files. See the errors produced in the mock."}),"\n",(0,s.jsx)(t.li,{children:'Add text to the GetText snapshot. Add text that you might expect to see,\nsuch as "Mnes" and "Frms". As expected, the demo will not recognize these\ninputs as being real island types. This is a way to use mocking to refine\nyour algorithm. While not technically an error, the application should\nprobably classify "Mnes" as Mines and "Frms" as Farms. Having these values\nin the snapshot allows you to refine and test your code efficiently, without\nhaving the long cycles characterized by real runs.'}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);
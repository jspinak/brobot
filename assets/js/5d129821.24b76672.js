"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3389],{28453:(n,i,e)=>{e.d(i,{R:()=>a,x:()=>s});var t=e(96540);const o={},l=t.createContext(o);function a(n){const i=t.useContext(l);return t.useMemo(function(){return"function"==typeof n?n(i):{...i,...n}},[i,n])}function s(n){let i;return i=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:a(n.components),t.createElement(l.Provider,{value:i},n.children)}},98870:(n,i,e)=>{e.r(i),e.d(i,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>r});const t=JSON.parse('{"id":"getting-started/action-hierarchy","title":"The Action Hierarchy","description":"Brobot interacts with the GUI using the Sikuli library. This is done with 3 main levels of abstraction:","source":"@site/docs/01-getting-started/action-hierarchy.md","sourceDirName":"01-getting-started","slug":"/getting-started/action-hierarchy","permalink":"/brobot/docs/getting-started/action-hierarchy","draft":false,"unlisted":false,"editUrl":"https://github.com/jspinak/brobot/edit/main/docs/docs/01-getting-started/action-hierarchy.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"title":"The Action Hierarchy"},"sidebar":"docSidebar","previous":{"title":"Transitions","permalink":"/brobot/docs/getting-started/transitions"},"next":{"title":"Installation","permalink":"/brobot/docs/getting-started/installation"}}');var o=e(74848),l=e(28453);const a={sidebar_position:5,title:"The Action Hierarchy"},s="Controlling the GUI",c={},r=[{value:"Sikuli Wrappers",id:"sikuli-wrappers",level:2},{value:"Basic Actions",id:"basic-actions",level:2},{value:"Complex Actions",id:"complex-actions",level:2},{value:"Example: Click Until Pattern Appears",id:"example-click-until-pattern-appears",level:3},{value:"Method 1: Traditional Loop Approach",id:"method-1-traditional-loop-approach",level:4},{value:"Method 2: Fluent API with Action Chaining",id:"method-2-fluent-api-with-action-chaining",level:4},{value:"Method 3: Using the Built-in ClickUntilOptions (Deprecated but Available)",id:"method-3-using-the-built-in-clickuntiloptions-deprecated-but-available",level:4},{value:"Method 4: Creating a Reusable Click-Until-Found Function",id:"method-4-creating-a-reusable-click-until-found-function",level:4},{value:"Choosing the Right Approach",id:"choosing-the-right-approach",level:3},{value:"Best Practices for Click Until Found",id:"best-practices-for-click-until-found",level:3},{value:"Enhanced Conditional Action Chaining",id:"enhanced-conditional-action-chaining",level:2},{value:"EnhancedConditionalActionChain Overview",id:"enhancedconditionalactionchain-overview",level:3},{value:"Basic Conditional Chaining",id:"basic-conditional-chaining",level:3},{value:"Advanced Conditional Patterns",id:"advanced-conditional-patterns",level:3},{value:"Pattern 1: Multi-Step Validation",id:"pattern-1-multi-step-validation",level:4},{value:"Pattern 2: Retry with Different Strategies",id:"pattern-2-retry-with-different-strategies",level:4},{value:"Pattern 3: Conditional Branching Based on Application State",id:"pattern-3-conditional-branching-based-on-application-state",level:4},{value:"Integration with ActionChainOptions",id:"integration-with-actionchainoptions",level:3},{value:"Comparison: ActionChainOptions vs ConditionalActionChain",id:"comparison-actionchainoptions-vs-conditionalactionchain",level:3},{value:"When to Use Each Approach",id:"when-to-use-each-approach",level:3},{value:"Best Practices for Conditional Chaining",id:"best-practices-for-conditional-chaining",level:3},{value:"Example: Complete Form Filling with Validation",id:"example-complete-form-filling-with-validation",level:3},{value:"Related Documentation",id:"related-documentation",level:3}];function d(n){const i={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(i.header,{children:(0,o.jsx)(i.h1,{id:"controlling-the-gui",children:"Controlling the GUI"})}),"\n",(0,o.jsx)(i.p,{children:"Brobot interacts with the GUI using the Sikuli library. This is done with 3 main levels of abstraction:"}),"\n",(0,o.jsx)(i.h2,{id:"sikuli-wrappers",children:"Sikuli Wrappers"}),"\n",(0,o.jsx)(i.p,{children:"These are the methods that form the interface between Brobot and Sikuli.\nSikuli Wrappers route the operational instructions either to Sikuli methods, which control the mouse and keyboard and capture data from the screen, or to functions that mock (simulate) these methods. When calling Sikuli methods, the Wrappers convert Brobot data types to Sikuli data types."}),"\n",(0,o.jsx)(i.h2,{id:"basic-actions",children:"Basic Actions"}),"\n",(0,o.jsx)(i.p,{children:"Basic Actions are the fundamental building blocks of GUI automation in Brobot. They perform simple, atomic operations that typically require at most one Find operation.\nExamples include:"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Find Actions"})," - Locate images, text, or patterns on screen"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Click Actions"})," - Single, double, or right clicks at specific locations"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Type Actions"})," - Keyboard input and key combinations"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Move Actions"})," - Mouse movements and hover operations"]}),"\n"]}),"\n",(0,o.jsxs)(i.p,{children:["Each Basic Action is implemented as a separate class that implements the ",(0,o.jsx)(i.code,{children:"ActionInterface"}),",\nproviding a clean, type-safe API through specific configuration classes like ",(0,o.jsx)(i.code,{children:"PatternFindOptions"}),",\n",(0,o.jsx)(i.code,{children:"ClickOptions"}),", and ",(0,o.jsx)(i.code,{children:"TypeOptions"}),"."]}),"\n",(0,o.jsx)(i.h2,{id:"complex-actions",children:"Complex Actions"}),"\n",(0,o.jsx)(i.p,{children:"Complex Actions (formerly called Composite Actions) combine Basic Actions to create more sophisticated operations. These are useful for:"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Multi-step Operations"})," - Actions requiring multiple Find operations"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Conditional Behaviors"})," - Click until something appears/disappears"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Drag Operations"})," - Click, hold, move, and release sequences"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Scrolling"})," - Repeated scroll actions until target is found"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Retry Logic"})," - Automatic retry with different strategies"]}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:"In Brobot 1.1.0, Complex Actions are built by:"}),"\n",(0,o.jsxs)(i.ol,{children:["\n",(0,o.jsx)(i.li,{children:"Chaining multiple Basic Actions together"}),"\n",(0,o.jsxs)(i.li,{children:["Using ",(0,o.jsx)(i.code,{children:"TaskSequence"})," for scripted sequences"]}),"\n",(0,o.jsx)(i.li,{children:"Creating custom action classes that orchestrate Basic Actions"}),"\n"]}),"\n",(0,o.jsx)(i.h3,{id:"example-click-until-pattern-appears",children:"Example: Click Until Pattern Appears"}),"\n",(0,o.jsx)(i.p,{children:"There are multiple ways to implement clickUntilFound in Brobot. Here are the most clean and efficient approaches:"}),"\n",(0,o.jsx)(i.h4,{id:"method-1-traditional-loop-approach",children:"Method 1: Traditional Loop Approach"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-java",children:"// Using individual actions with retry logic\npublic boolean clickUntilFound(StateImage clickTarget, StateImage findTarget, int maxAttempts) {\n    for (int i = 0; i < maxAttempts; i++) {\n        // Click on target with pause after action\n        ClickOptions click = new ClickOptions.Builder()\n                .setPauseAfterEnd(1.0)  // 1 second pause after click\n                .build();\n        action.perform(click, new ObjectCollection.Builder()\n                .withImages(clickTarget).build());\n        \n        // Check if pattern appeared\n        PatternFindOptions find = PatternFindOptions.forQuickSearch();\n        ActionResult result = action.perform(find, new ObjectCollection.Builder()\n                .withImages(findTarget).build());\n        \n        if (result.isSuccess()) {\n            return true;\n        }\n    }\n    return false;\n}\n"})}),"\n",(0,o.jsx)(i.h4,{id:"method-2-fluent-api-with-action-chaining",children:"Method 2: Fluent API with Action Chaining"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-java",children:'// Using the fluent API to chain click and find operations\npublic boolean clickUntilFoundFluent(StateImage clickTarget, StateImage findTarget) {\n    // Create a chain that clicks and then looks for the target\n    ClickOptions clickAndCheck = new ClickOptions.Builder()\n            .withBeforeActionLog("Clicking on " + clickTarget.getName() + "...")\n            .withSuccessLog("Click executed")\n            .setPauseAfterEnd(1.0)  // Wait after click\n            .then(new PatternFindOptions.Builder()\n                    .withBeforeActionLog("Checking if " + findTarget.getName() + " appeared...")\n                    .withSuccessLog(findTarget.getName() + " found!")\n                    .withFailureLog(findTarget.getName() + " not yet visible")\n                    .build())\n            .setRepetition(new RepetitionOptions.Builder()\n                    .setMaxTimesToRepeatActionSequence(10)  // Try up to 10 times\n                    .setPauseBetweenActionSequences(0.5)    // Brief pause between attempts\n                    .build())\n            .build();\n    \n    // Execute the chained action with both images\n    ObjectCollection targets = new ObjectCollection.Builder()\n            .withImages(clickTarget, findTarget)\n            .build();\n    \n    ActionResult result = action.perform(clickAndCheck, targets);\n    return result.isSuccess();\n}\n'})}),"\n",(0,o.jsx)(i.h4,{id:"method-3-using-the-built-in-clickuntiloptions-deprecated-but-available",children:"Method 3: Using the Built-in ClickUntilOptions (Deprecated but Available)"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-java",children:'// Using Brobot\'s built-in ClickUntil composite action\npublic boolean clickUntilFoundBuiltIn(StateImage clickTarget, StateImage findTarget) {\n    // Create ClickUntilOptions configured to click until objects appear\n    ClickUntilOptions clickUntil = new ClickUntilOptions.Builder()\n            .setCondition(ClickUntilOptions.Condition.OBJECTS_APPEAR)\n            .withBeforeActionLog("Clicking until " + findTarget.getName() + " appears...")\n            .withSuccessLog(findTarget.getName() + " appeared!")\n            .withFailureLog("Timeout - " + findTarget.getName() + " did not appear")\n            .setRepetition(new RepetitionOptions.Builder()\n                    .setMaxTimesToRepeatActionSequence(10)\n                    .setPauseBetweenActionSequences(1.0)\n                    .build())\n            .build();\n    \n    // Create ObjectCollections\n    // If using 1 collection: clicks objects until they appear\n    // If using 2 collections: clicks collection 1 until collection 2 appears\n    ObjectCollection clickCollection = new ObjectCollection.Builder()\n            .withImages(clickTarget)\n            .build();\n    ObjectCollection appearCollection = new ObjectCollection.Builder()\n            .withImages(findTarget)\n            .build();\n    \n    // Execute with two collections - click first until second appears\n    ActionResult result = action.perform(clickUntil, clickCollection, appearCollection);\n    return result.isSuccess();\n}\n'})}),"\n",(0,o.jsx)(i.h4,{id:"method-4-creating-a-reusable-click-until-found-function",children:"Method 4: Creating a Reusable Click-Until-Found Function"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-java",children:'// Creating a clean, reusable function that combines the best approaches\npublic boolean clickUntilFound(StateImage clickTarget, StateImage findTarget, \n                               int maxAttempts, double pauseBetween) {\n    // Use fluent chaining with automatic logging\n    PatternFindOptions clickAndCheck = new PatternFindOptions.Builder()\n            .withBeforeActionLog("Looking for click target...")\n            .withSuccessLog("Click target found")\n            .then(new ClickOptions.Builder()\n                    .withBeforeActionLog("Clicking...")\n                    .withSuccessLog("Clicked successfully")\n                    .setPauseAfterEnd(pauseBetween)\n                    .build())\n            .then(new PatternFindOptions.Builder()\n                    .withBeforeActionLog("Checking if target appeared...")\n                    .withSuccessLog("Target appeared!")\n                    .withFailureLog("Target not yet visible")\n                    .setSearchDuration(0.5) // Quick check\n                    .build())\n            .setRepetition(new RepetitionOptions.Builder()\n                    .setMaxTimesToRepeatActionSequence(maxAttempts)\n                    .setPauseBetweenActionSequences(0.5)\n                    .build())\n            .build();\n    \n    // Combine both images in one collection\n    ObjectCollection targets = new ObjectCollection.Builder()\n            .withImages(clickTarget, findTarget)\n            .build();\n    \n    // Execute and check the final result\n    ActionResult result = action.perform(clickAndCheck, targets);\n    \n    // The chain succeeds if the final find action succeeded\n    return result.isSuccess() && result.getLastActionResult().isSuccess();\n}\n\n// Usage example:\nboolean success = clickUntilFound(nextButton, finishButton, 10, 1.0);\n'})}),"\n",(0,o.jsx)(i.h3,{id:"choosing-the-right-approach",children:"Choosing the Right Approach"}),"\n",(0,o.jsxs)(i.table,{children:[(0,o.jsx)(i.thead,{children:(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.th,{children:"Method"}),(0,o.jsx)(i.th,{children:"When to Use"}),(0,o.jsx)(i.th,{children:"Pros"}),(0,o.jsx)(i.th,{children:"Cons"})]})}),(0,o.jsxs)(i.tbody,{children:[(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.td,{children:(0,o.jsx)(i.strong,{children:"Traditional Loop"})}),(0,o.jsx)(i.td,{children:"Simple cases, full control needed"}),(0,o.jsx)(i.td,{children:"Complete control over logic"}),(0,o.jsx)(i.td,{children:"More verbose, manual logging"})]}),(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.td,{children:(0,o.jsx)(i.strong,{children:"Fluent API Chaining"})}),(0,o.jsx)(i.td,{children:"Most common cases"}),(0,o.jsx)(i.td,{children:"Clean, automatic logging, easy to read"}),(0,o.jsx)(i.td,{children:"Requires understanding of chaining"})]}),(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.td,{children:(0,o.jsx)(i.strong,{children:"ClickUntilOptions"})}),(0,o.jsx)(i.td,{children:"Legacy code or specific composite needs"}),(0,o.jsx)(i.td,{children:"Built-in, handles edge cases"}),(0,o.jsx)(i.td,{children:"Deprecated, less flexible"})]}),(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.td,{children:(0,o.jsx)(i.strong,{children:"Reusable Function"})}),(0,o.jsx)(i.td,{children:"Multiple uses in codebase"}),(0,o.jsx)(i.td,{children:"DRY principle, consistent behavior"}),(0,o.jsx)(i.td,{children:"May need customization for edge cases"})]})]})]}),"\n",(0,o.jsx)(i.h3,{id:"best-practices-for-click-until-found",children:"Best Practices for Click Until Found"}),"\n",(0,o.jsxs)(i.ol,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Use Logging"}),": The fluent API approach (Method 2) provides the best logging and debugging experience"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Set Reasonable Timeouts"}),": Always limit the number of attempts to prevent infinite loops"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Add Pauses"}),": Include pauses between clicks to allow the UI to respond"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Consider State Management"}),": In a state-based automation framework, clickUntilFound might trigger a state transition"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"ObjectCollection Usage"}),": Remember that all actions in a chain share the same ObjectCollection"]}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:"This modular approach makes it easy to create custom complex behaviors while maintaining the benefits of type safety and clear intent provided by the ActionConfig architecture."}),"\n",(0,o.jsx)(i.h2,{id:"enhanced-conditional-action-chaining",children:"Enhanced Conditional Action Chaining"}),"\n",(0,o.jsxs)(i.p,{children:["Brobot 1.1.0+ introduces the powerful ",(0,o.jsx)(i.code,{children:"EnhancedConditionalActionChain"})," class for building sophisticated conditional execution flows. This provides a fluent API for creating complex action sequences with conditional branching, error handling, and retry logic."]}),"\n",(0,o.jsxs)(i.blockquote,{children:["\n",(0,o.jsxs)(i.p,{children:[(0,o.jsx)(i.strong,{children:"Note:"})," The original ",(0,o.jsx)(i.code,{children:"ConditionalActionChain"})," class is now deprecated. Use ",(0,o.jsx)(i.code,{children:"EnhancedConditionalActionChain"})," for all new development."]}),"\n"]}),"\n",(0,o.jsx)(i.h3,{id:"enhancedconditionalactionchain-overview",children:"EnhancedConditionalActionChain Overview"}),"\n",(0,o.jsxs)(i.p,{children:["The ",(0,o.jsx)(i.code,{children:"EnhancedConditionalActionChain"})," class allows you to:"]}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Chain actions with conditional execution based on previous results"}),"\n",(0,o.jsx)(i.li,{children:"Add fallback actions when primary actions fail"}),"\n",(0,o.jsx)(i.li,{children:"Implement retry logic with different strategies"}),"\n",(0,o.jsx)(i.li,{children:"Create branching workflows based on runtime conditions"}),"\n",(0,o.jsx)(i.li,{children:"Handle errors gracefully with recovery actions"}),"\n"]}),"\n",(0,o.jsx)(i.h3,{id:"basic-conditional-chaining",children:"Basic Conditional Chaining"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-java",children:'import io.github.jspinak.brobot.action.EnhancedConditionalActionChain;\nimport io.github.jspinak.brobot.action.basic.find.PatternFindOptions;\nimport io.github.jspinak.brobot.action.basic.click.ClickOptions;\nimport io.github.jspinak.brobot.action.basic.type.TypeOptions;\nimport io.github.jspinak.brobot.action.basic.find.color.ColorFindOptions;\nimport io.github.jspinak.brobot.action.RepetitionOptions;\nimport io.github.jspinak.brobot.action.ActionChainOptions;\n\n// Simple conditional chain: if login button found, click it and enter credentials\nEnhancedConditionalActionChain loginChain = EnhancedConditionalActionChain\n    .find(new PatternFindOptions.Builder().build())\n    .ifFoundClick()\n    .ifFoundDo(result -> {\n        action.type(usernameField, username);\n        action.type(passwordField, password);\n        action.click(submitButton);\n    })\n    .ifNotFoundLog("Login button not found - may already be logged in");\n\nActionResult result = loginChain.perform(action, \n    new ObjectCollection.Builder()\n        .withImages(loginButton)\n        .build());\n'})}),"\n",(0,o.jsx)(i.h3,{id:"advanced-conditional-patterns",children:"Advanced Conditional Patterns"}),"\n",(0,o.jsx)(i.h4,{id:"pattern-1-multi-step-validation",children:"Pattern 1: Multi-Step Validation"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-java",children:'// Validate each step and proceed only if successful\nEnhancedConditionalActionChain wizardChain = EnhancedConditionalActionChain\n    .find(new PatternFindOptions.Builder().build())\n    .ifFoundClick()  // Click step 1\n    .then(new PatternFindOptions.Builder().build())  // Find step 2\n    .ifFoundClick()  // Click step 2\n    .then(new PatternFindOptions.Builder().build())  // Find step 3\n    .ifFoundClick()  // Click step 3\n    .then(new PatternFindOptions.Builder()  // Find completion\n        .setSearchDuration(5.0)  // Wait up to 5 seconds\n        .build())\n    .ifFoundLog("Wizard completed successfully")\n    .ifNotFoundLog("Wizard failed to complete");\n\n// Execute with all step buttons\nObjectCollection steps = new ObjectCollection.Builder()\n    .withImages(step1Button, step2Button, step3Button, completionMessage)\n    .build();\n    \nActionResult result = wizardChain.perform(action, steps);\n'})}),"\n",(0,o.jsx)(i.h4,{id:"pattern-2-retry-with-different-strategies",children:"Pattern 2: Retry with Different Strategies"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-java",children:'// Try different approaches to close a dialog\n// Method 1: Try X button first\nConditionalActionChain closeWithX = ConditionalActionChain\n    .find(new PatternFindOptions.Builder().build())  // Find close button\n    .ifFoundClick()\n    .ifFoundLog("Closed dialog with X button");\n\n// Method 2: Try Escape key if X button fails\nConditionalActionChain closeWithEsc = ConditionalActionChain\n    .start(new TypeOptions.Builder()\n        .setText("\\u001B")  // ESC key\n        .build())\n    .always(new PatternFindOptions.Builder()  // Check if dialog gone\n        .setSearchDuration(1.0)\n        .build())\n    .ifNotFoundLog("Dialog closed with ESC key");\n\n// Method 3: Click outside dialog\nConditionalActionChain closeWithClick = ConditionalActionChain\n    .start(new ClickOptions.Builder()\n        .setClickLocation(ClickOptions.ClickLocation.OUTSIDE_MATCH)\n        .build())\n    .then(new PatternFindOptions.Builder()  // Verify dialog closed\n        .setSearchDuration(1.0)\n        .build())\n    .ifNotFoundLog("Dialog closed by clicking outside");\n\n// Use RepetitionOptions for retry logic\nPatternFindOptions findDialog = new PatternFindOptions.Builder()\n    .setRepetition(new RepetitionOptions.Builder()\n        .setMaxTimesToRepeatActionSequence(3)\n        .setPauseBetweenActionSequences(0.5)\n        .build())\n    .build();\n'})}),"\n",(0,o.jsx)(i.h4,{id:"pattern-3-conditional-branching-based-on-application-state",children:"Pattern 3: Conditional Branching Based on Application State"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-java",children:'// Different actions based on what\'s visible on screen\n// Since ConditionalActionChain doesn\'t have elseWhen, use separate chains\n\n// Chain for home screen\nConditionalActionChain fromHome = ConditionalActionChain\n    .find(new PatternFindOptions.Builder().build())  // Find home screen\n    .ifFoundClick()  // Click menu button\n    .then(new PatternFindOptions.Builder().build())  // Find menu panel\n    .ifFoundLog("Opened menu from home screen");\n\n// Chain for settings screen  \nConditionalActionChain fromSettings = ConditionalActionChain\n    .find(new PatternFindOptions.Builder().build())  // Find settings screen\n    .ifFoundClick()  // Click back button\n    .then(new PatternFindOptions.Builder().build())  // Find home screen\n    .ifFoundLog("Returned to home from settings");\n\n// Chain for error dialog\nConditionalActionChain fromError = ConditionalActionChain\n    .find(new PatternFindOptions.Builder().build())  // Find error dialog\n    .ifFoundClick()  // Click dismiss\n    .alwaysClick()  // Click home button\n    .then(new PatternFindOptions.Builder().build())  // Verify home screen\n    .ifFoundLog("Recovered from error state");\n\n// Execute appropriate chain based on current state\nActionResult result;\nif (action.find(homeScreen).isSuccess()) {\n    result = fromHome.perform(action, new ObjectCollection.Builder()\n        .withImages(homeScreen, menuButton, menuPanel).build());\n} else if (action.find(settingsScreen).isSuccess()) {\n    result = fromSettings.perform(action, new ObjectCollection.Builder()\n        .withImages(settingsScreen, backButton, homeScreen).build());\n} else if (action.find(errorDialog).isSuccess()) {\n    result = fromError.perform(action, new ObjectCollection.Builder()\n        .withImages(errorDialog, dismissButton, homeButton, homeScreen).build());\n} else {\n    log.warn("Unknown state - attempting recovery");\n    action.type(new ObjectCollection.Builder().withStrings("\\u001B\\u001B").build());\n}\n'})}),"\n",(0,o.jsx)(i.h3,{id:"integration-with-actionchainoptions",children:"Integration with ActionChainOptions"}),"\n",(0,o.jsxs)(i.p,{children:["Conditional chains can be combined with ",(0,o.jsx)(i.code,{children:"ActionChainOptions"})," for even more sophisticated behaviors:"]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-java",children:"// Combine ActionChainOptions with ConditionalActionChain\n// First, use ActionChainOptions for nested/confirmed finds\nActionChainOptions nestedFind = new ActionChainOptions.Builder(\n        new PatternFindOptions.Builder()\n            .setStrategy(PatternFindOptions.Strategy.BEST)\n            .setSimilarity(0.9)\n            .build())\n    .setStrategy(ActionChainOptions.ChainingStrategy.NESTED)\n    .then(new ColorFindOptions.Builder()\n        .setColorStrategy(ColorFindOptions.Color.MU)\n        .setSimilarity(0.85)\n        .build())\n    .build();\n\n// Then use ConditionalActionChain for conditional logic\nConditionalActionChain robustClick = ConditionalActionChain\n    .start(nestedFind)  // Start with the chained find\n    .ifFoundClick()  // Click if found\n    .ifNotFoundDo(result -> {\n        // Fallback: try with lower similarity\n        PatternFindOptions relaxedFind = new PatternFindOptions.Builder()\n            .setStrategy(PatternFindOptions.Strategy.BEST)\n            .setSimilarity(0.7)\n            .build();\n        \n        ActionResult fallbackResult = action.perform(relaxedFind, targetImage);\n        if (fallbackResult.isSuccess()) {\n            action.click(targetImage);\n        }\n    });\n\n// For retry logic, use RepetitionOptions\nPatternFindOptions withRetry = new PatternFindOptions.Builder()\n    .setStrategy(PatternFindOptions.Strategy.BEST)\n    .setRepetition(new RepetitionOptions.Builder()\n        .setMaxTimesToRepeatActionSequence(2)\n        .setPauseBetweenActionSequences(1.0)\n        .build())\n    .build();\n"})}),"\n",(0,o.jsx)(i.h3,{id:"comparison-actionchainoptions-vs-conditionalactionchain",children:"Comparison: ActionChainOptions vs ConditionalActionChain"}),"\n",(0,o.jsxs)(i.table,{children:[(0,o.jsx)(i.thead,{children:(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.th,{children:"Feature"}),(0,o.jsx)(i.th,{children:"ActionChainOptions"}),(0,o.jsx)(i.th,{children:"ConditionalActionChain"})]})}),(0,o.jsxs)(i.tbody,{children:[(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.td,{children:(0,o.jsx)(i.strong,{children:"Purpose"})}),(0,o.jsx)(i.td,{children:"Chain actions with NESTED/CONFIRM strategies"}),(0,o.jsx)(i.td,{children:"Complex conditional workflows"})]}),(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.td,{children:(0,o.jsx)(i.strong,{children:"Conditional Logic"})}),(0,o.jsx)(i.td,{children:"Limited (success/failure)"}),(0,o.jsx)(i.td,{children:"Full boolean conditions"})]}),(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.td,{children:(0,o.jsx)(i.strong,{children:"Branching"})}),(0,o.jsx)(i.td,{children:"No"}),(0,o.jsx)(i.td,{children:"Yes (if/else/elseWhen)"})]}),(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.td,{children:(0,o.jsx)(i.strong,{children:"Custom Logic"})}),(0,o.jsx)(i.td,{children:"No"}),(0,o.jsx)(i.td,{children:"Yes (lambda expressions)"})]}),(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.td,{children:(0,o.jsx)(i.strong,{children:"Retry Handling"})}),(0,o.jsx)(i.td,{children:"Via RepetitionOptions"}),(0,o.jsx)(i.td,{children:"Built-in retry with delays"})]}),(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.td,{children:(0,o.jsx)(i.strong,{children:"Use Case"})}),(0,o.jsx)(i.td,{children:"Pattern/color combining"}),(0,o.jsx)(i.td,{children:"Complex decision trees"})]})]})]}),"\n",(0,o.jsx)(i.h3,{id:"when-to-use-each-approach",children:"When to Use Each Approach"}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.strong,{children:"Use ActionChainOptions when:"})}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Combining find operations (nested or confirmed)"}),"\n",(0,o.jsx)(i.li,{children:"Performing sequential actions on the same objects"}),"\n",(0,o.jsx)(i.li,{children:"Need automatic history recording"}),"\n",(0,o.jsx)(i.li,{children:"Working with pattern and color matching"}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.strong,{children:"Use ConditionalActionChain when:"})}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Need complex conditional logic"}),"\n",(0,o.jsx)(i.li,{children:"Implementing recovery strategies"}),"\n",(0,o.jsx)(i.li,{children:"Creating branching workflows"}),"\n",(0,o.jsx)(i.li,{children:"Need custom validation between steps"}),"\n",(0,o.jsx)(i.li,{children:"Building robust error handling"}),"\n"]}),"\n",(0,o.jsx)(i.h3,{id:"best-practices-for-conditional-chaining",children:"Best Practices for Conditional Chaining"}),"\n",(0,o.jsxs)(i.ol,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Keep Chains Focused"}),": Each chain should have a single, clear purpose"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Use Meaningful Names"}),": Name your chains based on what they accomplish"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Add Logging"}),": Include log statements in your conditions and actions"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Set Reasonable Timeouts"}),": Prevent chains from running indefinitely"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Test Edge Cases"}),": Ensure your fallback actions handle all scenarios"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Document Complex Logic"}),": Add comments explaining the flow"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Consider State Management"}),": Chains may trigger state transitions"]}),"\n"]}),"\n",(0,o.jsx)(i.h3,{id:"example-complete-form-filling-with-validation",children:"Example: Complete Form Filling with Validation"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-java",children:'public class FormAutomation {\n    \n    @Autowired\n    private Action action;\n    \n    public boolean fillComplexForm(FormData data) {\n        // Check if form is open\n        ConditionalActionChain openForm = ConditionalActionChain\n            .find(new PatternFindOptions.Builder().build())\n            .ifNotFoundLog("Form not found")\n            .ifNotFoundDo(result -> log.error("Cannot proceed - form not visible"));\n        \n        ActionResult formResult = openForm.perform(action, \n            new ObjectCollection.Builder().withImages(formTitle).build());\n        \n        if (!formResult.isSuccess()) {\n            return false;\n        }\n        \n        // Fill required fields\n        boolean requiredFilled = fillRequiredFields(data);\n        if (!requiredFilled) {\n            log.error("Failed to fill required fields");\n            return false;\n        }\n        \n        // Conditionally fill optional fields\n        if (data.hasOptionalData()) {\n            fillOptionalFields(data);\n        }\n        \n        // Validate before submission\n        ConditionalActionChain validateChain = ConditionalActionChain\n            .start(new ClickOptions.Builder().build())  // Click validate\n            .then(new PatternFindOptions.Builder()\n                .setSearchDuration(2.0)  // Wait for validation\n                .build())\n            .ifFoundDo(result -> {\n                // If error message found, handle it\n                String errorText = action.text(errorMessage).getText();\n                log.error("Validation error: {}", errorText);\n                fixValidationError(errorText);\n            })\n            .ifNotFoundLog("Validation passed");\n        \n        ActionResult validateResult = validateChain.perform(action,\n            new ObjectCollection.Builder()\n                .withImages(validateButton, errorMessage)\n                .build());\n        \n        // Submit if valid\n        if (!action.find(errorMessage).isSuccess()) {\n            ConditionalActionChain submitChain = ConditionalActionChain\n                .start(new ClickOptions.Builder().build())\n                .then(new PatternFindOptions.Builder()\n                    .setSearchDuration(5.0)\n                    .build())\n                .ifFoundLog("Form submitted successfully");\n            \n            ActionResult submitResult = submitChain.perform(action,\n                new ObjectCollection.Builder()\n                    .withImages(submitButton, successMessage)\n                    .build());\n            \n            return submitResult.isSuccess();\n        }\n        \n        // Cancel if errors persist\n        action.click(cancelButton);\n        return false;\n    }\n}\n'})}),"\n",(0,o.jsx)(i.h3,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:(0,o.jsx)(i.a,{href:"/docs/01-getting-started/ai-brobot-project-creation#conditional-action-chains",children:"Conditional Action Chaining Guide"})})," - Comprehensive guide with more examples"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:(0,o.jsx)(i.a,{href:"/brobot/docs/core-library/guides/action-config-factory",children:"Action Config Factory"})})," - Creating and managing action configurations"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:(0,o.jsx)(i.a,{href:"/brobot/docs/core-library/guides/finding-objects/combining-finds",children:"Combining Finds"})})," - Pattern and color combination strategies"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:(0,o.jsx)(i.a,{href:"https://github.com/jspinak/brobot/tree/main/examples/03-core-library/action-config/conditional-chains-examples",children:"ConditionalActionChain Example"})})," - Complete implementation examples"]}),"\n"]})]})}function h(n={}){const{wrapper:i}={...(0,l.R)(),...n.components};return i?(0,o.jsx)(i,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}}}]);
"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8365],{28453:(n,e,t)=>{t.d(e,{R:()=>s,x:()=>a});var i=t(96540);const r={},o=i.createContext(r);function s(n){const e=i.useContext(o);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:s(n.components),i.createElement(o.Provider,{value:e},n.children)}},43607:(n,e,t)=>{t.d(e,{A:()=>i});const i=t.p+"assets/images/transitions-c388f3c755a4df88c4c15f76e021e687.png"},91768:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"getting-started/transitions","title":"Transitions","description":"Introduction","source":"@site/docs/01-getting-started/transitions.md","sourceDirName":"01-getting-started","slug":"/getting-started/transitions","permalink":"/brobot/docs/getting-started/transitions","draft":false,"unlisted":false,"editUrl":"https://github.com/jspinak/brobot/edit/main/docs/docs/01-getting-started/transitions.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Transitions"},"sidebar":"docSidebar","previous":{"title":"States","permalink":"/brobot/docs/getting-started/states"},"next":{"title":"The Action Hierarchy","permalink":"/brobot/docs/getting-started/action-hierarchy"}}');var r=t(74848),o=t(28453);const s={sidebar_position:4,title:"Transitions"},a="Transitions",l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"The Brobot Implementation: FromTransition and ToTransition",id:"the-brobot-implementation-fromtransition-and-totransition",level:2},{value:"Modern Approach: Using @TransitionSet Annotation",id:"modern-approach-using-transitionset-annotation",level:2},{value:"Complete Example",id:"complete-example",level:3},{value:"Annotation Types",id:"annotation-types",level:3},{value:"@TransitionSet",id:"transitionset",level:4},{value:"@FromTransition",id:"fromtransition",level:4},{value:"@ToTransition",id:"totransition",level:4},{value:"World State Example",id:"world-state-example",level:2},{value:"Key Benefits of @TransitionSet",id:"key-benefits-of-transitionset",level:2},{value:"File Organization",id:"file-organization",level:2},{value:"Complex Transitions with Action Chains",id:"complex-transitions-with-action-chains",level:2},{value:"The Formal Model (Under the Hood)",id:"the-formal-model-under-the-hood",level:2},{value:"Dynamic Transitions for Hidden States",id:"dynamic-transitions-for-hidden-states",level:2},{value:"Testing Transitions",id:"testing-transitions",level:2},{value:"Migration from Legacy Format",id:"migration-from-legacy-format",level:2},{value:"Old Format (Pre-1.2.0)",id:"old-format-pre-120",level:3},{value:"New Format (1.2.0+)",id:"new-format-120",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Summary",id:"summary",level:2}];function d(n){const e={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"transitions",children:"Transitions"})}),"\n",(0,r.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsxs)(e.p,{children:['While States define "where you can be" in a GUI, ',(0,r.jsx)(e.strong,{children:"Transitions"}),' define "how you get there." Every State that is reachable needs an associated transitions class that defines the pathways to and from other states.']}),"\n",(0,r.jsx)(e.p,{children:'Formally, a transition is a process or a sequence of actions that changes the GUI from one state to another. They form the "edges" of the state graph and are the building blocks used by the framework\'s pathfinder to navigate the application.'}),"\n",(0,r.jsx)(e.h2,{id:"the-brobot-implementation-fromtransition-and-totransition",children:"The Brobot Implementation: FromTransition and ToTransition"}),"\n",(0,r.jsxs)(e.p,{children:["Brobot implements this concept by splitting transitions into two types: ",(0,r.jsx)(e.strong,{children:"FromTransitions"})," and ",(0,r.jsx)(e.strong,{children:"ToTransitions"}),". This two-part system provides a clear and reusable structure for managing navigation logic."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.img,{alt:"Transition Diagram",src:t(43607).A+"",width:"623",height:"196"}),"\n",(0,r.jsx)(e.em,{children:"This diagram is based on Figure 8 from the research paper."})]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"FromTransition"}),": This handles the process of leaving another state to arrive at ",(0,r.jsx)(e.em,{children:"this"})," state. For example, to go from ",(0,r.jsx)(e.code,{children:"State A"})," to ",(0,r.jsx)(e.code,{children:"State B"}),", the FromTransition in ",(0,r.jsx)(e.code,{children:"BTransitions"})," defines how to navigate from A. It contains the specific actions needed to trigger the move from State A."]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"ToTransition"}),": This handles the verification of arriving at a state, regardless of which state started the process. There can be multiple FromTransitions coming to ",(0,r.jsx)(e.code,{children:"State B"})," from different states, but there is only one ToTransition for ",(0,r.jsx)(e.code,{children:"State B"}),". This verification contains checks to confirm ",(0,r.jsx)(e.code,{children:"State B"})," is active."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"modern-approach-using-transitionset-annotation",children:"Modern Approach: Using @TransitionSet Annotation"}),"\n",(0,r.jsx)(e.p,{children:"Brobot 1.2.0+ uses a cohesive, method-level annotation approach that groups all transitions for a state in one class. This maintains high cohesion while providing clear, annotation-based configuration."}),"\n",(0,r.jsx)(e.h3,{id:"complete-example",children:"Complete Example"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'@TransitionSet(state = PricingState.class, description = "Pricing page transitions")\n@Component\n@RequiredArgsConstructor\n@Slf4j\npublic class PricingTransitions {\n    \n    private final MenuState menuState;\n    private final HomepageState homepageState;\n    private final PricingState pricingState;\n    private final Action action;\n    \n    /**\n     * Navigate from Menu to Pricing by clicking the pricing menu item.\n     */\n    @FromTransition(from = MenuState.class, priority = 1, description = "Navigate from Menu to Pricing")\n    public boolean fromMenu() {\n        log.info("Navigating from Menu to Pricing");\n        // In mock mode, just return true for testing\n        if (io.github.jspinak.brobot.config.core.FrameworkSettings.mock) {\n            log.info("Mock mode: simulating successful navigation");\n            return true;\n        }\n        return action.click(menuState.getPricingButton()).isSuccess();\n    }\n    \n    /**\n     * Navigate from Homepage to Pricing.\n     */\n    @FromTransition(from = HomepageState.class, priority = 2, description = "Navigate from Homepage to Pricing")\n    public boolean fromHomepage() {\n        log.info("Navigating from Homepage to Pricing");\n        // In mock mode, just return true for testing\n        if (io.github.jspinak.brobot.config.core.FrameworkSettings.mock) {\n            log.info("Mock mode: simulating successful navigation");\n            return true;\n        }\n        return action.click(homepageState.getPricingLink()).isSuccess();\n    }\n    \n    /**\n     * Verify that we have successfully arrived at the Pricing state.\n     * Checks for the presence of pricing-specific elements.\n     */\n    @ToTransition(description = "Verify arrival at Pricing state", required = true)\n    public boolean verifyArrival() {\n        log.info("Verifying arrival at Pricing state");\n        // In mock mode, just return true for testing\n        if (io.github.jspinak.brobot.config.core.FrameworkSettings.mock) {\n            log.info("Mock mode: simulating successful verification");\n            return true;\n        }\n        \n        boolean found = action.find(pricingState.getStartForFreeButton()).isSuccess();\n        \n        if (found) {\n            log.info("Successfully confirmed Pricing state is active");\n            return true;\n        } else {\n            log.error("Failed to confirm Pricing state - button not found");\n            return false;\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"annotation-types",children:"Annotation Types"}),"\n",(0,r.jsx)(e.h4,{id:"transitionset",children:"@TransitionSet"}),"\n",(0,r.jsx)(e.p,{children:"Marks a class as containing all transitions for a specific state:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"state"}),": The state class these transitions belong to (required)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"name"}),': Optional state name override (defaults to class name without "State" suffix)']}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"description"}),": Documentation for the transition set"]}),"\n"]}),"\n",(0,r.jsx)(e.h4,{id:"fromtransition",children:"@FromTransition"}),"\n",(0,r.jsx)(e.p,{children:"Defines a transition FROM another state TO this state:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"from"}),": The source state class (required)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"priority"}),": Transition priority - higher values are preferred when multiple paths exist (default: 0)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"description"}),": Documentation for this transition"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"timeout"}),": Timeout in seconds (optional)"]}),"\n"]}),"\n",(0,r.jsx)(e.h4,{id:"totransition",children:"@ToTransition"}),"\n",(0,r.jsx)(e.p,{children:"Verifies successful arrival at the state:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"description"}),": Documentation for the verification"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"timeout"}),": Verification timeout in seconds (optional)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"required"}),": Whether verification must succeed (default: false)"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"world-state-example",children:"World State Example"}),"\n",(0,r.jsx)(e.p,{children:"Here's another complete example showing transitions for a World state with multiple entry and exit points:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'@TransitionSet(state = WorldState.class, description = "World map transitions")\n@Component\n@RequiredArgsConstructor\n@Slf4j\npublic class WorldTransitions {\n    \n    private final HomeState homeState;\n    private final WorldState worldState;\n    private final IslandState islandState;\n    private final Action action;\n    \n    /**\n     * Navigate from Home to World by clicking the world button.\n     */\n    @FromTransition(from = HomeState.class, priority = 1, description = "Navigate from Home to World")\n    public boolean fromHome() {\n        log.info("Navigating from Home to World");\n        if (io.github.jspinak.brobot.config.core.FrameworkSettings.mock) {\n            log.info("Mock mode: simulating successful navigation");\n            return true;\n        }\n        return action.click(homeState.getToWorldButton()).isSuccess();\n    }\n    \n    /**\n     * Navigate from Island back to World.\n     */\n    @FromTransition(from = IslandState.class, priority = 2, description = "Return from Island to World")\n    public boolean fromIsland() {\n        log.info("Navigating from Island to World");\n        if (io.github.jspinak.brobot.config.core.FrameworkSettings.mock) {\n            log.info("Mock mode: simulating successful navigation");\n            return true;\n        }\n        // Click back button or world map icon\n        return action.click(islandState.getBackToWorldButton()).isSuccess();\n    }\n    \n    /**\n     * Verify arrival at World state by checking for the world map.\n     */\n    @ToTransition(description = "Verify arrival at World state", required = true)\n    public boolean verifyArrival() {\n        log.info("Verifying arrival at World state");\n        if (io.github.jspinak.brobot.config.core.FrameworkSettings.mock) {\n            log.info("Mock mode: simulating successful verification");\n            return true;\n        }\n        \n        // Check for world-specific elements\n        boolean foundMap = action.find(worldState.getWorldMap()).isSuccess();\n        boolean foundIslands = action.find(worldState.getIsland1()).isSuccess();\n        \n        if (foundMap || foundIslands) {\n            log.info("Successfully confirmed World state is active");\n            return true;\n        } else {\n            log.error("Failed to confirm World state - world elements not found");\n            return false;\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"key-benefits-of-transitionset",children:"Key Benefits of @TransitionSet"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"High Cohesion"}),": All transitions for a state in ONE class - easy to find and maintain"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Clear Separation"}),": FromTransitions handle navigation logic, ToTransition verifies arrival"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Natural Organization"}),": File structure mirrors state structure (one transitions class per state)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Spring Integration"}),": Full dependency injection support with @Component"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Type Safety"}),": Class-based state references prevent typos and enable IDE refactoring"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Mock Mode Support"}),": Easy to add testing support with framework settings check"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Reduced Boilerplate"}),": Method-level annotations are more concise than builders"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"file-organization",children:"File Organization"}),"\n",(0,r.jsx)(e.p,{children:"Organize transition classes alongside state classes for clarity:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"src/main/java/com/example/app/\n\u251c\u2500\u2500 states/\n\u2502   \u251c\u2500\u2500 HomeState.java\n\u2502   \u251c\u2500\u2500 WorldState.java\n\u2502   \u251c\u2500\u2500 IslandState.java\n\u2502   \u2514\u2500\u2500 PricingState.java\n\u2514\u2500\u2500 transitions/\n    \u251c\u2500\u2500 HomeTransitions.java     # All transitions for Home state\n    \u251c\u2500\u2500 WorldTransitions.java    # All transitions for World state\n    \u251c\u2500\u2500 IslandTransitions.java   # All transitions for Island state\n    \u2514\u2500\u2500 PricingTransitions.java  # All transitions for Pricing state\n"})}),"\n",(0,r.jsx)(e.h2,{id:"complex-transitions-with-action-chains",children:"Complex Transitions with Action Chains"}),"\n",(0,r.jsx)(e.p,{children:"For transitions that require multiple steps, you can chain actions together:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'@TransitionSet(state = WorkingState.class, description = "Claude Working state transitions")\n@Component\n@RequiredArgsConstructor\n@Slf4j\npublic class WorkingTransitions {\n    \n    private final PromptState promptState;\n    private final WorkingState workingState;\n    private final Action action;\n    \n    /**\n     * Navigate from Prompt to Working by submitting a command.\n     */\n    @FromTransition(from = PromptState.class, priority = 1)\n    public boolean fromPrompt() {\n        try {\n            log.info("Navigating from Prompt to Working");\n            \n            if (io.github.jspinak.brobot.config.core.FrameworkSettings.mock) {\n                return true;\n            }\n\n            // Chain multiple actions: find -> click -> type\n            PatternFindOptions findClickType =\n                    new PatternFindOptions.Builder()\n                            .setPauseAfterEnd(0.5) // Pause before clicking\n                            .then(new ClickOptions.Builder()\n                                    .setPauseAfterEnd(0.5) // Pause before typing\n                                    .build())\n                            .then(new TypeOptions.Builder().build())\n                            .build();\n\n            // Create target objects for the chained action\n            ObjectCollection target =\n                    new ObjectCollection.Builder()\n                            .withImages(promptState.getClaudePrompt()) // For find & click\n                            .withStrings(promptState.getContinueCommand()) // For type\n                            .build();\n\n            // Execute the chained action\n            ActionResult result = action.perform(findClickType, target);\n            return result.isSuccess();\n            \n        } catch (Exception e) {\n            log.error("Error during Prompt to Working transition", e);\n            return false;\n        }\n    }\n    \n    @ToTransition(required = true)\n    public boolean verifyArrival() {\n        log.info("Verifying arrival at Working state");\n        if (io.github.jspinak.brobot.config.core.FrameworkSettings.mock) {\n            return true;\n        }\n        return action.find(workingState.getWorkingIndicator()).isSuccess();\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"the-formal-model-under-the-hood",children:"The Formal Model (Under the Hood)"}),"\n",(0,r.jsxs)(e.p,{children:["The academic paper provides a formal definition for a transition as a tuple ",(0,r.jsxs)(e.strong,{children:["t = (A, S",(0,r.jsx)("sub",{children:"t"}),(0,r.jsx)("sup",{children:"def"}),")"]}),"."]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"A"})," is a ",(0,r.jsx)(e.strong,{children:"process"}),", which is a sequence of one or more actions ",(0,r.jsx)(e.code,{children:"(a\xb9, a\xb2, ..., a\u207f)"}),". This corresponds to the method body in your @FromTransition methods."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsxs)(e.strong,{children:["S",(0,r.jsx)("sub",{children:"t"}),(0,r.jsx)("sup",{children:"def"})]})," is the ",(0,r.jsx)(e.strong,{children:"intended state information"}),". This is handled automatically by the framework based on the @TransitionSet's state parameter and the @FromTransition's from parameter."]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"dynamic-transitions-for-hidden-states",children:"Dynamic Transitions for Hidden States"}),"\n",(0,r.jsx)(e.p,{children:'Brobot supports dynamic transitions to handle common UI patterns like menus and pop-ups. When a state opens and covers another, the covered state is registered as "hidden."'}),"\n",(0,r.jsx)(e.p,{children:"You can define transitions that return to the previous state dynamically:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'@TransitionSet(state = MenuState.class, description = "Menu overlay transitions")\n@Component\n@RequiredArgsConstructor\n@Slf4j\npublic class MenuTransitions {\n    \n    private final MenuState menuState;\n    private final Action action;\n    \n    /**\n     * Close menu and return to whatever state was underneath.\n     * This uses the PREVIOUS special state for dynamic navigation.\n     */\n    @FromTransition(\n        from = io.github.jspinak.brobot.model.state.special.SpecialStateType.PREVIOUS.class,\n        priority = 1,\n        description = "Close menu and return to previous state"\n    )\n    public boolean fromPrevious() {\n        log.info("Closing menu to return to previous state");\n        if (io.github.jspinak.brobot.config.core.FrameworkSettings.mock) {\n            return true;\n        }\n        // Click close button or press ESC\n        return action.click(menuState.getCloseButton()).isSuccess() ||\n               action.type("\\u001B").isSuccess(); // ESC key\n    }\n    \n    @ToTransition\n    public boolean verifyArrival() {\n        log.info("Verifying arrival at Menu state");\n        if (io.github.jspinak.brobot.config.core.FrameworkSettings.mock) {\n            return true;\n        }\n        return action.find(menuState.getMenuHeader()).isSuccess();\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"testing-transitions",children:"Testing Transitions"}),"\n",(0,r.jsx)(e.p,{children:"The new format makes testing easier and more straightforward:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"@ExtendWith(SpringExtension.class)\n@ContextConfiguration(classes = {TestConfiguration.class})\npublic class PricingTransitionsTest {\n    \n    @Autowired\n    private PricingTransitions pricingTransitions;\n    \n    @MockBean\n    private Action action;\n    \n    @Test\n    public void testFromMenuTransition() {\n        // Given\n        when(action.click(any())).thenReturn(new ActionResult.Builder().setSuccess(true).build());\n        \n        // When\n        boolean result = pricingTransitions.fromMenu();\n        \n        // Then\n        assertTrue(result);\n        verify(action).click(menuState.getPricingButton());\n    }\n    \n    @Test\n    public void testVerifyArrival() {\n        // Given\n        when(action.find(any())).thenReturn(new ActionResult.Builder().setSuccess(true).build());\n        \n        // When\n        boolean arrived = pricingTransitions.verifyArrival();\n        \n        // Then\n        assertTrue(arrived);\n        verify(action).find(pricingState.getStartForFreeButton());\n    }\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"migration-from-legacy-format",children:"Migration from Legacy Format"}),"\n",(0,r.jsx)(e.p,{children:"If you're migrating from older Brobot versions, here's a quick comparison:"}),"\n",(0,r.jsx)(e.h3,{id:"old-format-pre-120",children:"Old Format (Pre-1.2.0)"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// Separate class for each transition\n@Transition(from = HomeState.class, to = WorldState.class)\n@Component\npublic class HomeToWorldTransition {\n    public boolean execute() {\n        return action.click(homeState.getToWorldButton()).isSuccess();\n    }\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"new-format-120",children:"New Format (1.2.0+)"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// All transitions for a state in one class\n@TransitionSet(state = WorldState.class)\n@Component\npublic class WorldTransitions {\n    \n    @FromTransition(from = HomeState.class, priority = 1)\n    public boolean fromHome() {\n        if (FrameworkSettings.mock) return true;\n        return action.click(homeState.getToWorldButton()).isSuccess();\n    }\n    \n    @ToTransition(required = true)\n    public boolean verifyArrival() {\n        if (FrameworkSettings.mock) return true;\n        return action.find(worldState.getWorldMap()).isSuccess();\n    }\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Always include mock mode support"})," for testing environments"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Use descriptive method names"})," like ",(0,r.jsx)(e.code,{children:"fromMenu()"}),", ",(0,r.jsx)(e.code,{children:"fromHomepage()"})]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Add logging"})," to track navigation flow during debugging"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Verify critical elements"})," in ToTransition to ensure state is truly active"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Set appropriate priorities"})," when multiple paths exist to the same state"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Handle exceptions"})," gracefully in complex transitions"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Keep transitions focused"})," - each method should do one thing well"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(e.p,{children:"The @TransitionSet approach provides a clean, maintainable way to define state transitions in Brobot. By grouping all transitions for a state in a single class and using clear annotations to distinguish navigation logic (FromTransition) from verification logic (ToTransition), your automation code becomes easier to understand, test, and maintain."})]})}function u(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}}}]);
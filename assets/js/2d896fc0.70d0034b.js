"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8365],{28453:(n,e,t)=>{t.d(e,{R:()=>r,x:()=>o});var i=t(96540);const s={},a=i.createContext(s);function r(n){const e=i.useContext(a);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:r(n.components),i.createElement(a.Provider,{value:e},n.children)}},43607:(n,e,t)=>{t.d(e,{A:()=>i});const i=t.p+"assets/images/transitions-c388f3c755a4df88c4c15f76e021e687.png"},91768:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"getting-started/transitions","title":"Transitions","description":"Introduction","source":"@site/docs/01-getting-started/transitions.md","sourceDirName":"01-getting-started","slug":"/getting-started/transitions","permalink":"/brobot/docs/getting-started/transitions","draft":false,"unlisted":false,"editUrl":"https://github.com/jspinak/brobot/edit/main/docs/docs/01-getting-started/transitions.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Transitions"},"sidebar":"docSidebar","previous":{"title":"States","permalink":"/brobot/docs/getting-started/states"},"next":{"title":"The Action Hierarchy","permalink":"/brobot/docs/getting-started/action-hierarchy"}}');var s=t(74848),a=t(28453);const r={sidebar_position:4,title:"Transitions"},o="Transitions",d={},l=[{value:"Introduction",id:"introduction",level:2},{value:"The Brobot Implementation: FromTransition and ToTransition",id:"the-brobot-implementation-fromtransition-and-totransition",level:2},{value:"Defining Transitions in Code",id:"defining-transitions-in-code",level:3},{value:"Complete Example: Traditional vs Modern",id:"complete-example-traditional-vs-modern",level:2},{value:"Traditional Approach",id:"traditional-approach",level:3},{value:"Modern Approach",id:"modern-approach",level:3},{value:"The Formal Model (Under the Hood)",id:"the-formal-model-under-the-hood",level:2},{value:"Modern Approach: Using @Transition Annotation",id:"modern-approach-using-transition-annotation",level:2},{value:"@Transition Annotation",id:"transition-annotation",level:3},{value:"Annotation Parameters",id:"annotation-parameters",level:3},{value:"Multiple Target States",id:"multiple-target-states",level:3},{value:"Comparison: Traditional vs Modern",id:"comparison-traditional-vs-modern",level:3},{value:"When to Use Each Approach",id:"when-to-use-each-approach",level:3},{value:"Dynamic Transitions for Hidden States",id:"dynamic-transitions-for-hidden-states",level:2},{value:"Dynamic Transitions with @Transition",id:"dynamic-transitions-with-transition",level:3}];function c(n){const e={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"transitions",children:"Transitions"})}),"\n",(0,s.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsxs)(e.p,{children:['While States define "where you can be" in a GUI, ',(0,s.jsx)(e.strong,{children:"Transitions"}),' define "how you get there." Every State that is reachable needs an associated ',(0,s.jsx)(e.code,{children:"StateTransitions"})," class that defines the pathways to and from other states."]}),"\n",(0,s.jsx)(e.p,{children:'Formally, a transition is a process or a sequence of actions that changes the GUI from one state to another.  They form the "edges" of the state graph and are the building blocks used by the framework\'s pathfinder to navigate the application.'}),"\n",(0,s.jsx)(e.h2,{id:"the-brobot-implementation-fromtransition-and-totransition",children:"The Brobot Implementation: FromTransition and ToTransition"}),"\n",(0,s.jsxs)(e.p,{children:["Brobot implements this concept by splitting transitions into two types: ",(0,s.jsx)(e.strong,{children:"FromTransitions"})," and ",(0,s.jsx)(e.strong,{children:"ToTransitions"}),".  This two-part system provides a clear and reusable structure for managing navigation logic."]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.img,{alt:"Transition Diagram",src:t(43607).A+"",width:"623",height:"196"}),"\n",(0,s.jsx)(e.em,{children:"This diagram is based on Figure 8 from the research paper."})]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"FromTransition"}),": This handles the process of leaving the ",(0,s.jsx)(e.em,{children:"current"})," state to go to another state. For example, to go from ",(0,s.jsx)(e.code,{children:"State A"})," to ",(0,s.jsx)(e.code,{children:"State B"}),", the FromTransition ",(0,s.jsx)(e.code,{children:"A -> B"})," is called. It contains the specific actions needed to initiate the move from State A."]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"ToTransition"}),": This handles the final steps of arriving at a new state, regardless of which state started the process. There can be multiple FromTransitions going to ",(0,s.jsx)(e.code,{children:"State B"})," from different states, but there is only one ToTransition for ",(0,s.jsx)(e.code,{children:"State B"}),". This ",(0,s.jsx)(e.code,{children:"-> B"})," transition contains generic actions that must always run to confirm ",(0,s.jsx)(e.code,{children:"State B"})," is active."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"defining-transitions-in-code",children:"Defining Transitions in Code"}),"\n",(0,s.jsxs)(e.p,{children:["In the ",(0,s.jsx)(e.code,{children:"StateTransitions"})," Builder, you define these two types of transitions using specific commands:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"addTransitionFinish"})," creates the ToTransition. The method passed to it is typically named ",(0,s.jsx)(e.code,{children:"finishTransition()"}),"."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"addTransition"})," creates a FromTransition. The methods passed to it can have any name and contain the actions for that specific path."]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",children:"// From the DoT test application in the paper \npublic class WorldTransitions {\n    // ...\n    StateTransitions transitions =\n        new StateTransitions.Builder(WORLD) // Defines transitions from the WORLD state\n            .addTransitionFinish(this::finishTransition) // This is the ToTransition for WORLD\n            .addTransition(new StateTransition.Builder() // This is a FromTransition\n                .addToActivate(ISLAND) // The target state is ISLAND\n                .setFunction(this::goToIsland) // The method with the actions\n                .build())\n            .build();\n    // ...\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"complete-example-traditional-vs-modern",children:"Complete Example: Traditional vs Modern"}),"\n",(0,s.jsx)(e.h3,{id:"traditional-approach",children:"Traditional Approach"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",children:"// WorldTransitions.java\n@Component\n@RequiredArgsConstructor\npublic class WorldTransitions {\n    private final WorldState worldState;\n    private final Action action;\n    \n    public StateTransitions getStateTransitions() {\n        return new StateTransitions.Builder(WORLD)\n            .addTransitionFinish(this::finishTransition)\n            .addTransition(new StateTransition.Builder()\n                .addToActivate(ISLAND)\n                .setFunction(this::goToIsland)\n                .build())\n            .build();\n    }\n    \n    private boolean goToIsland() {\n        return action.click(worldState.getIslandPortal()).isSuccess();\n    }\n    \n    private boolean finishTransition() {\n        return action.find(worldState.getWorldMap()).isSuccess();\n    }\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"modern-approach",children:"Modern Approach"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",children:"// WorldToIslandTransition.java\n@Transition(from = WorldState.class, to = IslandState.class)\n@RequiredArgsConstructor\npublic class WorldToIslandTransition {\n    private final WorldState worldState;\n    private final Action action;\n    \n    public boolean execute() {\n        return action.click(worldState.getIslandPortal()).isSuccess();\n    }\n}\n\n// ToWorldTransition.java (replaces finishTransition)\n@Transition(to = WorldState.class)\n@RequiredArgsConstructor\npublic class ToWorldTransition {\n    private final WorldState worldState;\n    private final Action action;\n    \n    public boolean execute() {\n        // Verify we're in the World state\n        return action.find(worldState.getWorldMap()).isSuccess();\n    }\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"the-formal-model-under-the-hood",children:"The Formal Model (Under the Hood)"}),"\n",(0,s.jsxs)(e.p,{children:["The academic paper provides a formal definition for a transition as a tuple ",(0,s.jsxs)(e.strong,{children:["t = (A, S",(0,s.jsx)("sub",{children:"t"}),(0,s.jsx)("sup",{children:"def"}),")"]}),"."]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"A"})," is a ",(0,s.jsx)(e.strong,{children:"process"}),", which is a sequence of one or more actions ",(0,s.jsx)(e.code,{children:"(a\xb9, a\xb2, ..., a\u207f)"}),".  This corresponds to the method you pass to the builder (e.g., ",(0,s.jsx)(e.code,{children:"goToIsland"}),")."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsxs)(e.strong,{children:["S",(0,s.jsx)("sub",{children:"t"}),(0,s.jsx)("sup",{children:"def"})]})," is the ",(0,s.jsx)(e.strong,{children:"intended state information"}),".  This is an explicit definition of which states should become active or inactive if the transition succeeds. This makes state management more robust and predictable, as the framework doesn't have to guess the outcome.  This corresponds to builder methods like ",(0,s.jsx)(e.code,{children:".addToActivate(ISLAND)"}),"."]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"modern-approach-using-transition-annotation",children:"Modern Approach: Using @Transition Annotation"}),"\n",(0,s.jsx)(e.p,{children:"Brobot 1.1.0+ introduces a simpler, annotation-based approach for defining transitions. This modern approach reduces boilerplate and integrates seamlessly with Spring Boot's dependency injection."}),"\n",(0,s.jsx)(e.h3,{id:"transition-annotation",children:"@Transition Annotation"}),"\n",(0,s.jsxs)(e.p,{children:["The ",(0,s.jsx)(e.code,{children:"@Transition"})," annotation automatically registers your transition class with the framework:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",children:'@Transition(from = HomeState.class, to = SettingsState.class)\n@RequiredArgsConstructor\n@Slf4j\npublic class HomeToSettingsTransition {\n    private final HomeState homeState;\n    private final Action action;\n    \n    public boolean execute() {\n        log.info("Navigating from Home to Settings");\n        // Click the settings button in the home state\n        return action.click(homeState.getSettingsButton()).isSuccess();\n    }\n}\n'})}),"\n",(0,s.jsx)(e.h3,{id:"annotation-parameters",children:"Annotation Parameters"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"from"}),": The source state class(es) - where the transition starts"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"to"}),": The target state class(es) - where the transition ends"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"method"}),': The method name to execute (default: "execute")']}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"priority"}),": Transition priority when multiple paths exist (default: 0)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"description"}),": Documentation for the transition"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"multiple-target-states",children:"Multiple Target States"}),"\n",(0,s.jsx)(e.p,{children:"You can define transitions that go to multiple possible states:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",children:'@Transition(\n    from = LoginState.class, \n    to = {HomeState.class, ErrorState.class},\n    description = "Login attempt that can succeed or fail"\n)\n@RequiredArgsConstructor\npublic class LoginTransition {\n    private final LoginState loginState;\n    private final Action action;\n    \n    public boolean execute() {\n        // Type credentials\n        action.type(loginState.getUsernameField(), "user@example.com");\n        action.type(loginState.getPasswordField(), "password");\n        \n        // Click login button\n        return action.click(loginState.getLoginButton()).isSuccess();\n    }\n}\n'})}),"\n",(0,s.jsx)(e.h3,{id:"comparison-traditional-vs-modern",children:"Comparison: Traditional vs Modern"}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Aspect"}),(0,s.jsx)(e.th,{children:"Traditional StateTransitions"}),(0,s.jsx)(e.th,{children:"Modern @Transition"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Boilerplate"})}),(0,s.jsx)(e.td,{children:"More verbose, requires builder pattern"}),(0,s.jsx)(e.td,{children:"Minimal, annotation-based"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Registration"})}),(0,s.jsx)(e.td,{children:"Manual in StateRegistrationListener"}),(0,s.jsx)(e.td,{children:"Automatic with Spring scanning"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Dependencies"})}),(0,s.jsx)(e.td,{children:"Injected but used in builder"}),(0,s.jsx)(e.td,{children:"Direct dependency injection"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Type Safety"})}),(0,s.jsx)(e.td,{children:"String-based state names"}),(0,s.jsx)(e.td,{children:"Class-based references"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Spring Integration"})}),(0,s.jsx)(e.td,{children:"Partial"}),(0,s.jsx)(e.td,{children:"Full integration"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Readability"})}),(0,s.jsx)(e.td,{children:"Complex with nested builders"}),(0,s.jsx)(e.td,{children:"Simple and clear"})]})]})]}),"\n",(0,s.jsx)(e.h3,{id:"when-to-use-each-approach",children:"When to Use Each Approach"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Use @Transition (Modern)"})," for:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"New projects starting with Brobot 1.1.0+"}),"\n",(0,s.jsx)(e.li,{children:"Simple, direct state transitions"}),"\n",(0,s.jsx)(e.li,{children:"Better Spring Boot integration"}),"\n",(0,s.jsx)(e.li,{children:"Cleaner, more maintainable code"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Use StateTransitions (Traditional)"})," for:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Legacy projects or gradual migration"}),"\n",(0,s.jsx)(e.li,{children:"Complex transition logic requiring fine control"}),"\n",(0,s.jsx)(e.li,{children:"Dynamic transition generation"}),"\n",(0,s.jsx)(e.li,{children:"Backward compatibility needs"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"dynamic-transitions-for-hidden-states",children:"Dynamic Transitions for Hidden States"}),"\n",(0,s.jsx)(e.p,{children:'In addition to these statically defined transitions, Brobot also supports dynamic transitions to handle common UI patterns like menus and pop-ups. When a state opens and covers another, the covered state is registered as "hidden."'}),"\n",(0,s.jsxs)(e.p,{children:["You can then define a transition with a dynamic target called ",(0,s.jsx)(e.strong,{children:(0,s.jsx)(e.code,{children:"PREVIOUS"})}),". When this transition is executed (e.g., by closing the menu), the framework intelligently navigates back to whatever state was most recently hidden, without you needing to pre-define every possible combination."]}),"\n",(0,s.jsx)(e.h3,{id:"dynamic-transitions-with-transition",children:"Dynamic Transitions with @Transition"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",children:'@Transition(\n    from = MenuState.class,\n    to = PreviousState.class,  // Special marker class for dynamic transitions\n    description = "Close menu and return to previous state"\n)\n@RequiredArgsConstructor\npublic class CloseMenuTransition {\n    private final MenuState menuState;\n    private final Action action;\n    \n    public boolean execute() {\n        // Click close button or press ESC\n        return action.click(menuState.getCloseButton()).isSuccess();\n    }\n}\n'})})]})}function h(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(c,{...n})}):c(n)}}}]);
"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8046],{28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var s=n(96540);const i={},a=s.createContext(i);function o(e){const t=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(a.Provider,{value:t},e.children)}},67603:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"theoretical-foundations/states","title":"States","description":"Introduction","source":"@site/versioned_docs/version-1.0.7/05-theoretical-foundations/states.md","sourceDirName":"05-theoretical-foundations","slug":"/theoretical-foundations/states","permalink":"/brobot/docs/1.0.7/theoretical-foundations/states","draft":false,"unlisted":false,"editUrl":"https://github.com/jspinak/brobot/edit/main/docs/versioned_docs/version-1.0.7/05-theoretical-foundations/states.md","tags":[],"version":"1.0.7","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"States"},"sidebar":"docSidebar","previous":{"title":"The Overall Model","permalink":"/brobot/docs/1.0.7/theoretical-foundations/overall-model"},"next":{"title":"Transitions","permalink":"/brobot/docs/1.0.7/theoretical-foundations/transitions"}}');var i=n(74848),a=n(28453);const o={sidebar_position:4,title:"States"},r="States",l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"The State Structure (\u03a9)",id:"the-state-structure-\u03c9",level:2},{value:"States in Brobot",id:"states-in-brobot",level:2},{value:"State Definition",id:"state-definition",level:3},{value:"State Identification and Verification",id:"state-identification-and-verification",level:3},{value:"Best Practices for State Design",id:"best-practices-for-state-design",level:2}];function d(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"states",children:"States"})}),"\n",(0,i.jsx)(t.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsxs)(t.p,{children:["In model-based GUI automation, the environment is represented by a ",(0,i.jsx)(t.strong,{children:"state structure"}),", which provides a complete map of the problem space. States are a fundamental component of this structure, representing conceptually cohesive sections of the graphical user interface. This approach moves away from fragile, sequential scripts and toward a more robust, explicit model of the GUI environment."]}),"\n",(0,i.jsx)(t.h2,{id:"the-state-structure-\u03c9",children:"The State Structure (\u03a9)"}),"\n",(0,i.jsxs)(t.p,{children:["The formal model of the GUI environment is defined by the state structure ",(0,i.jsx)(t.strong,{children:"\u03a9 = (E, S, T)"}),"."]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"E"})," is the set of all GUI elements chosen to model the environment, such as images, regions, or locations."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"S"})," is the set of all GUI states. Each state is defined as a collection of related GUI elements (a subset of E). Multiple states can be active at the same time."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"T"})," is the set of all transitions between states. Transitions are sequences of actions that change the set of active states."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"states-in-brobot",children:"States in Brobot"}),"\n",(0,i.jsx)(t.h3,{id:"state-definition",children:"State Definition"}),"\n",(0,i.jsx)(t.p,{children:"In Brobot, a state is a collection of related GUI elements. These elements are often grouped spatially or appear together, and what constitutes a state is subjective and should make sense for the specific automation task."}),"\n",(0,i.jsxs)(t.p,{children:["A state is defined by its collection of elements, such as images or regions. For example, the ",(0,i.jsx)(t.code,{children:"Home"})," state in the DoT test application is defined with a single image:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-java",children:'// From the DoT test application in the paper\nprivate StateImageObject toWorldButton = new StateImageObject.Builder()\n    .withImage("toWorldButton")\n    .isFixed(true)\n    .addSnapshot(new MatchSnapshot(220, 600, 20, 20))\n    .build(); \n\nprivate State state = new State.Builder(HOME)\n    .withImages(toWorldButton)\n    .build(); \n'})}),"\n",(0,i.jsx)(t.h3,{id:"state-identification-and-verification",children:"State Identification and Verification"}),"\n",(0,i.jsxs)(t.p,{children:["A state is considered ",(0,i.jsx)(t.strong,{children:"active"})," if one or more of its defining elements are found in the visible GUI. The set of all currently active states is represented by S",(0,i.jsx)("sub",{children:"\u039e"}),"."]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Activation"}),": An observation action that successfully finds an element will mark that element's parent state as active."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Deactivation"}),": States are not marked as inactive simply because an element is not found. Brobot relies on explicit ",(0,i.jsx)(t.strong,{children:"transitions"})," to deactivate states, which provides a more reliable mechanism for state management."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"best-practices-for-state-design",children:"Best Practices for State Design"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Cohesiveness"}),": Group elements into a state that are logically related, appear together on the screen, or are used together in a process."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Context-Driven"}),": The definition of a state is subjective and should be tailored to the goals of the automation application."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Modularity"}),": The state-based approach allows states and transitions to be built, tested, and debugged independently. This modular design helps manage complexity and localize troubleshooting efforts."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Granularity"}),": Balancing the number of states is key. For instance, the paper notes that the DoT app's simple design was chosen for the example, but that a more granular ",(0,i.jsx)(t.code,{children:"NewIsland"})," state might have been better for the specific automation task."]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);
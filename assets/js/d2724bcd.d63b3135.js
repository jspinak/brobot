"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8669],{28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var i=t(96540);const o={},s=i.createContext(o);function a(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),i.createElement(s.Provider,{value:n},e.children)}},79692:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>p,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"core-library/guides/processes-as-objects","title":"Processes as Objects","description":"Interacting with the GUI is not as simple as \'find\' and \'click\'. There are a lot of parameters involved. For example, a \'find\' operation depends on settings such as the minimum similarity required for the match to be accepted, the max amount of time to search before giving up, and the region in which to search, as well as other parameters. Building a library such as Brobot while using processes as functions would create either an exploding web of methods or methods with extremely long parameter lists. It would be unwieldy to use and complicated to develop.","source":"@site/docs/03-core-library/guides/processes-as-objects.md","sourceDirName":"03-core-library/guides","slug":"/core-library/guides/processes-as-objects","permalink":"/brobot/docs/core-library/guides/processes-as-objects","draft":false,"unlisted":false,"editUrl":"https://github.com/jspinak/brobot/edit/main/docs/docs/03-core-library/guides/processes-as-objects.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"docSidebar","previous":{"title":"Data Structure for Color Analysis","permalink":"/brobot/docs/core-library/guides/labeling/color-analysis"},"next":{"title":"Unified Logging System","permalink":"/brobot/docs/core-library/guides/unified-logging-system"}}');var o=t(74848),s=t(28453);const a={sidebar_position:5},r="Processes as Objects",c={},l=[{value:"Core Classes in Brobot 1.1.0",id:"core-classes-in-brobot-110",level:2},{value:"Example: Defining a Region",id:"example-defining-a-region",level:2},{value:"Benefits of the New Type-Safe Approach",id:"benefits-of-the-new-type-safe-approach",level:2},{value:"Creating Complex Actions",id:"creating-complex-actions",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"processes-as-objects",children:"Processes as Objects"})}),"\n",(0,o.jsx)(n.p,{children:"Interacting with the GUI is not as simple as 'find' and 'click'. There are a lot of parameters involved. For example, a 'find' operation depends on settings such as the minimum similarity required for the match to be accepted, the max amount of time to search before giving up, and the region in which to search, as well as other parameters. Building a library such as Brobot while using processes as functions would create either an exploding web of methods or methods with extremely long parameter lists. It would be unwieldy to use and complicated to develop."}),"\n",(0,o.jsx)(n.p,{children:"Processes as objects has an additional advantage in that it allows a interactive process to be treated as the combination of building blocks. This is important because brobot allows for the development of complex applications that react to their environments, in which the sequences of paths and actions taken are not known before the application is run."}),"\n",(0,o.jsx)(n.p,{children:"A good example of how this has affected the design choices taken is how pauses are used. Brobot makes a set of actions available to be used to create  applications. Pause, or wait, is not one of them. Instead, pauses can be selected as part of the action's options. Including pauses as options and not as a separate action was a deliberate design choice. Having a pause method allows the programmer to think in a more procedural manner: for example, do A and then wait a bit and then do B. Brobot's design incentivizes the programmer to think about the process as discrete process objects that can be combined and recombined in different configurations. Brobot provides a framework for a semi-intelligent automation and not just for automating a static process flow."}),"\n",(0,o.jsx)(n.p,{children:"Treating processes as objects also simplifies the creation of new composite actions out of the more basic process building blocks. For example, the composite action ClickUntil, which performs clicks until a condition is reached, is much simpler to create with the standard process objects in Brobot."}),"\n",(0,o.jsx)(n.h2,{id:"core-classes-in-brobot-110",children:"Core Classes in Brobot 1.1.0"}),"\n",(0,o.jsx)(n.p,{children:"The main classes enabling this object-oriented approach are:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"ActionConfig Classes"}),": Type-safe configuration objects for specific actions (e.g., ",(0,o.jsx)(n.code,{children:"PatternFindOptions"}),", ",(0,o.jsx)(n.code,{children:"ClickOptions"}),", ",(0,o.jsx)(n.code,{children:"DragOptions"}),"). Each class contains only the options relevant to its action type."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"ObjectCollection"}),": A collection of state objects that are used with the action."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"ActionService"}),": Provides the appropriate action implementation based on the ActionConfig type."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"ActionInterface"}),": The common interface for all actions, which take ActionConfig and ObjectCollection as parameters."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"ActionResult"}),": Contains all the results of the action linked to the corresponding objects in the ObjectCollection."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"example-defining-a-region",children:"Example: Defining a Region"}),"\n",(0,o.jsx)(n.p,{children:"Here's an example that defines a region around a match using the new ActionConfig API:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:"// Define options for finding the minimap\nPatternFindOptions findOptions = new PatternFindOptions.Builder()\n    .setSimilarity(0.6)\n    .setStrategy(PatternFindOptions.Strategy.FIRST)\n    .build();\n\n// Create object collection with the minimap image\nObjectCollection mapImage = new ObjectCollection.Builder()\n    .withImages(miniMap.getMap())\n    .build();\n\n// Find the minimap\nActionResult findResult = new ActionResult();\nfindResult.setActionConfig(findOptions);\nActionInterface findAction = actionService.getAction(findOptions);\nfindAction.perform(findResult, mapImage);\n\n// Define a region around the found match\nDefineRegionOptions defineOptions = new DefineRegionOptions.Builder()\n    .setDefineAs(DefineRegionOptions.DefineAs.MATCH)\n    .setOffsetX(-5)\n    .setOffsetY(-1)\n    .setWidth(296)\n    .setHeight(255)\n    .build();\n\n// Use the matches from the previous find operation\nObjectCollection matchCollection = new ObjectCollection.Builder()\n    .withMatches(findResult.getMatchList())\n    .build();\n\n// Define the region\nActionResult defineResult = new ActionResult();\ndefineResult.setActionConfig(defineOptions);\nActionInterface defineAction = actionService.getAction(defineOptions);\ndefineAction.perform(defineResult, matchCollection);\n"})}),"\n",(0,o.jsx)(n.h2,{id:"benefits-of-the-new-type-safe-approach",children:"Benefits of the New Type-Safe Approach"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Compile-Time Safety"}),": The compiler ensures you're using the right options for each action type."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Better IDE Support"}),": Auto-completion shows only relevant options for each action."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Clearer Intent"}),": The configuration class name immediately tells you what action will be performed."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Easier Composition"}),": Different action configurations can be easily combined to create complex behaviors."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"creating-complex-actions",children:"Creating Complex Actions"}),"\n",(0,o.jsx)(n.p,{children:"The object-oriented approach makes it easy to create complex, reusable actions:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:"public class SmartClick {\n    private final ActionService actionService;\n    \n    public boolean clickWithRetry(StateImage target, int maxRetries) {\n        for (int i = 0; i < maxRetries; i++) {\n            // First, find the target\n            PatternFindOptions findOptions = PatternFindOptions.forPreciseSearch();\n            ActionResult findResult = performAction(findOptions, target);\n            \n            if (findResult.isSuccess()) {\n                // Click on the found target\n                ClickOptions clickOptions = new ClickOptions.Builder()\n                    .setClickType(ClickOptions.Type.LEFT)\n                    .setPauseAfterEnd(0.5)\n                    .build();\n                    \n                ActionResult clickResult = performAction(clickOptions, \n                    findResult.getMatchList());\n                \n                if (clickResult.isSuccess()) {\n                    return true;\n                }\n            }\n            \n            // If this isn't the last attempt, add a pause\n            if (i < maxAttempts - 1) {\n                // Use a find action with pause to wait between attempts\n                PatternFindOptions waitOptions = new PatternFindOptions.Builder()\n                    .setPauseAfterAction(1.0)  // 1 second pause\n                    .setMaxMatchesToFind(0)     // Don't actually search\n                    .build();\n                performAction(waitOptions, target);\n            }\n        }\n        return false;\n    }\n    \n    private ActionResult performAction(ActionConfig config, Object data) {\n        ActionResult result = new ActionResult();\n        result.setActionConfig(config);\n        \n        ObjectCollection objects = createObjectCollection(data);\n        ActionInterface action = actionService.getAction(config);\n        action.perform(result, objects);\n        \n        return result;\n    }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"This design philosophy allows Brobot to provide a framework for semi-intelligent automation, not just for automating static process flows. The type-safe ActionConfig classes in version 2.0 make this approach even more powerful and easier to use."}),"\n",(0,o.jsxs)(n.p,{children:["For more information on migrating from the old ActionOptions API to the new ActionConfig API, see the ",(0,o.jsx)(n.a,{href:"./migration-guide",children:"Migration Guide"}),"."]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);
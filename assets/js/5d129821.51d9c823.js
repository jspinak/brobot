"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3389],{28453:(n,i,e)=>{e.d(i,{R:()=>l,x:()=>s});var t=e(96540);const o={},a=t.createContext(o);function l(n){const i=t.useContext(a);return t.useMemo(function(){return"function"==typeof n?n(i):{...i,...n}},[i,n])}function s(n){let i;return i=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:l(n.components),t.createElement(a.Provider,{value:i},n.children)}},98870:(n,i,e)=>{e.r(i),e.d(i,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>r});const t=JSON.parse('{"id":"getting-started/action-hierarchy","title":"The Action Hierarchy","description":"Brobot interacts with the GUI using the Sikuli library. This is done with 3 main levels of abstraction:","source":"@site/docs/01-getting-started/action-hierarchy.md","sourceDirName":"01-getting-started","slug":"/getting-started/action-hierarchy","permalink":"/brobot/docs/getting-started/action-hierarchy","draft":false,"unlisted":false,"editUrl":"https://github.com/jspinak/brobot/edit/main/docs/docs/01-getting-started/action-hierarchy.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"title":"The Action Hierarchy"},"sidebar":"docSidebar","previous":{"title":"Transitions","permalink":"/brobot/docs/getting-started/transitions"},"next":{"title":"Pathfinding & Multi-State Activation","permalink":"/brobot/docs/getting-started/pathfinding"}}');var o=e(74848),a=e(28453);const l={sidebar_position:5,title:"The Action Hierarchy"},s="Controlling the GUI",c={},r=[{value:"Sikuli Wrappers",id:"sikuli-wrappers",level:2},{value:"Basic Actions",id:"basic-actions",level:2},{value:"Complex Actions",id:"complex-actions",level:2},{value:"Example: Click Until Pattern Appears",id:"example-click-until-pattern-appears",level:3},{value:"Method 1: Traditional Loop Approach",id:"method-1-traditional-loop-approach",level:4},{value:"Method 2: Fluent API with Action Chaining",id:"method-2-fluent-api-with-action-chaining",level:4},{value:"Method 3: Using ConditionalActionChain",id:"method-3-using-conditionalactionchain",level:4},{value:"Method 4: Creating a Reusable Click-Until-Found Function",id:"method-4-creating-a-reusable-click-until-found-function",level:4},{value:"Choosing the Right Approach",id:"choosing-the-right-approach",level:3},{value:"Best Practices for Click Until Found",id:"best-practices-for-click-until-found",level:3},{value:"Conditional Action Chaining",id:"conditional-action-chaining",level:2},{value:"ConditionalActionChain Overview",id:"conditionalactionchain-overview",level:3},{value:"Basic Conditional Chaining",id:"basic-conditional-chaining",level:3},{value:"Advanced Conditional Patterns",id:"advanced-conditional-patterns",level:3},{value:"Pattern 1: Multi-Step Validation",id:"pattern-1-multi-step-validation",level:4},{value:"Pattern 2: Retry with Different Strategies",id:"pattern-2-retry-with-different-strategies",level:4},{value:"Pattern 3: Conditional Branching Based on Application State",id:"pattern-3-conditional-branching-based-on-application-state",level:4},{value:"Integration with ActionChainOptions",id:"integration-with-actionchainoptions",level:3},{value:"Comparison: ActionChainOptions vs ConditionalActionChain",id:"comparison-actionchainoptions-vs-conditionalactionchain",level:3},{value:"When to Use Each Approach",id:"when-to-use-each-approach",level:3},{value:"Best Practices for Conditional Chaining",id:"best-practices-for-conditional-chaining",level:3},{value:"Example: Complete Form Filling with Validation",id:"example-complete-form-filling-with-validation",level:3},{value:"Related Documentation",id:"related-documentation",level:3}];function d(n){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(i.header,{children:(0,o.jsx)(i.h1,{id:"controlling-the-gui",children:"Controlling the GUI"})}),"\n",(0,o.jsx)(i.p,{children:"Brobot interacts with the GUI using the Sikuli library. This is done with 3 main levels of abstraction:"}),"\n",(0,o.jsx)(i.h2,{id:"sikuli-wrappers",children:"Sikuli Wrappers"}),"\n",(0,o.jsx)(i.p,{children:"These are the methods that form the interface between Brobot and Sikuli.\nSikuli Wrappers route the operational instructions either to Sikuli methods, which control the mouse and keyboard and capture data from the screen, or to functions that mock (simulate) these methods. When calling Sikuli methods, the Wrappers convert Brobot data types to Sikuli data types."}),"\n",(0,o.jsx)(i.h2,{id:"basic-actions",children:"Basic Actions"}),"\n",(0,o.jsx)(i.p,{children:"Basic Actions are the fundamental building blocks of GUI automation in Brobot. They perform simple, atomic operations that typically require at most one Find operation.\nExamples include:"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Find Actions"})," - Locate images, text, or patterns on screen"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Click Actions"})," - Single, double, or right clicks at specific locations"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Type Actions"})," - Keyboard input and key combinations"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Move Actions"})," - Mouse movements and hover operations"]}),"\n"]}),"\n",(0,o.jsxs)(i.p,{children:["Each Basic Action is implemented as a separate class that implements the ",(0,o.jsx)(i.code,{children:"ActionInterface"}),",\nproviding a clean, type-safe API through specific configuration classes like ",(0,o.jsx)(i.code,{children:"PatternFindOptions"}),",\n",(0,o.jsx)(i.code,{children:"ClickOptions"}),", and ",(0,o.jsx)(i.code,{children:"TypeOptions"}),"."]}),"\n",(0,o.jsx)(i.h2,{id:"complex-actions",children:"Complex Actions"}),"\n",(0,o.jsx)(i.p,{children:"Complex Actions (formerly called Composite Actions) combine Basic Actions to create more sophisticated operations. These are useful for:"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Multi-step Operations"})," - Actions requiring multiple Find operations"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Conditional Behaviors"})," - Click until something appears/disappears"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Drag Operations"})," - Click, hold, move, and release sequences"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Scrolling"})," - Repeated scroll actions until target is found"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Retry Logic"})," - Automatic retry with different strategies"]}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:"In Brobot 1.1.0, Complex Actions are built by:"}),"\n",(0,o.jsxs)(i.ol,{children:["\n",(0,o.jsx)(i.li,{children:"Chaining multiple Basic Actions together"}),"\n",(0,o.jsxs)(i.li,{children:["Using ",(0,o.jsx)(i.code,{children:"TaskSequence"})," for scripted sequences"]}),"\n",(0,o.jsx)(i.li,{children:"Creating custom action classes that orchestrate Basic Actions"}),"\n"]}),"\n",(0,o.jsx)(i.h3,{id:"example-click-until-pattern-appears",children:"Example: Click Until Pattern Appears"}),"\n",(0,o.jsx)(i.p,{children:"There are multiple ways to implement clickUntilFound in Brobot. Here are the most clean and efficient approaches:"}),"\n",(0,o.jsx)(i.h4,{id:"method-1-traditional-loop-approach",children:"Method 1: Traditional Loop Approach"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-java",children:"public boolean clickUntilFound(StateImage clickTarget, StateImage findTarget, int maxAttempts) {\n    ClickOptions click = new ClickOptions.Builder()\n            .setPauseAfterEnd(1.0)\n            .build();\n\n    ObjectCollection clickCollection = new ObjectCollection.Builder()\n            .withImages(clickTarget).build();\n\n    ObjectCollection findCollection = new ObjectCollection.Builder()\n            .withImages(findTarget).build();\n\n    for (int i = 0; i < maxAttempts; i++) {\n        action.perform(click, clickCollection);\n        ActionResult result = action.perform(PatternFindOptions.forQuickSearch(), findCollection);\n\n        if (result.isSuccess()) {\n            return true;\n        }\n    }\n    return false;\n}\n"})}),"\n",(0,o.jsx)(i.h4,{id:"method-2-fluent-api-with-action-chaining",children:"Method 2: Fluent API with Action Chaining"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-java",children:"public boolean clickUntilFoundFluent(StateImage clickTarget, StateImage findTarget) {\n    ClickOptions clickWithVerify = new ClickOptions.Builder()\n        .setVerification(new VerificationOptions.Builder()\n            .addVerifyImage(findTarget)  // Check if this appears\n            .build())\n        .setRepetition(new RepetitionOptions.Builder()\n            .setMaxTimesToRepeatActionSequence(10)\n            .setPauseBetweenActionSequences(0.5)\n            .build())\n        .build();\n\n    ObjectCollection targets = new ObjectCollection.Builder()\n        .withImages(clickTarget, findTarget)\n        .build();\n\n    ActionResult result = action.perform(clickWithVerify, targets);\n    return result.isSuccess();\n}\n"})}),"\n",(0,o.jsx)(i.h4,{id:"method-3-using-conditionalactionchain",children:"Method 3: Using ConditionalActionChain"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-java",children:"// Direct usage with ConditionalActionChain\nConditionalActionChain clickUntilFound = ConditionalActionChain\n    .find(nextButton)\n    .ifFoundClick()\n    .then(new PatternFindOptions.Builder()\n        .setRepetition(new RepetitionOptions.Builder()\n            .setMaxTimesToRepeatActionSequence(10)\n            .setPauseBetweenActionSequences(1.0)\n            .build())\n        .build())\n    .withObjectCollection(new ObjectCollection.Builder()\n        .withImages(finishButton)\n        .build());\n\nActionResult result = clickUntilFound.perform(action);\n"})}),"\n",(0,o.jsx)(i.h4,{id:"method-4-creating-a-reusable-click-until-found-function",children:"Method 4: Creating a Reusable Click-Until-Found Function"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-java",children:"// Creating a clean, reusable function using ConditionalActionChain\npublic boolean clickUntilFound(StateImage clickTarget, StateImage findTarget, \n                                int maxAttempts, double pauseBetween) {\n\n    // Use RepetitionOptions on the find action for retry logic\n    PatternFindOptions findWithRetry = new PatternFindOptions.Builder()\n        .setRepetition(new RepetitionOptions.Builder()\n            .setMaxTimesToRepeatActionSequence(maxAttempts)\n            .setPauseBetweenActionSequences(pauseBetween)\n            .build())\n        .build();\n\n    // Build the conditional chain\n    ConditionalActionChain clickAndCheck = ConditionalActionChain\n        .find(clickTarget)\n        .ifFoundClick()\n        .then(findWithRetry)\n        .withObjectCollection(new ObjectCollection.Builder()\n            .withImages(findTarget)\n            .build());\n\n    // Execute and check the final result\n    ActionResult result = clickAndCheck.perform(action);\n    return result.isSuccess();\n}\n\n// Usage example:\nboolean success = clickUntilFound(nextButton, finishButton, 10, 1.0);\n"})}),"\n",(0,o.jsx)(i.h3,{id:"choosing-the-right-approach",children:"Choosing the Right Approach"}),"\n",(0,o.jsxs)(i.table,{children:[(0,o.jsx)(i.thead,{children:(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.th,{children:"Method"}),(0,o.jsx)(i.th,{children:"When to Use"}),(0,o.jsx)(i.th,{children:"Pros"}),(0,o.jsx)(i.th,{children:"Cons"})]})}),(0,o.jsxs)(i.tbody,{children:[(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.td,{children:(0,o.jsx)(i.strong,{children:"Traditional Loop"})}),(0,o.jsx)(i.td,{children:"Simple cases, full control needed"}),(0,o.jsx)(i.td,{children:"Complete control over logic"}),(0,o.jsx)(i.td,{children:"More verbose, manual logging"})]}),(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.td,{children:(0,o.jsx)(i.strong,{children:"Fluent API Chaining"})}),(0,o.jsx)(i.td,{children:"Most common cases"}),(0,o.jsx)(i.td,{children:"Clean, automatic logging, easy to read"}),(0,o.jsx)(i.td,{children:"Requires understanding of chaining"})]}),(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.td,{children:(0,o.jsx)(i.strong,{children:"Reusable Function"})}),(0,o.jsx)(i.td,{children:"Multiple uses in codebase"}),(0,o.jsx)(i.td,{children:"DRY principle, consistent behavior"}),(0,o.jsx)(i.td,{children:"May need customization for edge cases"})]})]})]}),"\n",(0,o.jsx)(i.h3,{id:"best-practices-for-click-until-found",children:"Best Practices for Click Until Found"}),"\n",(0,o.jsxs)(i.ol,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Use Logging"}),": The fluent API approach (Method 2) provides the best logging and debugging experience"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Set Reasonable Timeouts"}),": Set the number of attempts to balance search time and robustness"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Add Pauses"}),": Include pauses between clicks to allow the UI to respond"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Consider State Management"}),": Since it includes Find operations, clickUntilFound might add a new active state"]}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:"This modular approach makes it easy to create custom complex behaviors while maintaining the benefits of type safety and clear intent provided by the ActionConfig architecture."}),"\n",(0,o.jsx)(i.h2,{id:"conditional-action-chaining",children:"Conditional Action Chaining"}),"\n",(0,o.jsxs)(i.p,{children:["Brobot 1.1.0+ introduces the powerful ",(0,o.jsx)(i.code,{children:"ConditionalActionChain"})," class for building sophisticated conditional execution flows. This provides a fluent API for creating complex action sequences with conditional branching, error handling, and retry logic."]}),"\n",(0,o.jsx)(i.h3,{id:"conditionalactionchain-overview",children:"ConditionalActionChain Overview"}),"\n",(0,o.jsxs)(i.p,{children:["The ",(0,o.jsx)(i.code,{children:"ConditionalActionChain"})," class allows you to:"]}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Chain actions with conditional execution based on previous results"}),"\n",(0,o.jsx)(i.li,{children:"Add fallback actions when primary actions fail"}),"\n",(0,o.jsx)(i.li,{children:"Implement retry logic with different strategies"}),"\n",(0,o.jsx)(i.li,{children:"Create branching workflows based on runtime conditions"}),"\n",(0,o.jsx)(i.li,{children:"Handle errors gracefully with recovery actions"}),"\n"]}),"\n",(0,o.jsx)(i.h3,{id:"basic-conditional-chaining",children:"Basic Conditional Chaining"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-java",children:'import io.github.jspinak.brobot.action.ConditionalActionChain;\nimport io.github.jspinak.brobot.action.ActionResult;\n\n// Simple conditional chain: if login button found, click it and enter credentials\nConditionalActionChain loginChain = ConditionalActionChain\n    .find(loginButton)      // Pass StateImage directly\n    .ifFoundClick()         // Click the login button\n    .then(usernameField)    // Find username field\n    .ifFoundType(username)  // Type username (string)\n    .then(passwordField)    // Find password field\n    .ifFoundType(password)  // Type password (string)\n    .then(submitButton)     // Find submit button\n    .ifFoundClick()         // Click it\n    .ifNotFoundLog("Login button not found - may already be logged in");\n\nActionResult result = loginChain.perform(action);  // No ObjectCollection needed\n'})}),"\n",(0,o.jsx)(i.p,{children:"Or if you want to use the custom handler approach:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-java",children:'ConditionalActionChain loginChain = ConditionalActionChain\n    .find(loginButton)\n    .ifFoundClick()\n    .ifFoundDo(result -> {\n        action.click(usernameField);\n        action.type(username);\n        action.click(passwordField);\n        action.type(password);\n        action.click(submitButton);\n    })\n    .ifNotFoundLog("Login button not found");\n'})}),"\n",(0,o.jsx)(i.h3,{id:"advanced-conditional-patterns",children:"Advanced Conditional Patterns"}),"\n",(0,o.jsx)(i.h4,{id:"pattern-1-multi-step-validation",children:"Pattern 1: Multi-Step Validation"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-java",children:'// Validate each step and proceed only if successful\nConditionalActionChain wizardChain = ConditionalActionChain\n    .find(step1Button)  // Just pass the StateImage\n    .ifFoundClick()\n    .then(step2Button)\n    .ifFoundClick()\n    .then(step3Button)\n    .ifFoundClick()\n    .then(completionMessage)  // Use then() with StateImage\n    .ifFoundLog("Wizard completed successfully")\n    .ifNotFoundLog("Wizard failed to complete");\n\n// Execute\nActionResult result = wizardChain.perform(action);\n'})}),"\n",(0,o.jsx)(i.p,{children:"Or if you need custom options for specific steps, you need to use the internal pattern:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-java",children:'// If you need custom search duration for completion\nConditionalActionChain wizardChain = ConditionalActionChain\n    .find(step1Button)\n    .ifFoundClick()\n    .then(step2Button)\n    .ifFoundClick()\n    .then(step3Button)\n    .ifFoundClick()\n    .then(new PatternFindOptions.Builder()\n        .setSearchDuration(5.0)\n        .build())\n    .withObjectCollection(new ObjectCollection.Builder()\n        .withImages(completionMessage)\n        .build())  // Must manually attach the image\n    .ifFoundLog("Wizard completed successfully")\n    .ifNotFoundLog("Wizard failed to complete");\n\nActionResult result = wizardChain.perform(action);\n'})}),"\n",(0,o.jsx)(i.p,{children:"find() and then() methods accept either PatternFindOptions OR StateImage, but not both as separate parameters.\nWhen using options, you must manually attach the ObjectCollection with .withObjectCollection()."}),"\n",(0,o.jsx)(i.h4,{id:"pattern-2-retry-with-different-strategies",children:"Pattern 2: Retry with Different Strategies"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-java",children:'// Try different approaches to close a dialog\n// Method 1: Try X button first\nConditionalActionChain closeWithX = ConditionalActionChain\n    .find(closeButton)  // Pass the StateImage directly\n    .ifFoundClick()\n    .ifFoundLog("Closed dialog with X button");\n\n// Method 2: Try Escape key if X button fails  \nConditionalActionChain closeWithEsc = ConditionalActionChain\n    .pressEscape()  // Use the convenience method\n    .then(dialogImage)  // Check if dialog gone\n    .ifNotFoundLog("Dialog closed with ESC key");\n\n// Or using start():\nConditionalActionChain closeWithEscAlt = ConditionalActionChain\n    .start(new TypeOptions.Builder().build())\n    .withObjectCollection(new ObjectCollection.Builder()\n        .withStrings(org.sikuli.script.Key.ESC)  // Pass Key.ESC as string\n        .build())\n    .then(dialogImage)\n    .ifNotFoundLog("Dialog closed with ESC key");\n\n// Method 3: Click at a screen location to dismiss\nConditionalActionChain closeWithClick = ConditionalActionChain\n    .start(new ClickOptions.Builder().build())\n    .withObjectCollection(new ObjectCollection.Builder()\n        .withLocations(new Location(10, 10))  // Click at specific location\n        .build())\n    .then(dialogImage)\n    .ifNotFoundLog("Dialog closed by clicking outside");\n\n// Execute each chain with the Action instance\nActionResult result1 = closeWithX.perform(action);\nActionResult result2 = closeWithEsc.perform(action);\nActionResult result3 = closeWithClick.perform(action);\n'})}),"\n",(0,o.jsx)(i.h4,{id:"pattern-3-conditional-branching-based-on-application-state",children:"Pattern 3: Conditional Branching Based on Application State"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-java",children:'// Different actions based on what\'s visible on screen\n// Since ConditionalActionChain doesn\'t have elseWhen, use separate chains\n\n// Chain for home screen\nConditionalActionChain fromHome = ConditionalActionChain\n    .find(homeScreen)       // Find home screen (pass StateImage directly)\n    .then(menuButton)       // Find menu button\n    .ifFoundClick()         // Click it\n    .then(menuPanel)        // Find menu panel\n    .ifFoundLog("Opened menu from home screen");\n\n// Chain for settings screen  \nConditionalActionChain fromSettings = ConditionalActionChain\n    .find(settingsScreen)   // Find settings screen\n    .then(backButton)       // Find back button\n    .ifFoundClick()         // Click it\n    .then(homeScreen)       // Find home screen\n    .ifFoundLog("Returned to home from settings");\n\n// Chain for error dialog\nConditionalActionChain fromError = ConditionalActionChain\n    .find(errorDialog)      // Find error dialog\n    .then(dismissButton)    // Find dismiss button\n    .ifFoundClick()         // Click dismiss\n    .then(homeButton)       // Find home button\n    .ifFoundClick()         // Click home button\n    .then(homeScreen)       // Verify home screen\n    .ifFoundLog("Recovered from error state");\n\n// Execute appropriate chain based on current state\nActionResult result;\nif (action.find(homeScreen).isSuccess()) {\n    result = fromHome.perform(action);\n} else if (action.find(settingsScreen).isSuccess()) {\n    result = fromSettings.perform(action);\n} else if (action.find(errorDialog).isSuccess()) {\n    result = fromError.perform(action);\n} else {\n    log.warn("Unknown state - attempting recovery");\n    action.pressEscape();\n    action.pressEscape();\n}\n'})}),"\n",(0,o.jsx)(i.h3,{id:"integration-with-actionchainoptions",children:"Integration with ActionChainOptions"}),"\n",(0,o.jsxs)(i.p,{children:["Conditional chains can be combined with ",(0,o.jsx)(i.code,{children:"ActionChainOptions"})," for even more sophisticated behaviors:"]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-java",children:"// Combine ActionChainOptions with ConditionalActionChain\n// First, use ActionChainOptions for nested/confirmed finds\nActionChainOptions nestedFind = new ActionChainOptions.Builder(\n        new PatternFindOptions.Builder()\n            .setStrategy(PatternFindOptions.Strategy.BEST)\n            .setSimilarity(0.9)\n            .build())\n    .setStrategy(ActionChainOptions.ChainingStrategy.NESTED)\n    .then(new ColorFindOptions.Builder()\n        .setColorStrategy(ColorFindOptions.Color.MU)\n        .setSimilarity(0.85)\n        .build())\n    .build();\n\n// Then use ConditionalActionChain for conditional logic\nConditionalActionChain robustClick = ConditionalActionChain\n    .start(nestedFind)  // Start with the chained find\n    .ifFoundClick()     // Click if found\n    .ifNotFoundDo(result -> {\n        // Fallback: try with lower similarity\n        PatternFindOptions relaxedFind = new PatternFindOptions.Builder()\n            .setStrategy(PatternFindOptions.Strategy.BEST)\n            .setSimilarity(0.7)\n            .build();\n\n        ObjectCollection targetCollection = new ObjectCollection.Builder()\n            .withImages(targetImage)\n            .build();\n\n        ActionResult fallbackResult = action.perform(relaxedFind, targetCollection);\n        if (fallbackResult.isSuccess()) {\n            action.click(targetImage);\n        }\n    });\n\n// Execute the chain (needs ObjectCollection with target image)\nObjectCollection targets = new ObjectCollection.Builder()\n    .withImages(targetImage)\n    .build();\nActionResult result = robustClick.perform(action, targets);\n\n// For retry logic, use RepetitionOptions\nPatternFindOptions withRetry = new PatternFindOptions.Builder()\n    .setStrategy(PatternFindOptions.Strategy.BEST)\n    .setRepetition(new RepetitionOptions.Builder()\n        .setMaxTimesToRepeatActionSequence(2)\n        .setPauseBetweenActionSequences(1.0)\n        .build())\n    .build();\n"})}),"\n",(0,o.jsx)(i.h3,{id:"comparison-actionchainoptions-vs-conditionalactionchain",children:"Comparison: ActionChainOptions vs ConditionalActionChain"}),"\n",(0,o.jsxs)(i.table,{children:[(0,o.jsx)(i.thead,{children:(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.th,{children:"Feature"}),(0,o.jsx)(i.th,{children:"ActionChainOptions"}),(0,o.jsx)(i.th,{children:"ConditionalActionChain"})]})}),(0,o.jsxs)(i.tbody,{children:[(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.td,{children:"Purpose"}),(0,o.jsx)(i.td,{children:"Chain actions with NESTED/CONFIRM strategies"}),(0,o.jsx)(i.td,{children:"Complex conditional workflows"})]}),(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.td,{children:"Conditional Logic"}),(0,o.jsx)(i.td,{children:"Limited (success/failure)"}),(0,o.jsx)(i.td,{children:"Full boolean conditions"})]}),(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.td,{children:"Branching"}),(0,o.jsx)(i.td,{children:"No"}),(0,o.jsx)(i.td,{children:"Partial (if/ifNot, no elseWhen)"})]}),(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.td,{children:"Custom Logic"}),(0,o.jsx)(i.td,{children:"No"}),(0,o.jsx)(i.td,{children:"Yes (lambda expressions via ifFoundDo/ifNotFoundDo)"})]}),(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.td,{children:"Retry Handling"}),(0,o.jsx)(i.td,{children:"Via RepetitionOptions"}),(0,o.jsx)(i.td,{children:"Via static retry() method or manual loops"})]}),(0,o.jsxs)(i.tr,{children:[(0,o.jsx)(i.td,{children:"Use Case"}),(0,o.jsx)(i.td,{children:"Pattern/color combining, hierarchical searches"}),(0,o.jsx)(i.td,{children:"Complex decision trees, recovery workflows"})]})]})]}),"\n",(0,o.jsx)(i.h3,{id:"when-to-use-each-approach",children:"When to Use Each Approach"}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.strong,{children:"Use ActionChainOptions when:"})}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Combining find operations (nested or confirmed)"}),"\n",(0,o.jsx)(i.li,{children:"Performing sequential actions on the same objects"}),"\n",(0,o.jsx)(i.li,{children:"Working with pattern and color matching"}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.strong,{children:"Use ConditionalActionChain when:"})}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Need complex conditional logic"}),"\n",(0,o.jsx)(i.li,{children:"Implementing recovery strategies"}),"\n",(0,o.jsx)(i.li,{children:"Creating branching workflows"}),"\n",(0,o.jsx)(i.li,{children:"Need custom validation between steps"}),"\n",(0,o.jsx)(i.li,{children:"Building robust error handling"}),"\n"]}),"\n",(0,o.jsx)(i.h3,{id:"best-practices-for-conditional-chaining",children:"Best Practices for Conditional Chaining"}),"\n",(0,o.jsxs)(i.ol,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Keep Chains Focused"}),": Each chain should have a single, clear purpose"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Use Meaningful Names"}),": Name your chains based on what they accomplish"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Add Logging"}),": Include log statements in your conditions and actions"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Set Reasonable Timeouts"}),": Prevent chains from running indefinitely"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Test Edge Cases"}),": Ensure your fallback actions handle all scenarios"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Document Complex Logic"}),": Add comments explaining the flow"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Consider State Management"}),": Chains may trigger state activations"]}),"\n"]}),"\n",(0,o.jsx)(i.h3,{id:"example-complete-form-filling-with-validation",children:"Example: Complete Form Filling with Validation"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-java",children:'@Slf4j  // Automatically creates: private static final Logger log\n@Component\npublic class FormAutomation {\n\n    @Autowired\n    private Action action;\n\n    public boolean fillComplexForm(FormData data) {\n        // Check if form is open\n        ConditionalActionChain openForm = ConditionalActionChain\n            .find(formTitle)  // Pass StateImage directly\n            .ifNotFoundLog("Form not found")\n            .ifNotFoundDo(result -> log.error("Cannot proceed - form not visible"));\n\n        ActionResult formResult = openForm.perform(action);  // No ObjectCollection needed\n\n        if (!formResult.isSuccess()) {\n            return false;\n        }\n\n        // Fill required fields\n        boolean requiredFilled = fillRequiredFields(data);\n        if (!requiredFilled) {\n            log.error("Failed to fill required fields");\n            return false;\n        }\n\n        // Conditionally fill optional fields\n        if (data.hasOptionalData()) {\n            fillOptionalFields(data);\n        }\n\n        // Validate before submission\n        ConditionalActionChain validateChain = ConditionalActionChain\n            .find(validateButton)  // Find validate button\n            .ifFoundClick()        // Click it\n            .then(new PatternFindOptions.Builder()\n                .setSearchDuration(2.0)  // Wait for validation\n                .build())\n            .withObjectCollection(new ObjectCollection.Builder()\n                .withImages(errorMessage)  // Look for error message\n                .build())\n            .ifFoundDo(result -> {\n                // If error message found, handle it\n                ActionResult textResult = action.find(errorMessage);\n                if (textResult.isSuccess() && !textResult.getMatches().isEmpty()) {\n                    // Extract text from the error (if it\'s a text element)\n                    log.error("Validation error found");\n                    fixValidationError("validation_error");\n                }\n            })\n            .ifNotFoundLog("Validation passed");\n\n        ActionResult validateResult = validateChain.perform(action);\n\n        // Submit if valid\n        if (!action.find(errorMessage).isSuccess()) {\n            ConditionalActionChain submitChain = ConditionalActionChain\n                .find(submitButton)    // Find submit button\n                .ifFoundClick()        // Click it\n                .then(new PatternFindOptions.Builder()\n                    .setSearchDuration(5.0)\n                    .build())\n                .withObjectCollection(new ObjectCollection.Builder()\n                    .withImages(successMessage)\n                    .build())\n                .ifFoundLog("Form submitted successfully");\n\n            ActionResult submitResult = submitChain.perform(action);\n\n            return submitResult.isSuccess();\n        }\n\n        // Cancel if errors persist\n        action.click(cancelButton);\n        return false;\n    }\n\n    // Helper methods (stubs)\n    private boolean fillRequiredFields(FormData data) { return true; }\n    private void fillOptionalFields(FormData data) {}\n    private void fixValidationError(String error) {}\n}\n'})}),"\n",(0,o.jsx)(i.h3,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:(0,o.jsx)(i.a,{href:"ai-brobot-project-creation#conditional-action-chains",children:"Conditional Action Chaining Guide"})})," - Comprehensive guide with more examples"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:(0,o.jsx)(i.a,{href:"/brobot/docs/core-library/guides/action-config-factory",children:"Action Config Factory"})})," - Creating and managing action configurations"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:(0,o.jsx)(i.a,{href:"/brobot/docs/core-library/guides/finding-objects/combining-finds",children:"Combining Finds"})})," - Pattern and color combination strategies"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:(0,o.jsx)(i.a,{href:"https://github.com/jspinak/brobot/tree/main/examples/03-core-library/action-config/conditional-chains-examples",children:"ConditionalActionChain Example"})})," - Complete implementation examples"]}),"\n"]})]})}function h(n={}){const{wrapper:i}={...(0,a.R)(),...n.components};return i?(0,o.jsx)(i,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}}}]);
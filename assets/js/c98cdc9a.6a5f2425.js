"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8509],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var i=t(96540);const s={},a=i.createContext(s);function r(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:n},e.children)}},48815:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"core-library/guides/dynamic-transitions","title":"Dynamic Transitions and Hidden States","description":"Overview","source":"@site/docs/03-core-library/guides/dynamic-transitions.md","sourceDirName":"03-core-library/guides","slug":"/core-library/guides/dynamic-transitions","permalink":"/brobot/docs/core-library/guides/dynamic-transitions","draft":false,"unlisted":false,"editUrl":"https://github.com/jspinak/brobot/edit/main/docs/docs/03-core-library/guides/dynamic-transitions.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7,"title":"Dynamic Transitions and Hidden States"},"sidebar":"docSidebar","previous":{"title":"Enhanced Action Logging with Console Output and Visual Feedback","permalink":"/brobot/docs/core-library/guides/action-logging-console-visual"},"next":{"title":"Logging Migration Guide","permalink":"/brobot/docs/core-library/guides/logging-migration-guide"}}');var s=t(74848),a=t(28453);const r={sidebar_position:7,title:"Dynamic Transitions and Hidden States"},o="Dynamic Transitions and Hidden States",l={},c=[{value:"Overview",id:"overview",level:2},{value:"The Problem",id:"the-problem",level:2},{value:"The Solution: Hidden States",id:"the-solution-hidden-states",level:2},{value:"How Hidden States Work",id:"how-hidden-states-work",level:2},{value:"State Registration",id:"state-registration",level:3},{value:"The PREVIOUS Transition Target",id:"the-previous-transition-target",level:3},{value:"Implementation Examples",id:"implementation-examples",level:2},{value:"Modern Approach with @Transition",id:"modern-approach-with-transition",level:3},{value:"Traditional Approach with StateTransitions",id:"traditional-approach-with-statetransitions",level:3},{value:"Advanced Patterns",id:"advanced-patterns",level:2},{value:"Multi-Level Overlays",id:"multi-level-overlays",level:3},{value:"Conditional Hidden States",id:"conditional-hidden-states",level:3},{value:"Combining with State Verification",id:"combining-with-state-verification",level:3},{value:"Framework Components",id:"framework-components",level:2},{value:"SetHiddenStates",id:"sethiddenstates",level:3},{value:"StateMemory",id:"statememory",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Use for True Overlays",id:"1-use-for-true-overlays",level:3},{value:"2. Provide Fallbacks",id:"2-provide-fallbacks",level:3},{value:"3. Clear Visual Indicators",id:"3-clear-visual-indicators",level:3},{value:"4. Handle Edge Cases",id:"4-handle-edge-cases",level:3},{value:"Common Use Cases",id:"common-use-cases",level:2},{value:"1. Modal Dialogs",id:"1-modal-dialogs",level:3},{value:"2. Navigation Menus",id:"2-navigation-menus",level:3},{value:"3. Help Overlays",id:"3-help-overlays",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Hidden State Not Found",id:"hidden-state-not-found",level:3},{value:"Multiple States Claiming to be Active",id:"multiple-states-claiming-to-be-active",level:3},{value:"Transition Loops",id:"transition-loops",level:3},{value:"Related Documentation",id:"related-documentation",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"dynamic-transitions-and-hidden-states",children:"Dynamic Transitions and Hidden States"})}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsxs)(n.p,{children:["A common challenge in GUI automation is dealing with dynamic overlays like menus, dialogs, and pop-ups that can appear at any time and cover other UI elements. Brobot handles this elegantly through its ",(0,s.jsx)(n.strong,{children:"Hidden States"})," mechanism and ",(0,s.jsx)(n.strong,{children:"Dynamic Transitions"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"the-problem",children:"The Problem"}),"\n",(0,s.jsx)(n.p,{children:"Consider a typical application with:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"A main window with various screens (Home, Settings, Profile, etc.)"}),"\n",(0,s.jsx)(n.li,{children:"A menu that can be opened from any screen"}),"\n",(0,s.jsx)(n.li,{children:"Dialogs that can appear over any state"}),"\n",(0,s.jsx)(n.li,{children:"Pop-ups that temporarily cover content"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"When a menu opens over the Settings screen, the Settings state becomes temporarily inaccessible. When the menu is closed, you want to return to Settings. But what if the menu was opened from the Home screen instead? The same action that transitions from Menu to Settings would also transition from Menu to Home. If transitions were hard-coded, it would create ambiguity in the pathfinding algorithm."}),"\n",(0,s.jsx)(n.h2,{id:"the-solution-hidden-states",children:"The Solution: Hidden States"}),"\n",(0,s.jsx)(n.p,{children:"Brobot solves this with the Hidden States mechanism:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Automatic Registration"}),': When a state opens and covers another, the covered state is automatically registered as "hidden"']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Dynamic Tracking"}),": The framework maintains a stack of hidden states for each active state"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Smart Navigation"}),": Special dynamic transitions can navigate back to the most recently hidden state"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"how-hidden-states-work",children:"How Hidden States Work"}),"\n",(0,s.jsx)(n.h3,{id:"state-registration",children:"State Registration"}),"\n",(0,s.jsx)(n.p,{children:"When a state becomes active and covers another state, Brobot:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Detects which states are now covered"}),"\n",(0,s.jsxs)(n.li,{children:["Registers them in the covering state's ",(0,s.jsx)(n.code,{children:"hiddenStates"})," field"]}),"\n",(0,s.jsx)(n.li,{children:"Maintains this information until the covering state is closed"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"// Example: When MenuState opens, it registers what it covered\npublic class MenuState extends State {\n    // The framework automatically tracks what this menu is covering\n    // This could be HomeState, SettingsState, or any other state\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"the-previous-transition-target",children:"The PREVIOUS Transition Target"}),"\n",(0,s.jsxs)(n.p,{children:["Instead of defining static transitions to every possible state, you can use the special ",(0,s.jsx)(n.code,{children:"PREVIOUS"})," target:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'// Traditional approach - needs many transitions\n@Transition(from = MenuState.class, to = HomeState.class)\n@Transition(from = MenuState.class, to = SettingsState.class)\n@Transition(from = MenuState.class, to = ProfileState.class)\n// ... many more\n\n// Dynamic approach - one transition handles all cases\n@Transition(\n    from = MenuState.class,\n    to = PreviousState.class,  // Special marker for dynamic transitions\n    description = "Close menu and return to whatever was underneath"\n)\n'})}),"\n",(0,s.jsx)(n.h2,{id:"implementation-examples",children:"Implementation Examples"}),"\n",(0,s.jsx)(n.h3,{id:"modern-approach-with-transition",children:"Modern Approach with @Transition"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'import io.github.jspinak.brobot.state.PreviousState;\n\n@Transition(\n    from = MenuState.class,\n    to = PreviousState.class,\n    description = "Close menu and return to previous state"\n)\n@RequiredArgsConstructor\npublic class CloseMenuTransition {\n    private final MenuState menuState;\n    private final Action action;\n    \n    public boolean execute() {\n        // Close the menu\n        if (action.click(menuState.getCloseButton()).isSuccess()) {\n            return true;\n        }\n        \n        // Fallback: press ESC\n        return action.type(new ObjectCollection.Builder()\n            .withStrings("\\u001B")\n            .build()).isSuccess();\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"traditional-approach-with-statetransitions",children:"Traditional Approach with StateTransitions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"public class MenuTransitions {\n    public StateTransitions getStateTransitions() {\n        return new StateTransitions.Builder(MENU)\n            .addTransition(new StateTransition.Builder()\n                .addToActivate(PREVIOUS)  // Dynamic target\n                .setFunction(this::closeMenu)\n                .build())\n            .build();\n    }\n    \n    private boolean closeMenu() {\n        // Implementation to close the menu\n        return action.click(closeButton).isSuccess();\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"advanced-patterns",children:"Advanced Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"multi-level-overlays",children:"Multi-Level Overlays"}),"\n",(0,s.jsx)(n.p,{children:"Hidden states can be nested. For example:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"User is in Settings"}),"\n",(0,s.jsx)(n.li,{children:"Opens Menu (Settings becomes hidden)"}),"\n",(0,s.jsx)(n.li,{children:"Opens Help Dialog from Menu (Menu becomes hidden)"}),"\n",(0,s.jsx)(n.li,{children:"Closing Help returns to Menu"}),"\n",(0,s.jsx)(n.li,{children:"Closing Menu returns to Settings"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"// Each overlay maintains its own hidden state information\n@Transition(from = HelpDialog.class, to = PreviousState.class)\npublic class CloseHelpTransition {\n    // Returns to Menu if opened from Menu\n}\n\n@Transition(from = MenuState.class, to = PreviousState.class)\npublic class CloseMenuTransition {\n    // Returns to Settings or whatever was underneath\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"conditional-hidden-states",children:"Conditional Hidden States"}),"\n",(0,s.jsx)(n.p,{children:"Sometimes you want to return to a previous state only under certain conditions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"@Transition(from = ErrorDialog.class, to = PreviousState.class)\n@RequiredArgsConstructor\npublic class ErrorRecoveryTransition {\n    private final ErrorDialog errorDialog;\n    private final Action action;\n    private final StateMemory stateMemory;\n    \n    public boolean execute() {\n        // Check if error is recoverable\n        if (errorDialog.isRecoverable()) {\n            // Dismiss and return to previous state\n            action.click(errorDialog.getDismissButton());\n            return true;\n        } else {\n            // Critical error - go to home instead\n            action.click(errorDialog.getHomeButton());\n            return false;  // Don't use PREVIOUS\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"combining-with-state-verification",children:"Combining with State Verification"}),"\n",(0,s.jsx)(n.p,{children:"Ensure the hidden state is still valid before returning:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"@Transition(from = PopupState.class, to = PreviousState.class)\npublic class SmartPopupCloseTransition {\n    \n    public boolean execute() {\n        // Close the popup\n        action.click(closeButton);\n        \n        // Wait for popup to disappear\n        action.vanish(popupElement);\n        \n        // The framework will verify the previous state is active\n        // If not, it will trigger appropriate recovery transitions\n        return true;\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"framework-components",children:"Framework Components"}),"\n",(0,s.jsx)(n.h3,{id:"sethiddenstates",children:"SetHiddenStates"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"SetHiddenStates"})," service manages the registration and tracking of hidden states:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"@Component\npublic class SetHiddenStates {\n    // Automatically invoked by the framework when states change\n    public void setHiddenStates(State coveringState, Set<State> coveredStates) {\n        // Registers which states are hidden by the covering state\n    }\n    \n    public Set<State> getHiddenStates(State state) {\n        // Returns the states hidden by this state\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"statememory",children:"StateMemory"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"StateMemory"})," service maintains the history of state transitions and hidden states:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'@Component\npublic class StateMemory {\n    // Tracks the sequence of state activations\n    // Used to determine the "previous" state for dynamic transitions\n    \n    public Optional<State> getPreviousState() {\n        // Returns the most recently hidden state\n    }\n    \n    public void recordStateChange(State from, State to) {\n        // Updates the state history\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"1-use-for-true-overlays",children:"1. Use for True Overlays"}),"\n",(0,s.jsx)(n.p,{children:"Dynamic transitions work best for UI elements that truly overlay others:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Modal dialogs"}),"\n",(0,s.jsx)(n.li,{children:"Dropdown menus"}),"\n",(0,s.jsx)(n.li,{children:"Pop-up notifications"}),"\n",(0,s.jsx)(n.li,{children:"Sidebars that slide over content"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"2-provide-fallbacks",children:"2. Provide Fallbacks"}),"\n",(0,s.jsx)(n.p,{children:"Always have a fallback plan if the dynamic transition fails:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"@Transition(from = MenuState.class, to = PreviousState.class, priority = 1)\npublic class CloseMenuToPrevious {\n    // Primary: try to return to previous\n}\n\n@Transition(from = MenuState.class, to = HomeState.class, priority = 2)\npublic class CloseMenuToHome {\n    // Fallback: go to home if previous fails\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-clear-visual-indicators",children:"3. Clear Visual Indicators"}),"\n",(0,s.jsx)(n.p,{children:"Ensure overlays have clear visual indicators for state detection:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"public class DialogState extends State {\n    @StateImage\n    private StateImage dialogHeader;  // Unique to this dialog\n    \n    @StateImage\n    private StateImage darkOverlay;   // Common overlay indicator\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"4-handle-edge-cases",children:"4. Handle Edge Cases"}),"\n",(0,s.jsx)(n.p,{children:"Consider edge cases in your transitions:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"What if the previous state no longer exists?"}),"\n",(0,s.jsx)(n.li,{children:"What if multiple overlays are stacked?"}),"\n",(0,s.jsx)(n.li,{children:"What if the application crashed and restarted?"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'@Transition(from = MenuState.class, to = PreviousState.class)\npublic class RobustMenuClose {\n    \n    public boolean execute() {\n        // Try to close menu\n        if (!action.click(closeButton).isSuccess()) {\n            // Fallback 1: ESC key\n            action.type("\\u001B");\n        }\n        \n        // Verify menu is gone\n        if (action.vanish(menuElement).isSuccess()) {\n            return true;  // Let framework handle PREVIOUS\n        }\n        \n        // Menu still visible - force navigation\n        log.warn("Menu failed to close, forcing home navigation");\n        return action.click(homeButton).isSuccess();\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"common-use-cases",children:"Common Use Cases"}),"\n",(0,s.jsx)(n.h3,{id:"1-modal-dialogs",children:"1. Modal Dialogs"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"@State\npublic class ConfirmDialog extends State {\n    // This dialog can appear over any state\n}\n\n@Transition(from = ConfirmDialog.class, to = PreviousState.class)\npublic class ConfirmDialogHandler {\n    public boolean execute() {\n        // Handle confirm/cancel and return to whatever was underneath\n        return action.click(confirmButton).isSuccess();\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-navigation-menus",children:"2. Navigation Menus"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"@State\npublic class NavigationMenu extends State {\n    // Hamburger menu that slides over content\n}\n\n@Transition(from = NavigationMenu.class, to = PreviousState.class)\npublic class CloseNavMenu {\n    public boolean execute() {\n        // Swipe or click to close menu\n        return action.click(menuOverlay).isSuccess();\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-help-overlays",children:"3. Help Overlays"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'@State\npublic class HelpOverlay extends State {\n    // Tutorial or help screens that overlay the application\n}\n\n@Transition(from = HelpOverlay.class, to = PreviousState.class)\npublic class DismissHelp {\n    public boolean execute() {\n        // Click "Got it" or press ESC\n        return action.click(gotItButton).isSuccess();\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,s.jsx)(n.h3,{id:"hidden-state-not-found",children:"Hidden State Not Found"}),"\n",(0,s.jsx)(n.p,{children:"If a dynamic transition fails to find the previous state:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Check that states are properly detecting overlays"}),"\n",(0,s.jsx)(n.li,{children:"Verify StateImage definitions don't overlap incorrectly"}),"\n",(0,s.jsx)(n.li,{children:"Ensure the covering state is properly registered"}),"\n",(0,s.jsx)(n.li,{children:"Check logs for state transition history"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"multiple-states-claiming-to-be-active",children:"Multiple States Claiming to be Active"}),"\n",(0,s.jsx)(n.p,{children:"This can happen with poor state definition:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Make StateImages more specific"}),"\n",(0,s.jsx)(n.li,{children:"Use unique identifiers for each state"}),"\n",(0,s.jsx)(n.li,{children:"Adjust pattern matching thresholds"}),"\n",(0,s.jsx)(n.li,{children:"Consider using state priorities"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"transition-loops",children:"Transition Loops"}),"\n",(0,s.jsx)(n.p,{children:"Prevent infinite loops between states:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Use transition priorities"}),"\n",(0,s.jsx)(n.li,{children:"Implement maximum retry counts"}),"\n",(0,s.jsx)(n.li,{children:"Add cooldown periods between transitions"}),"\n",(0,s.jsx)(n.li,{children:"Log and monitor transition patterns"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/getting-started/transitions",children:"Transitions Overview"})," - General transition concepts"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/getting-started/core-concepts#handling-dynamic-overlays-hidden-states",children:"Core Concepts"})," - Brief hidden states overview"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/getting-started/states",children:"States Overview"})," - Understanding states in Brobot"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/core-library/guides/state-aware-scheduling",children:"State-Aware Scheduling"})," - Advanced state scheduling patterns"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);
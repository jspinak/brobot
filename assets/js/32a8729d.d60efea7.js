"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1271],{28453:(n,t,e)=>{e.d(t,{R:()=>s,x:()=>a});var i=e(96540);const r={},o=i.createContext(r);function s(n){const t=i.useContext(o);return i.useMemo(function(){return"function"==typeof n?n(t):{...t,...n}},[t,n])}function a(n){let t;return t=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:s(n.components),i.createElement(o.Provider,{value:t},n.children)}},31090:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"core-library/tutorials/tutorial-claude-automator/transitions","title":"Implementing Transitions with @TransitionSet","description":"Overview","source":"@site/docs/03-core-library/tutorials/tutorial-claude-automator/transitions.md","sourceDirName":"03-core-library/tutorials/tutorial-claude-automator","slug":"/core-library/tutorials/tutorial-claude-automator/transitions","permalink":"/brobot/docs/core-library/tutorials/tutorial-claude-automator/transitions","draft":false,"unlisted":false,"editUrl":"https://github.com/jspinak/brobot/edit/main/docs/docs/03-core-library/tutorials/tutorial-claude-automator/transitions.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docSidebar","previous":{"title":"Creating States with Annotations","permalink":"/brobot/docs/core-library/tutorials/tutorial-claude-automator/states"},"next":{"title":"Tutorial: Mr.doob","permalink":"/brobot/docs/core-library/tutorials/tutorial-mrdoob/intro"}}');var r=e(74848),o=e(28453);const s={},a="Implementing Transitions with @TransitionSet",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Modern Approach: Unified Transition Classes",id:"modern-approach-unified-transition-classes",level:2},{value:"PromptTransitions.java",id:"prompttransitionsjava",level:3},{value:"WorkingTransitions.java",id:"workingtransitionsjava",level:3},{value:"Key Features of @TransitionSet",id:"key-features-of-transitionset",level:2},{value:"1. <strong>Unified Class Structure</strong>",id:"1-unified-class-structure",level:3},{value:"2. <strong>Clear Annotations</strong>",id:"2-clear-annotations",level:3},{value:"3. <strong>Mock Mode Support</strong>",id:"3-mock-mode-support",level:3},{value:"Action Chaining Pattern",id:"action-chaining-pattern",level:2},{value:"Comparison: Old vs New",id:"comparison-old-vs-new",level:2},{value:"Old Approach (Pre-1.2.0)",id:"old-approach-pre-120",level:3},{value:"New Approach (1.2.0+)",id:"new-approach-120",level:3},{value:"File Organization",id:"file-organization",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Benefits of @TransitionSet Approach",id:"benefits-of-transitionset-approach",level:2},{value:"Testing Transitions",id:"testing-transitions",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(n){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"implementing-transitions-with-transitionset",children:"Implementing Transitions with @TransitionSet"})}),"\n",(0,r.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(t.p,{children:"Transitions define how to navigate between states. With the new @TransitionSet annotation system (Brobot 1.2.0+), all transitions for a state are grouped together in a single class, providing better organization and clearer intent."}),"\n",(0,r.jsx)(t.h2,{id:"modern-approach-unified-transition-classes",children:"Modern Approach: Unified Transition Classes"}),"\n",(0,r.jsx)(t.h3,{id:"prompttransitionsjava",children:"PromptTransitions.java"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:'// Note: BrobotProperties must be injected as a dependency\n@Autowired\nprivate BrobotProperties brobotProperties;\n\npackage com.claude.automator.transitions;\n\nimport org.springframework.stereotype.Component;\nimport com.claude.automator.states.PromptState;\nimport com.claude.automator.states.WorkingState;\nimport io.github.jspinak.brobot.action.Action;\nimport io.github.jspinak.brobot.annotations.FromTransition;\nimport io.github.jspinak.brobot.annotations.IncomingTransition;\nimport io.github.jspinak.brobot.annotations.TransitionSet;\nimport lombok.RequiredArgsConstructor;\nimport lombok.extern.slf4j.Slf4j;\n\n/**\n * All transitions for the Prompt state.\n * Contains FromTransitions from other states TO Prompt,\n * and a IncomingTransition to verify arrival at Prompt.\n */\n@TransitionSet(state = PromptState.class, description = "Claude Prompt state transitions")\n@Component\n@RequiredArgsConstructor\n@Slf4j\npublic class PromptTransitions {\n    \n    private final PromptState promptState;\n    private final WorkingState workingState;\n    private final Action action;\n    \n    /**\n     * Navigate from Working state back to Prompt.\n     * This occurs when Claude finishes processing and returns to the prompt.\n     */\n    @FromTransition(from = WorkingState.class, priority = 1, description = "Return from Working to Prompt")\n    public boolean fromWorking() {\n        log.info("Navigating from Working to Prompt");\n        \n        // In mock mode, just return true for testing\n        if (io.github.jspinak.brobot.config.core.brobotProperties.getCore().isMock()) {\n            log.info("Mock mode: simulating successful navigation");\n            return true;\n        }\n        \n        // Wait for Claude to finish processing and return to prompt\n        // This might involve waiting for the working indicator to disappear\n        return action.find(promptState.getClaudePrompt()).isSuccess();\n    }\n    \n    /**\n     * Verify that we have successfully arrived at the Prompt state.\n     * Checks for the presence of the Claude prompt input area.\n     */\n    @IncomingTransition(description = "Verify arrival at Prompt state", required = true)\n    public boolean verifyArrival() {\n        log.info("Verifying arrival at Prompt state");\n        \n        // In mock mode, just return true for testing\n        if (io.github.jspinak.brobot.config.core.brobotProperties.getCore().isMock()) {\n            log.info("Mock mode: simulating successful verification");\n            return true;\n        }\n        \n        // Check for presence of prompt-specific elements\n        boolean foundPrompt = action.find(promptState.getClaudePrompt()).isSuccess();\n        \n        if (foundPrompt) {\n            log.info("Successfully confirmed Prompt state is active");\n            return true;\n        } else {\n            log.error("Failed to confirm Prompt state - prompt elements not found");\n            return false;\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(t.h3,{id:"workingtransitionsjava",children:"WorkingTransitions.java"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:'package com.claude.automator.transitions;\n\nimport org.springframework.stereotype.Component;\nimport com.claude.automator.states.PromptState;\nimport com.claude.automator.states.WorkingState;\nimport io.github.jspinak.brobot.action.Action;\nimport io.github.jspinak.brobot.action.ActionResult;\nimport io.github.jspinak.brobot.action.ObjectCollection;\nimport io.github.jspinak.brobot.action.basic.click.ClickOptions;\nimport io.github.jspinak.brobot.action.basic.find.PatternFindOptions;\nimport io.github.jspinak.brobot.action.basic.type.TypeOptions;\nimport io.github.jspinak.brobot.annotations.FromTransition;\nimport io.github.jspinak.brobot.annotations.IncomingTransition;\nimport io.github.jspinak.brobot.annotations.TransitionSet;\nimport lombok.RequiredArgsConstructor;\nimport lombok.extern.slf4j.Slf4j;\n\n/**\n * All transitions for the Working state.\n * Contains FromTransitions from other states TO Working,\n * and a IncomingTransition to verify arrival at Working.\n */\n@TransitionSet(state = WorkingState.class, description = "Claude Working state transitions")\n@Component\n@RequiredArgsConstructor\n@Slf4j\npublic class WorkingTransitions {\n    \n    private final PromptState promptState;\n    private final WorkingState workingState;\n    private final Action action;\n    \n    /**\n     * Navigate from Prompt to Working by submitting a command.\n     * This transition occurs when the user submits a prompt and Claude begins processing.\n     */\n    @FromTransition(from = PromptState.class, priority = 1, description = "Submit prompt to start working")\n    public boolean fromPrompt() {\n        try {\n            log.info("Navigating from Prompt to Working");\n            \n            // In mock mode, just return true for testing\n            if (io.github.jspinak.brobot.config.core.brobotProperties.getCore().isMock()) {\n                log.info("Mock mode: simulating successful navigation");\n                return true;\n            }\n\n            // Using the fluent API to chain actions: find -> click -> type\n            PatternFindOptions findClickType = new PatternFindOptions.Builder()\n                    .setPauseAfterEnd(0.5) // Pause before clicking\n                    .then(new ClickOptions.Builder()\n                            .setPauseAfterEnd(0.5) // Pause before typing\n                            .build())\n                    .then(new TypeOptions.Builder()\n                            .build())\n                    .build();\n\n            // Create target objects for the chained action\n            ObjectCollection target = new ObjectCollection.Builder()\n                    .withImages(promptState.getClaudePrompt()) // For find & click\n                    .withStrings(promptState.getContinueCommand()) // For type (continue with Enter)\n                    .build();\n\n            // Execute the chained action\n            ActionResult result = action.perform(findClickType, target);\n\n            if (result.isSuccess()) {\n                log.info("Successfully triggered transition from Prompt to Working");\n                return true;\n            } else {\n                log.warn("Failed to execute transition: {}", result.getActionDescription());\n                return false;\n            }\n\n        } catch (Exception e) {\n            log.error("Error during Prompt to Working transition", e);\n            return false;\n        }\n    }\n    \n    /**\n     * Verify that we have successfully arrived at the Working state.\n     * Checks for the presence of the working indicator.\n     */\n    @IncomingTransition(description = "Verify arrival at Working state", required = true)\n    public boolean verifyArrival() {\n        log.info("Verifying arrival at Working state");\n        \n        // In mock mode, just return true for testing\n        if (io.github.jspinak.brobot.config.core.brobotProperties.getCore().isMock()) {\n            log.info("Mock mode: simulating successful verification");\n            return true;\n        }\n        \n        // Check for presence of working-specific elements\n        boolean foundWorkingIndicator = action.find(workingState.getWorkingIndicator()).isSuccess();\n        \n        if (foundWorkingIndicator) {\n            log.info("Successfully confirmed Working state is active");\n            return true;\n        } else {\n            log.error("Failed to confirm Working state - working indicator not found");\n            return false;\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(t.h2,{id:"key-features-of-transitionset",children:"Key Features of @TransitionSet"}),"\n",(0,r.jsxs)(t.h3,{id:"1-unified-class-structure",children:["1. ",(0,r.jsx)(t.strong,{children:"Unified Class Structure"})]}),"\n",(0,r.jsx)(t.p,{children:"All transitions for a state are in ONE class:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"@FromTransition"})," methods define how to get TO this state FROM other states"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"@IncomingTransition"})," method (only ONE per class) verifies arrival at this state"]}),"\n"]}),"\n",(0,r.jsxs)(t.h3,{id:"2-clear-annotations",children:["2. ",(0,r.jsx)(t.strong,{children:"Clear Annotations"})]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:'@TransitionSet(state = TargetState.class, description = "Documentation")\n'})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"state"}),": The state these transitions belong to (required)"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"description"}),": Optional documentation"]}),"\n"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:'@FromTransition(from = SourceState.class, priority = 1, description = "Navigation logic")\n'})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"from"}),": The source state (required)"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"priority"}),": Higher values are preferred when multiple paths exist"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"description"}),": Optional documentation"]}),"\n"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:'@IncomingTransition(description = "Verification logic", required = true)\n'})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"required"}),": Whether verification must succeed (default: false)"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"description"}),": Optional documentation"]}),"\n"]}),"\n",(0,r.jsxs)(t.h3,{id:"3-mock-mode-support",children:["3. ",(0,r.jsx)(t.strong,{children:"Mock Mode Support"})]}),"\n",(0,r.jsx)(t.p,{children:"Always include mock mode checks for testing:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:'@FromTransition(from = SourceState.class)\npublic boolean fromSource() {\n    if (io.github.jspinak.brobot.config.core.brobotProperties.getCore().isMock()) {\n        log.info("Mock mode: simulating successful navigation");\n        return true;\n    }\n    // Real navigation logic\n    return action.click(element).isSuccess();\n}\n'})}),"\n",(0,r.jsx)(t.h2,{id:"action-chaining-pattern",children:"Action Chaining Pattern"}),"\n",(0,r.jsx)(t.p,{children:"The fluent API enables elegant action sequences:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"// Chain multiple actions in sequence\nPatternFindOptions chainedAction = new PatternFindOptions.Builder()\n    .setPauseAfterEnd(0.5)              // Wait after finding\n    .then(new ClickOptions.Builder()\n            .setPauseAfterEnd(0.5)       // Wait after clicking\n            .build())\n    .then(new TypeOptions.Builder()\n            .build())                     // Type text\n    .build();\n\n// Execute all actions in sequence\nActionResult result = action.perform(chainedAction, target);\n"})}),"\n",(0,r.jsx)(t.h2,{id:"comparison-old-vs-new",children:"Comparison: Old vs New"}),"\n",(0,r.jsx)(t.h3,{id:"old-approach-pre-120",children:"Old Approach (Pre-1.2.0)"}),"\n",(0,r.jsx)(t.p,{children:"Multiple separate transition classes:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"// Separate file for each transition\n@Transition(from = PromptState.class, to = WorkingState.class)\npublic class PromptToWorkingTransition {\n    public boolean execute() {\n        return action.click(promptState.getButton()).isSuccess();\n    }\n}\n\n// Another separate file\n@Transition(from = WorkingState.class, to = PromptState.class)\npublic class WorkingToPromptTransition {\n    public boolean execute() {\n        return action.wait(5).isSuccess();\n    }\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"new-approach-120",children:"New Approach (1.2.0+)"}),"\n",(0,r.jsx)(t.p,{children:"All transitions for a state in ONE class:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"@TransitionSet(state = WorkingState.class)\n@Component\npublic class WorkingTransitions {\n    \n    @FromTransition(from = PromptState.class, priority = 1)\n    public boolean fromPrompt() {\n        if (brobotProperties.getCore().isMock()) return true;\n        return action.click(promptState.getButton()).isSuccess();\n    }\n    \n    @IncomingTransition(required = true)\n    public boolean verifyArrival() {\n        if (brobotProperties.getCore().isMock()) return true;\n        return action.find(workingState.getIndicator()).isSuccess();\n    }\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"file-organization",children:"File Organization"}),"\n",(0,r.jsx)(t.p,{children:"Organize your transitions alongside states:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"src/main/java/com/claude/automator/\n\u251c\u2500\u2500 states/\n\u2502   \u251c\u2500\u2500 PromptState.java\n\u2502   \u2514\u2500\u2500 WorkingState.java\n\u2514\u2500\u2500 transitions/\n    \u251c\u2500\u2500 PromptTransitions.java    # All transitions for Prompt state\n    \u2514\u2500\u2500 WorkingTransitions.java   # All transitions for Working state\n"})}),"\n",(0,r.jsx)(t.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Use Required Annotations"}),":"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"@TransitionSet(state = MyState.class)\n@Component                    // For Spring dependency injection\n@RequiredArgsConstructor      // For constructor injection\n@Slf4j                       // For logging\n"})}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Descriptive Method Names"}),": Use ",(0,r.jsx)(t.code,{children:"fromStateName()"})," pattern for clarity"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Mock Mode Support"}),": Always include mock mode checks for testing"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Handle Failures Gracefully"}),":"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:'@FromTransition(from = SourceState.class)\npublic boolean fromSource() {\n    try {\n        // Transition logic\n        return action.click("button").isSuccess();\n    } catch (Exception e) {\n        log.error("Transition failed", e);\n        return false;\n    }\n}\n'})}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Log Appropriately"}),": Info for success, warn for expected failures, error for exceptions"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"benefits-of-transitionset-approach",children:"Benefits of @TransitionSet Approach"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Better Organization"}),": All transitions for a state in ONE place"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Clearer Intent"}),": FromTransitions vs IncomingTransition makes flow obvious"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Less Boilerplate"}),": No manual StateTransitions builders"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Compile-Time Safety"}),": IDE immediately shows if states don't exist"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Easier Testing"}),": Each transition method can be tested independently"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Natural Structure"}),": File organization mirrors state structure"]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"testing-transitions",children:"Testing Transitions"}),"\n",(0,r.jsx)(t.p,{children:"The new format makes testing straightforward:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"@ExtendWith(SpringExtension.class)\n@ContextConfiguration(classes = {TestConfiguration.class})\npublic class WorkingTransitionsTest {\n    \n    @Autowired\n    private WorkingTransitions workingTransitions;\n    \n    @MockBean\n    private Action action;\n    \n    @Test\n    public void testFromPromptTransition() {\n        // Given\n        when(action.perform(any(), any()))\n            .thenReturn(new ActionResult.Builder().setSuccess(true).build());\n        \n        // When\n        boolean result = workingTransitions.fromPrompt();\n        \n        // Then\n        assertTrue(result);\n    }\n    \n    @Test\n    public void testVerifyArrival() {\n        // Given\n        when(action.find(any()))\n            .thenReturn(new ActionResult.Builder().setSuccess(true).build());\n        \n        // When\n        boolean arrived = workingTransitions.verifyArrival();\n        \n        // Then\n        assertTrue(arrived);\n    }\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsx)(t.p,{children:"With states and transitions defined using @TransitionSet annotations, the entire state machine is automatically configured. The framework handles all registration and wiring - you just focus on your automation logic!"})]})}function u(n={}){const{wrapper:t}={...(0,o.R)(),...n.components};return t?(0,r.jsx)(t,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}}}]);
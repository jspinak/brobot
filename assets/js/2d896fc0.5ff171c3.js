"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8365],{28453:(n,i,t)=>{t.d(i,{R:()=>r,x:()=>a});var e=t(96540);const s={},o=e.createContext(s);function r(n){const i=e.useContext(o);return e.useMemo(function(){return"function"==typeof n?n(i):{...i,...n}},[i,n])}function a(n){let i;return i=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:r(n.components),e.createElement(o.Provider,{value:i},n.children)}},43607:(n,i,t)=>{t.d(i,{A:()=>e});const e=t.p+"assets/images/transitions-c388f3c755a4df88c4c15f76e021e687.png"},91768:(n,i,t)=>{t.r(i),t.d(i,{assets:()=>c,contentTitle:()=>a,default:()=>g,frontMatter:()=>r,metadata:()=>e,toc:()=>l});const e=JSON.parse('{"id":"getting-started/transitions","title":"Transitions","description":"Introduction","source":"@site/docs/01-getting-started/transitions.md","sourceDirName":"01-getting-started","slug":"/getting-started/transitions","permalink":"/brobot/docs/getting-started/transitions","draft":false,"unlisted":false,"editUrl":"https://github.com/jspinak/brobot/edit/main/docs/docs/01-getting-started/transitions.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Transitions"},"sidebar":"docSidebar","previous":{"title":"States","permalink":"/brobot/docs/getting-started/states"},"next":{"title":"The Action Hierarchy","permalink":"/brobot/docs/getting-started/action-hierarchy"}}');var s=t(74848),o=t(28453);const r={sidebar_position:4,title:"Transitions"},a="Transitions",c={},l=[{value:"Introduction",id:"introduction",level:2},{value:"The Brobot Implementation: IncomingTransition and OutgoingTransition",id:"the-brobot-implementation-incomingtransition-and-outgoingtransition",level:2},{value:"Using @TransitionSet Annotation",id:"using-transitionset-annotation",level:2},{value:"Complete Example",id:"complete-example",level:3},{value:"Annotation Types",id:"annotation-types",level:3},{value:"@TransitionSet",id:"transitionset",level:4},{value:"@IncomingTransition",id:"incomingtransition",level:4},{value:"@OutgoingTransition",id:"outgoingtransition",level:4},{value:"World State Example",id:"world-state-example",level:2},{value:"Key Benefits of This Pattern",id:"key-benefits-of-this-pattern",level:2},{value:"File Organization",id:"file-organization",level:2},{value:"Complex Transitions with Action Chains",id:"complex-transitions-with-action-chains",level:2},{value:"The Formal Model (Under the Hood)",id:"the-formal-model-under-the-hood",level:2},{value:"Dynamic Transitions for Hidden States",id:"dynamic-transitions-for-hidden-states",level:2},{value:"Testing Transitions",id:"testing-transitions",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Summary",id:"summary",level:2}];function d(n){const i={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"transitions",children:"Transitions"})}),"\n",(0,s.jsx)(i.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsxs)(i.p,{children:['While States define "where you can be" in a GUI, ',(0,s.jsx)(i.strong,{children:"Transitions"}),' define "how you get there." Every State that is reachable needs an associated transitions class that defines the pathways to and from other states.']}),"\n",(0,s.jsx)(i.p,{children:'Formally, a transition is a process or a sequence of actions that changes the GUI from one state to another. They form the "edges" of the state graph and are the building blocks used by the framework\'s pathfinder to navigate the application.'}),"\n",(0,s.jsx)(i.h2,{id:"the-brobot-implementation-incomingtransition-and-outgoingtransition",children:"The Brobot Implementation: IncomingTransition and OutgoingTransition"}),"\n",(0,s.jsx)(i.p,{children:"Brobot implements transitions using a cohesive pattern where each state's transition class contains:"}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.img,{alt:"Transition Diagram",src:t(43607).A+"",width:"623",height:"196"}),"\n",(0,s.jsx)(i.em,{children:"This diagram is based on Figure 8 from the research paper."})]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"IncomingTransition"}),": This verifies successful arrival at the state, regardless of which state initiated the transition. There is only one IncomingTransition per state, and it contains checks to confirm the state is active."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"OutgoingTransition"}),": These handle navigation FROM the current state TO other states. Since these transitions use the current state's images and UI elements, grouping them in the state's transition class creates better cohesion. Each OutgoingTransition contains the specific actions needed to navigate to a target state."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"using-transitionset-annotation",children:"Using @TransitionSet Annotation"}),"\n",(0,s.jsx)(i.p,{children:"Brobot uses a cohesive, method-level annotation approach that groups all transitions for a state in one class. Each transition class contains:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"The IncomingTransition to verify arrival at the state"}),"\n",(0,s.jsx)(i.li,{children:"All OutgoingTransitions that navigate FROM this state to other states"}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"This pattern maintains high cohesion since outgoing transitions use the current state's images."}),"\n",(0,s.jsx)(i.h3,{id:"complete-example",children:"Complete Example"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-java",children:'// Note: BrobotProperties must be injected as a dependency\n@Autowired\nprivate BrobotProperties brobotProperties;\n\n@TransitionSet(state = PricingState.class, description = "Pricing page transitions")\n@RequiredArgsConstructor\n@Slf4j\npublic class PricingTransitions {\n\n    private final PricingState pricingState;\n    private final Action action;\n    \n    /**\n     * Verify that we have successfully arrived at the Pricing state.\n     * Checks for the presence of pricing-specific elements.\n     */\n    @IncomingTransition(description = "Verify arrival at Pricing state", required = true)\n    public boolean verifyArrival() {\n        log.info("Verifying arrival at Pricing state");\n        // In mock mode, just return true for testing\n        if (io.github.jspinak.brobot.config.core.brobotProperties.getCore().isMock()) {\n            log.info("Mock mode: simulating successful verification");\n            return true;\n        }\n\n        boolean found = action.find(pricingState.getStartForFreeButton()).isSuccess();\n\n        if (found) {\n            log.info("Successfully confirmed Pricing state is active");\n            return true;\n        } else {\n            log.error("Failed to confirm Pricing state - button not found");\n            return false;\n        }\n    }\n\n    /**\n     * Navigate from Pricing to Homepage by clicking the home/logo button.\n     */\n    @OutgoingTransition(to = HomepageState.class, priority = 1, description = "Navigate from Pricing to Homepage")\n    public boolean toHomepage() {\n        log.info("Navigating from Pricing to Homepage");\n        // In mock mode, just return true for testing\n        if (io.github.jspinak.brobot.config.core.brobotProperties.getCore().isMock()) {\n            log.info("Mock mode: simulating successful navigation");\n            return true;\n        }\n        return action.click(pricingState.getHomeLink()).isSuccess();\n    }\n\n    /**\n     * Navigate from Pricing to Menu by clicking the menu icon.\n     */\n    @OutgoingTransition(to = MenuState.class, priority = 2, description = "Navigate from Pricing to Menu")\n    public boolean toMenu() {\n        log.info("Navigating from Pricing to Menu");\n        // In mock mode, just return true for testing\n        if (io.github.jspinak.brobot.config.core.brobotProperties.getCore().isMock()) {\n            log.info("Mock mode: simulating successful navigation");\n            return true;\n        }\n        return action.click(pricingState.getMenuIcon()).isSuccess();\n    }\n}\n'})}),"\n",(0,s.jsx)(i.h3,{id:"annotation-types",children:"Annotation Types"}),"\n",(0,s.jsx)(i.h4,{id:"transitionset",children:"@TransitionSet"}),"\n",(0,s.jsx)(i.p,{children:"Marks a class as containing all transitions for a specific state:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"state"}),": The state class these transitions belong to (required)"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"name"}),': Optional state name override (defaults to class name without "State" suffix)']}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"description"}),": Documentation for the transition set"]}),"\n"]}),"\n",(0,s.jsx)(i.h4,{id:"incomingtransition",children:"@IncomingTransition"}),"\n",(0,s.jsx)(i.p,{children:"Verifies successful arrival at the state:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"description"}),": Documentation for the verification"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"timeout"}),": Verification timeout in seconds (optional)"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"required"}),": Whether verification must succeed (default: false)"]}),"\n"]}),"\n",(0,s.jsx)(i.h4,{id:"outgoingtransition",children:"@OutgoingTransition"}),"\n",(0,s.jsx)(i.p,{children:"Defines a transition FROM the current state TO another state:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"to"}),": The target state class (required)"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"priority"}),": Transition priority - higher values are preferred when multiple paths exist (default: 0)"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"description"}),": Documentation for this transition"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"timeout"}),": Timeout in seconds (optional)"]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"world-state-example",children:"World State Example"}),"\n",(0,s.jsx)(i.p,{children:"Here's another complete example showing transitions for a World state with multiple entry and exit points:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-java",children:'@TransitionSet(state = WorldState.class, description = "World map transitions")\n@RequiredArgsConstructor\n@Slf4j\npublic class WorldTransitions {\n\n    private final WorldState worldState;\n    private final Action action;\n    \n    /**\n     * Verify arrival at World state by checking for the world map.\n     */\n    @IncomingTransition(description = "Verify arrival at World state", required = true)\n    public boolean verifyArrival() {\n        log.info("Verifying arrival at World state");\n        if (io.github.jspinak.brobot.config.core.brobotProperties.getCore().isMock()) {\n            log.info("Mock mode: simulating successful verification");\n            return true;\n        }\n\n        // Check for world-specific elements\n        boolean foundMap = action.find(worldState.getWorldMap()).isSuccess();\n        boolean foundIslands = action.find(worldState.getIsland1()).isSuccess();\n\n        if (foundMap || foundIslands) {\n            log.info("Successfully confirmed World state is active");\n            return true;\n        } else {\n            log.error("Failed to confirm World state - world elements not found");\n            return false;\n        }\n    }\n\n    /**\n     * Navigate from World to Home by clicking the home button.\n     */\n    @OutgoingTransition(to = HomeState.class, priority = 1, description = "Navigate from World to Home")\n    public boolean toHome() {\n        log.info("Navigating from World to Home");\n        if (io.github.jspinak.brobot.config.core.brobotProperties.getCore().isMock()) {\n            log.info("Mock mode: simulating successful navigation");\n            return true;\n        }\n        return action.click(worldState.getHomeButton()).isSuccess();\n    }\n\n    /**\n     * Navigate from World to Island by clicking on an island.\n     */\n    @OutgoingTransition(to = IslandState.class, priority = 2, description = "Navigate from World to Island")\n    public boolean toIsland() {\n        log.info("Navigating from World to Island");\n        if (io.github.jspinak.brobot.config.core.brobotProperties.getCore().isMock()) {\n            log.info("Mock mode: simulating successful navigation");\n            return true;\n        }\n        // Click on first island\n        return action.click(worldState.getIsland1()).isSuccess();\n    }\n}\n'})}),"\n",(0,s.jsx)(i.h2,{id:"key-benefits-of-this-pattern",children:"Key Benefits of This Pattern"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"High Cohesion"}),": Each transition class only needs its own state as a dependency, since outgoing transitions use that state's images"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Clear Separation"}),": IncomingTransition verifies arrival, OutgoingTransitions handle navigation FROM the state"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Natural Organization"}),": File structure mirrors state structure (one transitions class per state)"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Reduced Dependencies"}),": No need to inject other states just for their images in incoming transitions"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Spring Integration"}),": Full dependency injection support (@TransitionSet includes @Component)"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Type Safety"}),": Class-based state references prevent typos and enable IDE refactoring"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Mock Mode Support"}),": Easy to add testing support with framework settings check"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Cleaner Code"}),": Each transition class is self-contained with its state's navigation logic"]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"file-organization",children:"File Organization"}),"\n",(0,s.jsx)(i.p,{children:"Organize transition classes alongside state classes for clarity:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{children:"src/main/java/com/example/app/\n\u251c\u2500\u2500 states/\n\u2502   \u251c\u2500\u2500 HomeState.java\n\u2502   \u251c\u2500\u2500 WorldState.java\n\u2502   \u251c\u2500\u2500 IslandState.java\n\u2502   \u2514\u2500\u2500 PricingState.java\n\u2514\u2500\u2500 transitions/\n    \u251c\u2500\u2500 HomeTransitions.java     # All transitions for Home state\n    \u251c\u2500\u2500 WorldTransitions.java    # All transitions for World state\n    \u251c\u2500\u2500 IslandTransitions.java   # All transitions for Island state\n    \u2514\u2500\u2500 PricingTransitions.java  # All transitions for Pricing state\n"})}),"\n",(0,s.jsx)(i.h2,{id:"complex-transitions-with-action-chains",children:"Complex Transitions with Action Chains"}),"\n",(0,s.jsx)(i.p,{children:"For transitions that require multiple steps, you can chain actions together:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-java",children:'@TransitionSet(state = WorkingState.class, description = "Claude Working state transitions")\n@RequiredArgsConstructor\n@Slf4j\npublic class WorkingTransitions {\n\n    private final WorkingState workingState;\n    private final Action action;\n    \n    @IncomingTransition(required = true)\n    public boolean verifyArrival() {\n        log.info("Verifying arrival at Working state");\n        if (io.github.jspinak.brobot.config.core.brobotProperties.getCore().isMock()) {\n            return true;\n        }\n        return action.find(workingState.getWorkingIndicator()).isSuccess();\n    }\n\n    /**\n     * Navigate from Working to Prompt when work is complete.\n     */\n    @OutgoingTransition(to = PromptState.class, priority = 1)\n    public boolean toPrompt() {\n        try {\n            log.info("Navigating from Working to Prompt");\n\n            if (io.github.jspinak.brobot.config.core.brobotProperties.getCore().isMock()) {\n                return true;\n            }\n\n            // Wait for work to complete and return to prompt\n            // This might involve clicking a button or waiting for the prompt to reappear\n            return action.click(workingState.getStopButton()).isSuccess();\n\n        } catch (Exception e) {\n            log.error("Error during Working to Prompt transition", e);\n            return false;\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(i.h2,{id:"the-formal-model-under-the-hood",children:"The Formal Model (Under the Hood)"}),"\n",(0,s.jsxs)(i.p,{children:["The academic paper provides a formal definition for a transition as a tuple ",(0,s.jsxs)(i.strong,{children:["t = (A, S",(0,s.jsx)("sub",{children:"t"}),(0,s.jsx)("sup",{children:"def"}),")"]}),"."]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"A"})," is a ",(0,s.jsx)(i.strong,{children:"process"}),", which is a sequence of one or more actions ",(0,s.jsx)(i.code,{children:"(a\xb9, a\xb2, ..., a\u207f)"}),". This corresponds to the method body in your @OutgoingTransition methods."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsxs)(i.strong,{children:["S",(0,s.jsx)("sub",{children:"t"}),(0,s.jsx)("sup",{children:"def"})]})," is the ",(0,s.jsx)(i.strong,{children:"intended state information"}),". This is handled automatically by the framework based on the @TransitionSet's state parameter and the @OutgoingTransition's to parameter."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"dynamic-transitions-for-hidden-states",children:"Dynamic Transitions for Hidden States"}),"\n",(0,s.jsx)(i.p,{children:'Brobot supports dynamic transitions to handle common UI patterns like menus and pop-ups. When a state opens and covers another, the covered state is registered as "hidden."'}),"\n",(0,s.jsx)(i.p,{children:"You can define transitions that return to the previous state dynamically:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-java",children:'@TransitionSet(state = MenuState.class, description = "Menu overlay transitions")\n@RequiredArgsConstructor\n@Slf4j\npublic class MenuTransitions {\n    \n    private final MenuState menuState;\n    private final Action action;\n    \n    /**\n     * Close menu and return to whatever state was underneath.\n     * This uses the PREVIOUS special state for dynamic navigation.\n     */\n    @OutgoingTransition(\n        to = io.github.jspinak.brobot.model.state.special.SpecialStateType.PREVIOUS.class,\n        priority = 1,\n        description = "Close menu and return to previous state"\n    )\n    public boolean toPrevious() {\n        log.info("Closing menu to return to previous state");\n        if (io.github.jspinak.brobot.config.core.brobotProperties.getCore().isMock()) {\n            return true;\n        }\n        // Click close button or press ESC\n        return action.click(menuState.getCloseButton()).isSuccess() ||\n               action.type("\\u001B").isSuccess(); // ESC key\n    }\n    \n    @IncomingTransition\n    public boolean verifyArrival() {\n        log.info("Verifying arrival at Menu state");\n        if (io.github.jspinak.brobot.config.core.brobotProperties.getCore().isMock()) {\n            return true;\n        }\n        return action.find(menuState.getMenuHeader()).isSuccess();\n    }\n}\n'})}),"\n",(0,s.jsx)(i.h2,{id:"testing-transitions",children:"Testing Transitions"}),"\n",(0,s.jsx)(i.p,{children:"The new format makes testing easier and more straightforward:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-java",children:"@ExtendWith(SpringExtension.class)\n@ContextConfiguration(classes = {TestConfiguration.class})\npublic class PricingTransitionsTest {\n    \n    @Autowired\n    private PricingTransitions pricingTransitions;\n    \n    @MockBean\n    private Action action;\n    \n    @Test\n    public void testFromMenuTransition() {\n        // Given\n        when(action.click(any())).thenReturn(new ActionResult.Builder().setSuccess(true).build());\n        \n        // When\n        boolean result = pricingTransitions.fromMenu();\n        \n        // Then\n        assertTrue(result);\n        verify(action).click(menuState.getPricingButton());\n    }\n    \n    @Test\n    public void testVerifyArrival() {\n        // Given\n        when(action.find(any())).thenReturn(new ActionResult.Builder().setSuccess(true).build());\n        \n        // When\n        boolean arrived = pricingTransitions.verifyArrival();\n        \n        // Then\n        assertTrue(arrived);\n        verify(action).find(pricingState.getStartForFreeButton());\n    }\n}\n"})}),"\n",(0,s.jsx)(i.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Always include mock mode support"})," for testing environments"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Use descriptive method names"})," like ",(0,s.jsx)(i.code,{children:"toMenu()"}),", ",(0,s.jsx)(i.code,{children:"toHomepage()"})," for outgoing transitions"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Add logging"})," to track navigation flow during debugging"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Verify critical elements"})," in ToTransition to ensure state is truly active"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Set appropriate priorities"})," when multiple paths exist to the same state"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Handle exceptions"})," gracefully in complex transitions"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Keep transitions focused"})," - each method should do one thing well"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Minimize dependencies"})," - each transition class should only need its own state"]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(i.p,{children:"The @TransitionSet pattern with @OutgoingTransition and @IncomingTransition provides a clean, maintainable way to define state transitions in Brobot. By grouping a state's verification logic (IncomingTransition) with its outgoing navigation logic (OutgoingTransition) in a single class, you achieve:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Better cohesion"}),": Outgoing transitions use the current state's images"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Fewer dependencies"}),": Each transition class only needs its own state"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Clearer organization"}),": Navigation logic flows naturally from each state"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Easier maintenance"}),": All transitions for a state are in one place"]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"This pattern makes your automation code easier to understand, test, and maintain."})]})}function g(n={}){const{wrapper:i}={...(0,o.R)(),...n.components};return i?(0,s.jsx)(i,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}}}]);
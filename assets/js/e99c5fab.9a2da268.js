"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7761],{28453:(t,e,n)=>{n.d(e,{R:()=>a,x:()=>r});var i=n(96540);const s={},o=i.createContext(s);function a(t){const e=i.useContext(o);return i.useMemo(function(){return"function"==typeof t?t(e):{...e,...t}},[e,t])}function r(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(s):t.components||s:a(t.components),i.createElement(o.Provider,{value:e},t.children)}},94231:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"theoretical-foundations/transitions","title":"Transitions","description":"Introduction","source":"@site/docs/05-theoretical-foundations/transitions.md","sourceDirName":"05-theoretical-foundations","slug":"/theoretical-foundations/transitions","permalink":"/brobot/docs/theoretical-foundations/transitions","draft":false,"unlisted":false,"editUrl":"https://github.com/jspinak/brobot/edit/main/docs/docs/05-theoretical-foundations/transitions.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"title":"Transitions"},"sidebar":"docSidebar","previous":{"title":"States","permalink":"/brobot/docs/theoretical-foundations/states"},"next":{"title":"Testing the Automation","permalink":"/brobot/docs/theoretical-foundations/testing-automation"}}');var s=n(74848),o=n(28453);const a={sidebar_position:5,title:"Transitions"},r="Transitions",c={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Formal Definition",id:"formal-definition",level:2},{value:"Transitions in Brobot",id:"transitions-in-brobot",level:2},{value:"Implementation",id:"implementation",level:3},{value:"Code Example",id:"code-example",level:3},{value:"The Role of Transitions in Path Traversal",id:"the-role-of-transitions-in-path-traversal",level:2}];function d(t){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...t.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"transitions",children:"Transitions"})}),"\n",(0,s.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(e.p,{children:"In model-based GUI automation, a transition represents the pathway from one state to another. Unlike states, which represent a static configuration of the GUI, transitions define the dynamic sequences of actions that cause the GUI to change. They are a fundamental part of the state structure, forming the edges in the graph of the GUI environment."}),"\n",(0,s.jsx)(e.h2,{id:"formal-definition",children:"Formal Definition"}),"\n",(0,s.jsx)(e.p,{children:"The paper's formal model defines a transition as a tuple t = (A, S<sub>t</sub><sup>def</sup>) where:"}),"\n",(0,s.jsx)(e.p,{children:"A is a process or sequence of actions (a<sup>1</sup>, a<sup>2</sup>, ..., a<sup>n</sup>) that are executed as part of the transition. These are the concrete steps, like clicks and keyboard inputs, that manipulate the GUI.\nS<sub>t</sub><sup>def</sup> is the intended state information that is applied if the transition succeeds. This explicitly defines which states should become active or inactive upon the successful completion of the action sequence.\nThe transition function, f<sub>\u03c4</sub>, processes this tuple to produce a new GUI state and a result indicating success or failure. By including defined state changes (S<sub>t</sub><sup>def</sup>), transitions can significantly streamline state management, eliminating the need for extra verification steps."}),"\n",(0,s.jsx)(e.h2,{id:"transitions-in-brobot",children:"Transitions in Brobot"}),"\n",(0,s.jsx)(e.h3,{id:"implementation",children:"Implementation"}),"\n",(0,s.jsxs)(e.p,{children:["Brobot implements the transition model by separating it into two parts: a ",(0,s.jsx)(e.strong,{children:"FromTransition"})," and a ",(0,s.jsx)(e.strong,{children:"IncomingTransition"}),"."]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["A ",(0,s.jsx)(e.strong,{children:"FromTransition"})," contains the initial actions required to move from a specific starting state towards a target state."]}),"\n",(0,s.jsxs)(e.li,{children:["A ",(0,s.jsx)(e.strong,{children:"IncomingTransition"})," contains the actions that always occur to finalize the entry into the target state, regardless of where the transition began."]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["For example, to go from ",(0,s.jsx)(e.code,{children:"State 1"})," to ",(0,s.jsx)(e.code,{children:"State 6"}),", the framework first executes the ",(0,s.jsx)(e.code,{children:"FromTransition"})," for ",(0,s.jsx)(e.code,{children:"State 1 to State 6"})," and then completes it by executing the ",(0,s.jsx)(e.code,{children:"IncomingTransition"})," for ",(0,s.jsx)(e.code,{children:"to State 6"}),"."]}),"\n",(0,s.jsx)(e.h3,{id:"code-example",children:"Code Example"}),"\n",(0,s.jsx)(e.p,{children:"The DoT application demonstrates how transitions are defined in the framework. A transition is built by specifying its target state and the function that performs the necessary actions."}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",children:"// From the DoT test application in the paper\npublic class WorldTransitions {\n    // ...\n    StateTransitions transitions =\n        new StateTransitions.Builder(WORLD) // Defines transitions from the WORLD state\n            .addTransition(new StateTransition.Builder()\n                .addToActivate(ISLAND) // The target state is ISLAND\n                .setFunction(this::goToIsland) // The method to execute\n                .setStaysVisibleAfterTransition(TRUE) // The WORLD state remains active\n                .build())\n            .build(); \n    // ...\n    public boolean goToIsland() {\n        // The action sequence for this transition is a single click\n        return action.perform(\n            CLICK, world.getSearchButton()\n        ).isSuccess(); \n    }\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"the-role-of-transitions-in-path-traversal",children:"The Role of Transitions in Path Traversal"}),"\n",(0,s.jsx)(e.p,{children:"Transitions are the building blocks of paths in the state graph. The path traversal model is responsible for finding and executing a sequence of transitions to move the GUI to a desired target state."}),"\n",(0,s.jsx)(e.p,{children:"If a transition in the selected path fails, the framework can recalculate to find a new path from the current set of active states, providing robustness against automation failures. The framework can also use a cost assigned to each transition as part of a heuristic to select the most efficient or reliable path."})]})}function h(t={}){const{wrapper:e}={...(0,o.R)(),...t.components};return e?(0,s.jsx)(e,{...t,children:(0,s.jsx)(d,{...t})}):d(t)}}}]);
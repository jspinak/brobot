"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2764],{28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var t=i(96540);const s={},r=t.createContext(s);function o(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(r.Provider,{value:n},e.children)}},95658:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"core-library/testing/enhanced-mocking","title":"Enhanced Mock Testing System","description":"This section covers advanced mocking features for developers extending the Brobot framework or building complex testing scenarios.","source":"@site/docs/03-core-library/testing/enhanced-mocking.md","sourceDirName":"03-core-library/testing","slug":"/core-library/testing/enhanced-mocking","permalink":"/brobot/docs/core-library/testing/enhanced-mocking","draft":false,"unlisted":false,"editUrl":"https://github.com/jspinak/brobot/edit/main/docs/docs/03-core-library/testing/enhanced-mocking.md","tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"sidebar_position":10,"title":"Enhanced Mock Testing System"},"sidebar":"docSidebar","previous":{"title":"Test Logging Architecture","permalink":"/brobot/docs/core-library/testing/test-logging-architecture"},"next":{"title":"CI/CD Testing Guide for Brobot","permalink":"/brobot/docs/core-library/testing/ci-cd-testing"}}');var s=i(74848),r=i(28453);const o={sidebar_position:10,title:"Enhanced Mock Testing System"},a="Enhanced Mock Testing System",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Centralized Mock Mode Management",id:"centralized-mock-mode-management",level:3},{value:"Mock Scenario Configuration",id:"mock-scenario-configuration",level:2},{value:"Basic Scenario Setup",id:"basic-scenario-setup",level:3},{value:"Advanced Failure Patterns",id:"advanced-failure-patterns",level:3},{value:"Temporal Conditions",id:"temporal-conditions",level:3},{value:"Behavioral Verification",id:"behavioral-verification",level:2},{value:"State Transition Verification",id:"state-transition-verification",level:3},{value:"Action Pattern Verification",id:"action-pattern-verification",level:3},{value:"Structured Test Data Builder",id:"structured-test-data-builder",level:2},{value:"Creating Test Scenarios",id:"creating-test-scenarios",level:3},{value:"Test Variations",id:"test-variations",level:3},{value:"Custom Variations",id:"custom-variations",level:3},{value:"Base Test Configuration",id:"base-test-configuration",level:2},{value:"Using BrobotTestBase",id:"using-brobottestbase",level:3},{value:"What BrobotTestBase Provides",id:"what-brobottestbase-provides",level:4},{value:"Key Benefits",id:"key-benefits",level:4},{value:"Customizing Test Setup",id:"customizing-test-setup",level:4},{value:"When to Use BrobotTestBase",id:"when-to-use-brobottestbase",level:4},{value:"Enhanced Mock Infrastructure",id:"enhanced-mock-infrastructure",level:2},{value:"Grid Operations in Mock Mode",id:"grid-operations-in-mock-mode",level:3},{value:"MockGridConfig Features",id:"mockgridconfig-features",level:4},{value:"MockFind Intelligent Fallback Behavior",id:"mockfind-intelligent-fallback-behavior",level:3},{value:"Automatic Match Generation",id:"automatic-match-generation",level:4},{value:"Fallback Behavior Rules",id:"fallback-behavior-rules",level:4},{value:"Example: Testing Without Extensive Setup",id:"example-testing-without-extensive-setup",level:4},{value:"When to Use Match History vs Fallback",id:"when-to-use-match-history-vs-fallback",level:4},{value:"Configuring Match History When Needed",id:"configuring-match-history-when-needed",level:4},{value:"Mock Scene and Color Analysis",id:"mock-scene-and-color-analysis",level:3},{value:"MockSceneBuilder Methods",id:"mockscenebuilder-methods",level:4},{value:"Builder Pattern for Complex Scenarios",id:"builder-pattern-for-complex-scenarios",level:4},{value:"Performance Characteristics",id:"performance-characteristics",level:3},{value:"Jackson Serialization Support",id:"jackson-serialization-support",level:3},{value:"Common Testing Pitfalls and Solutions",id:"common-testing-pitfalls-and-solutions",level:3},{value:"Integration with Existing Tests",id:"integration-with-existing-tests",level:2},{value:"Migrating from Basic Mocks",id:"migrating-from-basic-mocks",level:3},{value:"Test Suite Organization",id:"test-suite-organization",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Scenario Design",id:"scenario-design",level:3},{value:"Failure Pattern Design",id:"failure-pattern-design",level:3},{value:"Verification Strategy",id:"verification-strategy",level:3},{value:"Performance Considerations",id:"performance-considerations",level:3},{value:"Configuration Reference",id:"configuration-reference",level:2},{value:"MockScenarioConfig Properties",id:"mockscenarioconfig-properties",level:3},{value:"FailurePattern Properties",id:"failurepattern-properties",level:3},{value:"Verification Configuration",id:"verification-configuration",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"enhanced-mock-testing-system",children:"Enhanced Mock Testing System"})}),"\n",(0,s.jsxs)(n.admonition,{title:"For Framework Developers",type:"info",children:[(0,s.jsxs)(n.p,{children:["This section covers ",(0,s.jsx)(n.strong,{children:"advanced mocking features"})," for developers extending the Brobot framework or building complex testing scenarios."]}),(0,s.jsxs)(n.p,{children:["For standard automation testing, see the ",(0,s.jsx)(n.a,{href:"/docs/testing/testing-intro",children:"main Testing documentation"}),"."]})]}),"\n",(0,s.jsx)(n.p,{children:"Brobot's enhanced mock testing system provides sophisticated scenario-based testing capabilities with advanced failure patterns, verification, and structured test data management."}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"The enhanced mock system extends the basic mocking capabilities with:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Centralized mock mode management"})," via ",(0,s.jsx)(n.code,{children:"MockModeManager"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scenario-based configurations"})," for complex test conditions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Advanced failure patterns"})," with temporal and cascading behaviors"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Behavioral verification"})," beyond simple operation counting"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Structured test data builders"})," with variations and versioning"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Performance optimization"})," for large-scale test execution"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"centralized-mock-mode-management",children:"Centralized Mock Mode Management"}),"\n",(0,s.jsxs)(n.p,{children:["Brobot now provides the ",(0,s.jsx)(n.code,{children:"MockModeManager"})," class as a single source of truth for mock mode configuration:"]}),"\n",(0,s.jsx)(n.admonition,{title:"Clean Test Configuration",type:"note",children:(0,s.jsxs)(n.p,{children:["For Spring-based tests, see the ",(0,s.jsx)(n.a,{href:"/docs/core-library/testing/test-logging-architecture",children:"Test Logging Architecture"})," which provides factory-based configuration with clean dependencies."]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"// Note: BrobotProperties must be injected as a dependency\n@Autowired\nprivate BrobotProperties brobotProperties;\n\nimport io.github.jspinak.brobot.config.MockModeManager;\nimport io.github.jspinak.brobot.test.logging.TestLoggerFactory;\n\n// Enable mock mode across all components\nMockModeManager.setMockMode(true);\n\n// Check if mock mode is active\nif (brobotProperties.getCore().isMock()) {\n    // Execute mock-specific logic\n}\n\n// Debug mock mode state\nMockModeManager.logMockModeState();\n"})}),"\n",(0,s.jsx)(n.p,{children:"This ensures consistency across:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"System properties"}),"\n",(0,s.jsx)(n.li,{children:"ExecutionEnvironment"}),"\n",(0,s.jsx)(n.li,{children:"FrameworkSettings"}),"\n",(0,s.jsx)(n.li,{children:"All other mock-aware components"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"mock-scenario-configuration",children:"Mock Scenario Configuration"}),"\n",(0,s.jsx)(n.h3,{id:"basic-scenario-setup",children:"Basic Scenario Setup"}),"\n",(0,s.jsxs)(n.p,{children:["All test classes should extend ",(0,s.jsx)(n.code,{children:"BrobotTestBase"})," for automatic mock mode configuration:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'import io.github.jspinak.brobot.test.BrobotTestBase;\n\npublic class MyScenarioTest extends BrobotTestBase {\n    \n    @Test\n    public void testLoginUnderNetworkIssues() {\n    MockScenarioConfig scenario = MockScenarioConfig.builder()\n        .scenarioName("login_network_issues")\n        .description("Simulate intermittent network connectivity during login")\n        .stateAppearanceProbability("LOGIN_STATE", 0.8)  // 80% appear rate\n        .stateAppearanceProbability("DASHBOARD", 0.9)    // 90% appear rate\n        .build();\n        \n    // Apply scenario and run test\n    mockScenarioManager.activateScenario(scenario);\n    \n    // Your test logic here\n    ActionResult result = actions.find(loginButton);\n    \n    assertTrue(result.isSuccess());\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"advanced-failure-patterns",children:"Advanced Failure Patterns"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'@Test \npublic void testRetryBehaviorWithCascadingFailures() {\n    // Configure cascading failures that worsen over time\n    FailurePattern cascadingFailure = FailurePattern.builder()\n        .baseProbability(0.3)              // Start with 30% failure rate\n        .cascading(true)                   // Enable cascading\n        .cascadeMultiplier(1.5)            // Each failure increases probability by 50%\n        .maxConsecutiveFailures(3)         // Force success after 3 failures\n        .recoveryDelay(Duration.ofSeconds(2))  // 2-second recovery period\n        .failureMessage("Network timeout")\n        .build();\n        \n    MockScenarioConfig scenario = MockScenarioConfig.builder()\n        .scenarioName("cascading_network_failures")\n        .actionFailurePattern(ActionType.FIND, cascadingFailure)\n        .maxDuration(Duration.ofMinutes(5))  // Scenario timeout\n        .build();\n        \n    mockScenarioManager.activateScenario(scenario);\n    \n    // Test retry logic\n    for (int attempt = 1; attempt <= 5; attempt++) {\n        // Find with pause before next retry\n        PatternFindOptions findWithPause = new PatternFindOptions.Builder()\n            .setPauseAfterEnd(0.5)  // 500ms pause if not found\n            .build();\n        ActionResult result = actions.perform(findWithPause, targetElement);\n        if (result.isSuccess()) break;\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"temporal-conditions",children:"Temporal Conditions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'@Test\npublic void testPerformanceUnderLoad() {\n    TemporalConditions slowNetwork = TemporalConditions.builder()\n        .baseDelay(Duration.ofMillis(500))        // Base 500ms delay\n        .maximumDelay(Duration.ofSeconds(3))      // Cap at 3 seconds\n        .delayProgression(Duration.ofMillis(100)) // Increase by 100ms each time\n        .randomVariation(0.2)                     // \xb120% random variation\n        .activeTimeRange(LocalTime.of(9, 0), LocalTime.of(17, 0)) // Business hours\n        .build();\n        \n    MockScenarioConfig scenario = MockScenarioConfig.builder()\n        .scenarioName("performance_degradation")\n        .temporalCondition("slow_network", slowNetwork)\n        .build();\n        \n    mockScenarioManager.activateScenario(scenario);\n    \n    long startTime = System.currentTimeMillis();\n    ActionResult result = actions.find(targetElement);\n    long duration = System.currentTimeMillis() - startTime;\n    \n    assertTrue("Action should take longer under load", duration >= 500);\n    assertTrue(result.isSuccess());\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"behavioral-verification",children:"Behavioral Verification"}),"\n",(0,s.jsx)(n.h3,{id:"state-transition-verification",children:"State Transition Verification"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'@Test\npublic void testLoginFlowTransitionSequence() {\n    // Set up verification for expected state transitions\n    StateTransitionVerification verification = mockBehaviorVerifier\n        .expectTransitionSequence("login_flow")\n        .fromState("INITIAL")\n        .toState("LOGIN_PAGE")\n        .maxDuration(Duration.ofSeconds(2))  // Transition should be fast\n        .fromState("LOGIN_PAGE") \n        .toState("AUTHENTICATING")\n        .minDuration(Duration.ofMillis(100)) // Should take some time to authenticate\n        .maxDuration(Duration.ofSeconds(5))\n        .fromState("AUTHENTICATING")\n        .toState("DASHBOARD")\n        .withinTime(Duration.ofSeconds(10))  // Overall sequence timeout\n        .verify();\n        \n    // Execute the login flow\n    performLoginSequence();\n    \n    // Verify the transitions occurred as expected\n    assertEquals(VerificationResult.PASSED, verification.getResult());\n    assertTrue("No transition errors", verification.getErrors().isEmpty());\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"action-pattern-verification",children:"Action Pattern Verification"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'@Test\npublic void testRetryPatternCompliance() {\n    // Verify that find operations retry with proper backoff\n    ActionPatternVerification retryVerification = mockBehaviorVerifier\n        .expectActionPattern("find_retry_pattern")\n        .action(ActionType.FIND)\n        .maxAttempts(3)\n        .withBackoff(Duration.ofMillis(500))\n        .expectedSuccessRate(0.8)  // 80% should eventually succeed\n        .within(Duration.ofSeconds(10))\n        .verify();\n        \n    // Execute actions that may need retries\n    ActionResult result1 = actions.find(intermittentElement);\n    ActionResult result2 = actions.find(intermittentElement);\n    ActionResult result3 = actions.find(intermittentElement);\n    \n    // Verify retry behavior\n    assertEquals(VerificationResult.PASSED, retryVerification.getResult());\n    assertTrue("Retry timing should be correct", retryVerification.getErrors().isEmpty());\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"structured-test-data-builder",children:"Structured Test Data Builder"}),"\n",(0,s.jsx)(n.h3,{id:"creating-test-scenarios",children:"Creating Test Scenarios"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'@Test\npublic void testWithStructuredData() {\n    TestScenario loginScenario = testDataBuilder\n        .scenario("comprehensive_login_test")\n        .withDescription("Complete login flow with variations")\n        .withVersion("1.1.0")\n        .withBaselineData()\n        .withStateImage("login_button", "login_btn.png")\n        .withStateImage("username_field", "username_input.png") \n        .withStateString("welcome_text", "Welcome back!")\n        .withRegion("login_form", new Region(300, 200, 400, 300))\n        .withTag("authentication")\n        .withTag("critical_path")\n        .build();\n        \n    // Use the structured scenario in your test\n    StateImage loginButton = loginScenario.getStateImages().get("login_button");\n    Region formArea = loginScenario.getRegions().get("login_form");\n    \n    ActionResult result = actions.find(loginButton).searchRegions(formArea);\n    assertTrue(result.isSuccess());\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"test-variations",children:"Test Variations"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'@Test\npublic void testMobileLayoutVariation() {\n    TestScenario baseScenario = testDataBuilder.loginScenario().build();\n    \n    // Create mobile variation with adjusted similarity thresholds\n    TestScenario mobileScenario = baseScenario.withVariation("small_screen");\n    \n    // Mobile scenario automatically has:\n    // - Reduced similarity thresholds for scaled elements\n    // - Adjusted regions for smaller screen\n    // - Modified timing expectations\n    \n    StateImage mobileLoginButton = mobileScenario.getStateImages().get("login_button");\n    assertTrue("Mobile button has lower similarity threshold", \n               mobileLoginButton.getSimilarity() < 0.8);\n               \n    ActionResult result = actions.find(mobileLoginButton);\n    assertTrue(result.isSuccess());\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"custom-variations",children:"Custom Variations"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'@Test\npublic void testHighContrastVariation() {\n    TestScenario scenario = testDataBuilder\n        .scenario("high_contrast_test")\n        .withStateImage("button", "normal_button.png")\n        .withVariation("high_contrast")\n            .withDescription("High contrast accessibility mode")\n            .withTransformation("reduce_similarity", (name, obj) -> {\n                if (obj instanceof StateImage) {\n                    return ((StateImage) obj).toBuilder()\n                        .similarity(Math.max(0.6, ((StateImage) obj).getSimilarity() - 0.15))\n                        .build();\n                }\n                return obj;\n            })\n        .endVariation()\n        .build();\n        \n    TestScenario highContrastScenario = scenario.withVariation("high_contrast");\n    \n    // Test with high contrast variation\n    ActionResult result = actions.find(\n        highContrastScenario.getStateImages().get("button"));\n    assertTrue(result.isSuccess());\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"base-test-configuration",children:"Base Test Configuration"}),"\n",(0,s.jsx)(n.h3,{id:"using-brobottestbase",children:"Using BrobotTestBase"}),"\n",(0,s.jsxs)(n.p,{children:["All Brobot tests should extend ",(0,s.jsx)(n.code,{children:"BrobotTestBase"})," to ensure proper mock mode configuration and consistent test behavior across different environments:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"import io.github.jspinak.brobot.test.BrobotTestBase;\nimport org.junit.jupiter.api.Test;\n\npublic class MyBrobotTest extends BrobotTestBase {\n    \n    @Test\n    public void testMyFeature() {\n        // Your test code here\n        // Mock mode is automatically enabled\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"what-brobottestbase-provides",children:"What BrobotTestBase Provides"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"BrobotTestBase"})," automatically configures the following for all tests:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Mock Mode Activation"})," - Sets ",(0,s.jsx)(n.code,{children:"// Mock mode is now configured via application.properties: // brobot.core.mock=true"})," to prevent SikuliX headless exceptions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fast Mock Timings"})," - Configures minimal delays for mock operations (0.01-0.04 seconds)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Mouse Settings"})," - Removes mouse pause delays for faster test execution"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Screenshot Paths"})," - Sets up paths for mock screenshot operations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Per-Test Reset"})," - Ensures mock mode remains enabled between tests"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"key-benefits",children:"Key Benefits"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"CI/CD Compatibility"})," - Tests run without requiring a display or GUI"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Consistent Behavior"})," - All tests use the same mock configuration"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fast Execution"})," - Minimal mock delays speed up test suites"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Headless Support"})," - Prevents AWTException and HeadlessException errors"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"customizing-test-setup",children:"Customizing Test Setup"}),"\n",(0,s.jsxs)(n.p,{children:["You can override ",(0,s.jsx)(n.code,{children:"setupTest()"})," to add custom configuration:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"public class CustomTest extends BrobotTestBase {\n    \n    @Override\n    @BeforeEach\n    public void setupTest() {\n        super.setupTest(); // Important: call parent setup first\n        \n        // Add your custom setup\n        brobotProperties.getCore().isMock()TimeFindFirst = 0.05; // Custom timing\n        // Other custom configuration...\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"when-to-use-brobottestbase",children:"When to Use BrobotTestBase"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Always"})," for unit tests that use Brobot APIs"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Always"})," for integration tests in headless environments"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Optional"})," for end-to-end tests that need real screen interaction (don't extend BrobotTestBase)"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"enhanced-mock-infrastructure",children:"Enhanced Mock Infrastructure"}),"\n",(0,s.jsx)(n.h3,{id:"grid-operations-in-mock-mode",children:"Grid Operations in Mock Mode"}),"\n",(0,s.jsxs)(n.p,{children:["Brobot now provides full grid operation support in mock mode through the ",(0,s.jsx)(n.code,{children:"MockGridConfig"})," class:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"import io.github.jspinak.brobot.tools.testing.mock.grid.MockGridConfig;\n\n@Test\npublic void testGridOperations() {\n    // Configure grid dimensions for testing\n    MockGridConfig.setDefaultGrid(3, 3); // 3x3 grid\n    \n    Region region = new Region(0, 0, 300, 300);\n    Location location = new Location(150, 150); // Center\n    \n    // Grid operations work seamlessly in mock mode\n    Optional<Integer> gridNumber = RegionUtils.getGridNumber(region, location);\n    assertTrue(gridNumber.isPresent());\n    assertEquals(4, gridNumber.get()); // Center cell in 3x3 grid\n    \n    // Get specific grid region\n    Region gridRegion = region.getGridRegion(4);\n    assertEquals(100, gridRegion.w());\n    assertEquals(100, gridRegion.h());\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"mockgridconfig-features",children:"MockGridConfig Features"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Configurable Dimensions"}),": Set custom grid sizes with ",(0,s.jsx)(n.code,{children:"setDefaultGrid(rows, cols)"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Thread-Safe"}),": Safe for use in parallel test execution"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fallback Calculations"}),": When SikuliX is unavailable, uses native Brobot calculations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Consistent Behavior"}),": Same API in mock and real modes"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"mockfind-intelligent-fallback-behavior",children:"MockFind Intelligent Fallback Behavior"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"MockFind"})," class provides intelligent fallback behavior to ensure robust testing even when match history is not configured:"]}),"\n",(0,s.jsx)(n.h4,{id:"automatic-match-generation",children:"Automatic Match Generation"}),"\n",(0,s.jsx)(n.p,{children:"When a pattern has no configured match history, MockFind automatically generates default successful matches:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'@Test\npublic void testWithoutMatchHistory() {\n    // Create pattern without any match history\n    Pattern pattern = new Pattern.Builder()\n        .setName("TestPattern")\n        .build();\n    \n    // MockFind will still return a match in mock mode\n    MockFind mockFind = context.getBean(MockFind.class);\n    List<Match> matches = mockFind.getMatches(pattern);\n    \n    assertFalse(matches.isEmpty(), "MockFind provides default match");\n    assertEquals("TestPattern", matches.get(0).getName());\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"fallback-behavior-rules",children:"Fallback Behavior Rules"}),"\n",(0,s.jsx)(n.p,{children:"MockFind follows these rules for consistent testing behavior:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Check for existing history"}),": First checks if the pattern has any match history configured"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Generate default match if empty"}),": If no history exists, generates a default successful match with:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Region: 100, 100, 50, 50 (reasonable default location and size)"}),"\n",(0,s.jsx)(n.li,{children:"Similarity score: 0.95 (high confidence match)"}),"\n",(0,s.jsx)(n.li,{children:'Name: Uses pattern name if available, otherwise "MockMatch"'}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Respect configured history"}),": If history exists but has no matches for current state, returns empty list"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"State-aware matching"}),": When history exists, filters by active states"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"example-testing-without-extensive-setup",children:"Example: Testing Without Extensive Setup"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'@Test\npublic void testQuickMockSetup() {\n    // No need to configure match history for simple tests\n    StateImage quickTestImage = new StateImage.Builder()\n        .addPattern(new Pattern.Builder()\n            .setName("QuickTestPattern")\n            .build())\n        .build();\n    \n    ObjectCollection collection = new ObjectCollection.Builder()\n        .withImages(quickTestImage)\n        .build();\n    \n    // MockFind will provide default matches\n    ActionResult result = action.perform(new PatternFindOptions.Builder().build(), collection);\n    \n    assertTrue(result.isSuccess(), "Mock mode works without match history setup");\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"when-to-use-match-history-vs-fallback",children:"When to Use Match History vs Fallback"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use configured match history"})," when:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Testing specific match locations or patterns"}),"\n",(0,s.jsx)(n.li,{children:"Simulating test scenarios with varying success rates"}),"\n",(0,s.jsx)(n.li,{children:"Testing state-specific behaviors"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Rely on fallback behavior"})," when:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Running quick smoke tests"}),"\n",(0,s.jsx)(n.li,{children:"Testing flow logic rather than match specifics"}),"\n",(0,s.jsx)(n.li,{children:"Prototyping new test scenarios"}),"\n",(0,s.jsx)(n.li,{children:"Testing in CI/CD without complex setup"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"configuring-match-history-when-needed",children:"Configuring Match History When Needed"}),"\n",(0,s.jsx)(n.p,{children:"For tests requiring specific match behavior, configure match history explicitly:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'@Test\npublic void testWithSpecificMatchHistory() {\n    Pattern pattern = new Pattern.Builder()\n        .setName("SpecificPattern")\n        .build();\n    \n    // Add specific match history\n    ActionRecord successfulFind = new ActionRecord.Builder()\n        .setActionConfig(new PatternFindOptions.Builder()\n            .setStrategy(PatternFindOptions.Strategy.FIRST)\n            .build())\n        .setActionSuccess(true)\n        .setState("TestState")\n        .setMatchList(Arrays.asList(\n            new Match.Builder()\n                .setRegion(new Region(200, 150, 100, 50))  // Specific location\n                .setSimScore(0.98)  // High confidence\n                .build()))\n        .build();\n    \n    pattern.getMatchHistory().addSnapshot(successfulFind);\n    \n    // Test will use configured history instead of fallback\n    MockFind mockFind = context.getBean(MockFind.class);\n    List<Match> matches = mockFind.getMatches(pattern);\n    \n    assertEquals(200, matches.get(0).getRegion().x());  // Uses configured location\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"This intelligent fallback behavior ensures that:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Tests can run successfully without extensive mock setup"}),"\n",(0,s.jsx)(n.li,{children:"Quick prototyping and testing is possible"}),"\n",(0,s.jsx)(n.li,{children:"Tests remain maintainable with minimal configuration"}),"\n",(0,s.jsx)(n.li,{children:"Configured history is always respected when present"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"mock-scene-and-color-analysis",children:"Mock Scene and Color Analysis"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"MockSceneBuilder"})," provides comprehensive builders for creating test data for color analysis and scene processing:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"import io.github.jspinak.brobot.tools.testing.mock.builders.MockSceneBuilder;\n\n@Test\npublic void testColorAnalysis() {\n    // Create a mock scene with initialized image data\n    Scene scene = MockSceneBuilder.createMockScene();\n    assertNotNull(scene.getPattern());\n    assertNotNull(scene.getPattern().getImage());\n    \n    // Create scene analysis with multiple profiles\n    SceneAnalysis analysis = MockSceneBuilder.createMockSceneAnalysis(3);\n    assertEquals(3, analysis.size());\n    \n    // Each profile has properly initialized color clusters\n    PixelProfiles profile = analysis.getPixelAnalysisCollection(0);\n    assertNotNull(profile.getStateImage().getColorCluster());\n    \n    // Color operations work without real images\n    ColorClassifier classifier = new ColorClassifier();\n    Mat indices = classifier.getImageIndices(analysis, ColorCluster.ColorSchemaName.BGR);\n    assertNotNull(indices);\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"mockscenebuilder-methods",children:"MockSceneBuilder Methods"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Method"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"createMockScene()"})}),(0,s.jsx)(n.td,{children:"Creates Scene with valid Pattern and Image"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"createMockPattern()"})}),(0,s.jsx)(n.td,{children:"Creates Pattern with BGR Mat image"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"createMockSceneAnalysis(int)"})}),(0,s.jsx)(n.td,{children:"Creates SceneAnalysis with specified number of profiles"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"createMockColorCluster()"})}),(0,s.jsx)(n.td,{children:"Creates ColorCluster with BGR and HSV schemas"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"createMockColorSchema(ColorSchemaName)"})}),(0,s.jsx)(n.td,{children:"Creates schema with proper statistics"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"sceneAnalysis()"})}),(0,s.jsx)(n.td,{children:"Returns builder for complex SceneAnalysis configurations"})]})]})]}),"\n",(0,s.jsx)(n.h4,{id:"builder-pattern-for-complex-scenarios",children:"Builder Pattern for Complex Scenarios"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"@Test\npublic void testComplexSceneAnalysis() {\n    // Use builder for complex configurations\n    SceneAnalysis analysis = MockSceneBuilder.sceneAnalysis()\n        .withScene(customScene)\n        .withPixelProfile(0)\n        .withPixelProfile(1)\n        .withPixelProfile(2)\n        .build();\n    \n    // Analysis is fully initialized and ready for testing\n    assertEquals(3, analysis.getPixelAnalysisCollections().size());\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,s.jsx)(n.p,{children:"Mock mode operations are significantly faster than real operations:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Operation"}),(0,s.jsx)(n.th,{children:"Mock Mode"}),(0,s.jsx)(n.th,{children:"Real Mode"}),(0,s.jsx)(n.th,{children:"Speedup"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Grid operations"}),(0,s.jsx)(n.td,{children:"~0.01s"}),(0,s.jsx)(n.td,{children:"0.5s"}),(0,s.jsx)(n.td,{children:"50x"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Color analysis"}),(0,s.jsx)(n.td,{children:"~0.02s"}),(0,s.jsx)(n.td,{children:"1-2s"}),(0,s.jsx)(n.td,{children:"50-100x"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Pattern matching"}),(0,s.jsx)(n.td,{children:"~0.01s"}),(0,s.jsx)(n.td,{children:"0.5-2s"}),(0,s.jsx)(n.td,{children:"50-200x"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"State transitions"}),(0,s.jsx)(n.td,{children:"~0.01s"}),(0,s.jsx)(n.td,{children:"0.2-1s"}),(0,s.jsx)(n.td,{children:"20-100x"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"jackson-serialization-support",children:"Jackson Serialization Support"}),"\n",(0,s.jsx)(n.p,{children:"When creating test objects that need serialization, ensure proper Jackson annotations:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'@Getter\n@Builder(toBuilder = true, builderClassName = "Builder")\n@JsonDeserialize(builder = MyTestData.Builder.class)\n@JsonIgnoreProperties(ignoreUnknown = true)\npublic class MyTestData {\n    \n    private String field;\n    \n    @JsonPOJOBuilder(withPrefix = "")\n    @JsonIgnoreProperties(ignoreUnknown = true)\n    public static class Builder {\n        // Lombok generates implementation\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"common-testing-pitfalls-and-solutions",children:"Common Testing Pitfalls and Solutions"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Pitfall"}),(0,s.jsx)(n.th,{children:"Solution"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Tests fail in headless environments"}),(0,s.jsxs)(n.td,{children:["Always extend ",(0,s.jsx)(n.code,{children:"BrobotTestBase"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"SikuliX field mocking errors"}),(0,s.jsx)(n.td,{children:"Use real SikuliX objects or Brobot mocks"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Grid operations return empty"}),(0,s.jsxs)(n.td,{children:["Configure ",(0,s.jsx)(n.code,{children:"MockGridConfig"})," dimensions"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"ColorClassifier NPEs"}),(0,s.jsxs)(n.td,{children:["Use ",(0,s.jsx)(n.code,{children:"MockSceneBuilder"})," for test data"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:["Forget to call ",(0,s.jsx)(n.code,{children:"super.setupTest()"})]}),(0,s.jsx)(n.td,{children:"Always call parent setup when overriding"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Static mocks without cleanup"}),(0,s.jsx)(n.td,{children:"Use try-with-resources for static mocks"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"integration-with-existing-tests",children:"Integration with Existing Tests"}),"\n",(0,s.jsx)(n.h3,{id:"migrating-from-basic-mocks",children:"Migrating from Basic Mocks"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'// Old approach - basic mock status\n@Test\npublic void oldStyleTest() {\n    MockStatus.setTimesToRun(10);\n    \n    for (int i = 0; i < 10; i++) {\n        ActionResult result = actions.find(element);\n        assertTrue(result.isSuccess());\n    }\n}\n\n// New approach - scenario-based with verification\n@Test \npublic void newStyleTest() {\n    MockScenarioConfig scenario = MockScenarioConfig.builder()\n        .scenarioName("repeated_find_test")\n        .build();\n        \n    mockScenarioManager.activateScenario(scenario);\n    \n    ActionPatternVerification verification = mockBehaviorVerifier\n        .expectActionPattern("find_pattern")\n        .action(ActionType.FIND)\n        .expectedSuccessRate(1.0)\n        .verify();\n        \n    for (int i = 0; i < 10; i++) {\n        ActionResult result = actions.find(element);\n        assertTrue(result.isSuccess());\n    }\n    \n    assertEquals(VerificationResult.PASSED, verification.getResult());\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"test-suite-organization",children:"Test Suite Organization"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'@TestConfiguration\npublic class MockTestConfig {\n    \n    @Bean\n    public MockScenarioManager scenarioManager() {\n        return new MockScenarioManager();\n    }\n    \n    @Bean \n    public TestDataBuilder testDataBuilder() {\n        return new TestDataBuilder();\n    }\n    \n    // Pre-configured scenarios for reuse\n    @Bean\n    public Map<String, MockScenarioConfig> commonScenarios() {\n        Map<String, MockScenarioConfig> scenarios = new HashMap<>();\n        \n        scenarios.put("network_issues", MockScenarioConfig.builder()\n            .scenarioName("network_issues")\n            .actionFailurePattern(ActionType.FIND, \n                FailurePattern.builder()\n                    .baseProbability(0.2)\n                    .maxConsecutiveFailures(2)\n                    .build())\n            .build());\n            \n        scenarios.put("slow_system", MockScenarioConfig.builder()\n            .scenarioName("slow_system") \n            .temporalCondition("delay", \n                TemporalConditions.builder()\n                    .baseDelay(Duration.ofMillis(200))\n                    .build())\n            .build());\n            \n        return scenarios;\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"scenario-design",children:"Scenario Design"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Keep scenarios focused"})," - Each scenario should test one specific condition"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use meaningful names"})," - Scenario names should clearly indicate what they test"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Set appropriate timeouts"})," - Prevent runaway tests with reasonable duration limits"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Document expected behaviors"})," - Include descriptions of what each scenario validates"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"failure-pattern-design",children:"Failure Pattern Design"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Model realistic failures"})," - Base patterns on actual system behavior"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use progressive failures"})," - Start with low probability and increase over time"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Include recovery periods"})," - Allow systems to recover after failure sequences"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Set failure limits"})," - Prevent infinite failure loops with max consecutive failures"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"verification-strategy",children:"Verification Strategy"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Verify behavior, not just results"})," - Check timing, sequences, and patterns"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use multiple verification types"})," - Combine state transitions with action patterns"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Include negative tests"})," - Verify that unexpected behaviors are caught"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Clean up after tests"})," - Reset verifiers and scenarios between tests"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use sampling for high-frequency actions"})," - Reduce verification overhead"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Batch related verifications"})," - Group similar checks together"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Clean up resources"})," - Properly dispose of mock contexts and verifiers"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Monitor test execution time"})," - Enhanced mocking should not significantly slow tests"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"configuration-reference",children:"Configuration Reference"}),"\n",(0,s.jsx)(n.h3,{id:"mockscenarioconfig-properties",children:"MockScenarioConfig Properties"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Property"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"scenarioName"})}),(0,s.jsx)(n.td,{children:"String"}),(0,s.jsx)(n.td,{children:"Unique identifier for the scenario"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"description"})}),(0,s.jsx)(n.td,{children:"String"}),(0,s.jsx)(n.td,{children:"Human-readable description"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"stateAppearanceProbabilities"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Map<String, Double>"})}),(0,s.jsx)(n.td,{children:"Per-state appearance rates (0.0-1.0)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"actionFailurePatterns"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Map<Action, FailurePattern>"})}),(0,s.jsx)(n.td,{children:"Failure patterns by action type"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"temporalConditions"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Map<String, TemporalConditions>"})}),(0,s.jsx)(n.td,{children:"Time-based conditions"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"maxDuration"})}),(0,s.jsx)(n.td,{children:"Duration"}),(0,s.jsx)(n.td,{children:"Maximum scenario runtime"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"cascadingFailures"})}),(0,s.jsx)(n.td,{children:"boolean"}),(0,s.jsx)(n.td,{children:"Enable failure cascading"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"failurepattern-properties",children:"FailurePattern Properties"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Property"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"baseProbability"})}),(0,s.jsx)(n.td,{children:"double"}),(0,s.jsx)(n.td,{children:"Base failure rate (0.0-1.0)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"probabilityDecay"})}),(0,s.jsx)(n.td,{children:"double"}),(0,s.jsx)(n.td,{children:"Reduction per failure occurrence"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"maxConsecutiveFailures"})}),(0,s.jsx)(n.td,{children:"int"}),(0,s.jsx)(n.td,{children:"Max failures before forced success"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"cascading"})}),(0,s.jsx)(n.td,{children:"boolean"}),(0,s.jsx)(n.td,{children:"Whether failures increase probability"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"recoveryDelay"})}),(0,s.jsx)(n.td,{children:"Duration"}),(0,s.jsx)(n.td,{children:"Recovery time after failures"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"exceptionType"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Class<Exception>"})}),(0,s.jsx)(n.td,{children:"Type of exception to throw"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"verification-configuration",children:"Verification Configuration"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Property"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"maxTotalTime"})}),(0,s.jsx)(n.td,{children:"Duration"}),(0,s.jsx)(n.td,{children:"Overall sequence timeout"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"minDuration"})}),(0,s.jsx)(n.td,{children:"Duration"}),(0,s.jsx)(n.td,{children:"Minimum step duration"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"maxDuration"})}),(0,s.jsx)(n.td,{children:"Duration"}),(0,s.jsx)(n.td,{children:"Maximum step duration"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"optional"})}),(0,s.jsx)(n.td,{children:"boolean"}),(0,s.jsx)(n.td,{children:"Whether step is optional"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"verificationWindow"})}),(0,s.jsx)(n.td,{children:"Duration"}),(0,s.jsx)(n.td,{children:"Time window for pattern verification"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"This enhanced mock testing system provides comprehensive tools for creating realistic, maintainable, and thorough test scenarios that closely mirror production conditions while enabling rapid iteration and debugging."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);
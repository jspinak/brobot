"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3391],{22598:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"testing/integration-testing","title":"Integration Testing","description":"Integration testing in Brobot simulates the complete application environment and workflow. Unlike unit testing which focuses on individual components, integration testing validates entire automation sequences using mock execution to ensure robustness and reliability.","source":"@site/docs/04-testing/integration-testing.md","sourceDirName":"04-testing","slug":"/testing/integration-testing","permalink":"/brobot/docs/testing/integration-testing","draft":false,"unlisted":false,"editUrl":"https://github.com/jspinak/brobot/edit/main/docs/docs/04-testing/integration-testing.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"docSidebar","previous":{"title":"Testing Overview","permalink":"/brobot/docs/testing/testing-intro"},"next":{"title":"Mock Mode Guide","permalink":"/brobot/docs/testing/mock-mode-guide"}}');var s=t(74848),o=t(28453);const r={sidebar_position:2},a="Integration Testing",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Test Base Class",id:"test-base-class",level:2},{value:"BrobotTestBase (Without Spring)",id:"brobottestbase-without-spring",level:3},{value:"BrobotIntegrationTestBase (With Spring)",id:"brobotintegrationtestbase-with-spring",level:3},{value:"Configuration",id:"configuration",level:2},{value:"Automatic Mock Configuration",id:"automatic-mock-configuration",level:3},{value:"Configuration via Properties",id:"configuration-via-properties",level:3},{value:"Test Configuration",id:"test-configuration",level:3},{value:"Mock Execution Architecture",id:"mock-execution-architecture",level:2},{value:"How Mocking Works",id:"how-mocking-works",level:3},{value:"Mock Timing Configuration",id:"mock-timing-configuration",level:3},{value:"State Object Initialization",id:"state-object-initialization",level:2},{value:"Action History Setup",id:"action-history-setup",level:3},{value:"State Structure Builder Integration",id:"state-structure-builder-integration",level:3},{value:"API Migration Note",id:"api-migration-note",level:3},{value:"Log Output Analysis",id:"log-output-analysis",level:3},{value:"Test Assertions and Validation",id:"test-assertions-and-validation",level:2},{value:"Modern Assertion Patterns",id:"modern-assertion-patterns",level:3},{value:"Performance Assertions",id:"performance-assertions",level:3},{value:"Custom Test Matchers",id:"custom-test-matchers",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Optimized Test Base Class",id:"optimized-test-base-class",level:3},{value:"Gradle Configuration",id:"gradle-configuration",level:3},{value:"Gradle Properties",id:"gradle-properties",level:3},{value:"Mock Timing Optimization",id:"mock-timing-optimization",level:3},{value:"Test Execution Strategies",id:"test-execution-strategies",level:3},{value:"Running Specific Test Categories",id:"running-specific-test-categories",level:4},{value:"CI/CD Optimization",id:"cicd-optimization",level:4},{value:"Best Practices",id:"best-practices",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"integration-testing",children:"Integration Testing"})}),"\n",(0,s.jsx)(n.p,{children:"Integration testing in Brobot simulates the complete application environment and workflow. Unlike unit testing which focuses on individual components, integration testing validates entire automation sequences using mock execution to ensure robustness and reliability."}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"Integration testing provides:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Centralized mock mode management"})," via ",(0,s.jsx)(n.code,{children:"MockModeManager"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Full application simulation"})," without GUI interaction"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Stochastic modeling"})," of real-world variability"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"State transition validation"})," across complex workflows"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Risk assessment"})," for automation reliability"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"test-base-class",children:"Test Base Class"}),"\n",(0,s.jsx)(n.h3,{id:"brobottestbase-without-spring",children:"BrobotTestBase (Without Spring)"}),"\n",(0,s.jsxs)(n.p,{children:["For simple integration tests without Spring context, extend ",(0,s.jsx)(n.code,{children:"BrobotTestBase"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"import io.github.jspinak.brobot.test.BrobotTestBase;\n\npublic class WorkflowIntegrationTest extends BrobotTestBase {\n    // Mock mode is automatically enabled\n    // All mock settings are synchronized via MockModeManager\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"brobotintegrationtestbase-with-spring",children:"BrobotIntegrationTestBase (With Spring)"}),"\n",(0,s.jsx)(n.p,{children:"For integration tests requiring Spring context and dependency injection:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"import io.github.jspinak.brobot.test.BrobotIntegrationTestBase;\n\n@SpringBootTest(classes = BrobotTestApplication.class)\n@ContextConfiguration(initializers = TestConfigurationManager.class)\n@Import({TestActionConfig.class, MockBrobotLoggerConfig.class})\npublic class SpringIntegrationTest extends BrobotIntegrationTestBase {\n    \n    @Autowired\n    private BrobotLogger logger;  // Automatically configured via factory pattern\n    \n    @Autowired\n    private Action action;  // Clean dependency injection\n}\n"})}),"\n",(0,s.jsx)(n.admonition,{title:"Clean Architecture for Spring Tests",type:"tip",children:(0,s.jsxs)(n.p,{children:["The test configuration architecture uses factory patterns and proper initialization order to ensure clean dependencies. See ",(0,s.jsx)(n.a,{href:"/docs/core-library/testing/test-logging-architecture",children:"Test Logging Architecture"})," for details."]})}),"\n",(0,s.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,s.jsx)(n.h3,{id:"automatic-mock-configuration",children:"Automatic Mock Configuration"}),"\n",(0,s.jsxs)(n.p,{children:["When using ",(0,s.jsx)(n.code,{children:"BrobotTestBase"}),", mock mode is automatically configured:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"public class IntegrationTest extends BrobotTestBase {\n    \n    @Test\n    public void testWorkflow() {\n        // Mock mode is enabled via MockModeManager\n        assertTrue(MockModeManager.isMockMode());\n        // Your test logic here\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"configuration-via-properties",children:"Configuration via Properties"}),"\n",(0,s.jsx)(n.p,{children:"Additional testing configuration:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-properties",children:"# Mock mode is automatically enabled by BrobotTestBase\n# These properties are synchronized by MockModeManager:\nbrobot.mock.mode=true\nbrobot.core.mock=true\nbrobot.framework.mock=true\n\n# Mock timing configuration\nbrobot.mock.time-find-first=0.1\nbrobot.mock.time-find-all=0.2\nbrobot.mock.time-click=0.05\nbrobot.mock.time-drag=0.3\n\n# Testing settings\nbrobot.testing.iteration=1\nbrobot.testing.send-logs=true\n\n# Dataset collection (optional)\nbrobot.dataset.build=false\nbrobot.dataset.path=dataset/\n"})}),"\n",(0,s.jsx)(n.p,{children:"Or using YAML:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"brobot:\n  core:\n    mock: true\n  mock:\n    time-find-first: 0.1\n    time-find-all: 0.2\n    time-click: 0.05\n    time-drag: 0.3\n  testing:\n    iteration: 1\n    send-logs: true\n"})}),"\n",(0,s.jsx)(n.h3,{id:"test-configuration",children:"Test Configuration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"@SpringBootTest\npublic class IntegrationTestConfig extends BrobotTestBase {\n    // Mock mode automatically enabled by BrobotTestBase\n    // Additional configuration handled by Spring Boot\n    \n    @BeforeEach\n    @Override\n    public void setupTest() {\n        super.setupTest(); // Ensures MockModeManager is configured\n        // Add any additional setup\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"mock-execution-architecture",children:"Mock Execution Architecture"}),"\n",(0,s.jsx)(n.p,{children:"Brobot's mocking system provides comprehensive simulation of GUI automation:"}),"\n",(0,s.jsx)(n.h3,{id:"how-mocking-works",children:"How Mocking Works"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Action Interception"}),": All GUI actions (click, find, drag) are intercepted at the wrapper level"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Realistic Timing"}),": Mock operations use configurable delays to simulate real execution"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Stochastic Results"}),": Actions return probabilistic outcomes based on historical data"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Transparent Operation"}),": Application code runs identically in mock and live modes"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"mock-timing-configuration",children:"Mock Timing Configuration"}),"\n",(0,s.jsx)(n.p,{children:"Configure mock timings via properties:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-properties",children:"# Configure realistic timings for different actions\nbrobot.mock.time-find-first=0.1\nbrobot.mock.time-find-all=0.3\nbrobot.mock.time-click=0.05\nbrobot.mock.time-drag=0.4\nbrobot.mock.time-move=0.2\n"})}),"\n",(0,s.jsx)(n.p,{children:"Or per-test configuration:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'@Test\n@TestPropertySource(properties = {\n    "brobot.mock.time-find-first=0.1",\n    "brobot.mock.time-click=0.05"\n})\nvoid testWithCustomTimings() {\n    // Test uses configured mock timings\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"wrappers",src:t(76359).A+"",width:"1920",height:"1080"})}),"\n",(0,s.jsx)(n.p,{children:"Mocking can uncover errors in the code in the same way that traditional testing, for\nexample JUnit testing, does. You don't have to wait 30 minutes to realize that you\nforgot to name the new image you saved, and your application can't find it. This\nhappens instantly."}),"\n",(0,s.jsx)(n.p,{children:"Mocking also provides insight into how robust your code is. Parts of the code with\nnarrow paths (little redundancy in making a transition from state A to state B)\nmay perform poorly if a state has a low probability of appearing. You can introduce\nprocess flow errors into the mocks, including sending your process to an unknown state,\nto see how your app will behave."}),"\n",(0,s.jsx)(n.h2,{id:"state-object-initialization",children:"State Object Initialization"}),"\n",(0,s.jsx)(n.h3,{id:"action-history-setup",children:"Action History Setup"}),"\n",(0,s.jsx)(n.p,{children:"State objects should be initialized with realistic action histories for proper mock behavior. The modern approach uses ActionConfig-based snapshots:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'@Component\npublic class StateInitializer {\n    \n    public StateImage createLoginButton() {\n        return new StateImage.Builder()\n            .addPattern("login_button")\n            .setName("LoginButton")\n            .build();\n    }\n    \n    // Add action history snapshots to patterns\n    public void initializeActionHistory(StateImage stateImage) {\n        Pattern pattern = stateImage.getPatterns().get(0);\n        ActionHistory history = pattern.getActionHistory();\n        \n        // Add find snapshots with modern ActionConfig\n        history.addSnapshot(createFindSnapshot());\n        history.addSnapshot(createClickSnapshot());\n    }\n    \n    private ActionRecord createFindSnapshot() {\n        return new ActionRecord.Builder()\n            .setActionConfig(new PatternFindOptions.Builder()\n                .setStrategy(PatternFindOptions.Strategy.BEST)\n                .setSimilarity(0.95)\n                .build())\n            .addMatch(new Match.Builder()\n                .setRegion(100, 200, 80, 30)\n                .setSimScore(0.95)\n                .build())\n            .setActionSuccess(true)\n            .build();\n    }\n    \n    private ActionRecord createClickSnapshot() {\n        return new ActionRecord.Builder()\n            .setActionConfig(new ClickOptions.Builder()\n                .setClickType(ClickOptions.Type.LEFT)\n                .build())\n            .setActionSuccess(true)\n            .build();\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"state-structure-builder-integration",children:"State Structure Builder Integration"}),"\n",(0,s.jsx)(n.p,{children:"When using the State Structure Builder, mock data is automatically generated:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Screenshot Analysis"}),": Captures current application screens"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Image Recognition"}),": Analyzes UI elements and their properties"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"History Generation"}),": Creates realistic action histories from analysis"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Code Generation"}),": Produces Java code with pre-configured mock data"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'// Generated by State Structure Builder\npublic class GeneratedStates {\n    \n    public static StateImage getSubmitButton() {\n        StateImage submitButton = new StateImage.Builder()\n            .addPattern("submit_button")\n            .setName("SubmitButton")\n            .build();\n            \n        // Initialize with auto-generated action histories\n        initializeActionHistory(submitButton);\n        return submitButton;\n    }\n    \n    private static void initializeActionHistory(StateImage stateImage) {\n        Pattern pattern = stateImage.getPatterns().get(0);\n        ActionHistory history = pattern.getActionHistory();\n        \n        // Generated from actual screenshot analysis\n        history.addSnapshot(createSnapshot(0.98, 245, 356, 120, 35));\n        history.addSnapshot(createSnapshot(0.96, 245, 356, 120, 35));\n        history.addSnapshot(createSnapshot(0.89, 245, 356, 120, 35));\n    }\n    \n    private static ActionRecord createSnapshot(double score, int x, int y, int w, int h) {\n        return new ActionRecord.Builder()\n            .setActionConfig(new PatternFindOptions.Builder()\n                .setStrategy(PatternFindOptions.Strategy.BEST)\n                .build())\n            .addMatch(new Match.Builder()\n                .setRegion(x, y, w, h)\n                .setSimScore(score)\n                .build())\n            .setActionSuccess(true)\n            .build();\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"api-migration-note",children:"API Migration Note"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Important"}),": The ActionHistory class is currently in a transitional state. While the modern ActionConfig system is the recommended approach, ActionHistory still uses ",(0,s.jsx)(n.code,{children:"ActionOptions.Action"})," internally for backward compatibility. The examples above show the intended modern API pattern that will be fully supported in future versions."]}),"\n",(0,s.jsx)(n.p,{children:"Current ActionHistory methods that still use the legacy API:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"getRandomSnapshot(ActionOptions.Action action)"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"getRandomSnapshot(ActionOptions.Action action, Long state)"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"For now, when working with ActionHistory directly, you may need to use adapter patterns or continue using ActionOptions.Action until the migration is complete."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"private static List<ActionResult> getFindHistorySubmitButton() {\n    // Generated from actual screenshot analysis\n    return Arrays.asList(\n        createActionResult(0.98, 245, 356, 120, 35),\n        createActionResult(0.96, 245, 356, 120, 35),\n        createActionResult(0.89, 245, 356, 120, 35)\n    );\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'\n## Logging and Monitoring\n\n### Comprehensive Test Logging\n\nMock execution provides detailed logging for debugging and analysis:\n\n```java\n@SpringBootTest\n@TestPropertySource(properties = {\n    "brobot.core.mock=true",\n    "brobot.testing.send-logs=true",\n    "brobot.logging.verbosity=VERBOSE"\n})\npublic class IntegrationTestWithLogging {\n    \n    private static final Logger logger = LoggerFactory.getLogger(IntegrationTestWithLogging.class);\n    \n    @Autowired\n    private Action action;\n    \n    @Autowired\n    private StateImageRepository stateImageRepo;\n    \n    @Test\n    public void testCompleteWorkflow() {\n        logger.info("Starting integration test workflow");\n        \n        // Mock execution provides full logging\n        PatternFindOptions findOptions = new PatternFindOptions.Builder()\n            .setStrategy(PatternFindOptions.Strategy.BEST)\n            .build();\n        \n        StateImage loginButton = stateImageRepo.get("login_button");\n        ActionResult loginResult = action.perform(findOptions, loginButton);\n        logger.info("Login result: {} matches found", loginResult.size());\n        \n        ClickOptions clickOptions = new ClickOptions.Builder().build();\n        action.perform(clickOptions, loginButton);\n        \n        StateImage dashboardMenu = stateImageRepo.get("dashboard_menu");\n        ActionResult navigationResult = action.perform(findOptions, dashboardMenu);\n        logger.info("Navigation result: success={}", navigationResult.isSuccess());\n        \n        // Process data with multiple finds\n        PatternFindOptions findAllOptions = new PatternFindOptions.Builder()\n            .setStrategy(PatternFindOptions.Strategy.ALL)\n            .build();\n        StateImage dataRows = stateImageRepo.get("data_rows");\n        ActionResult dataResult = action.perform(findAllOptions, dataRows);\n        logger.info("Data processing completed with {} operations", dataResult.size());\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"log-output-analysis",children:"Log Output Analysis"}),"\n",(0,s.jsx)(n.p,{children:"Mock runs produce detailed output including:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Action Timing"}),": Simulated execution durations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Decision Points"}),": State transition logic"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Match Results"}),": Simulated find operation outcomes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Error Conditions"}),": Exception handling and recovery"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Performance Metrics"}),": Mock operation statistics"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"[INFO] Starting integration test workflow\n[DEBUG] Mock FIND operation: login_button.png -> 1 match (score: 0.95, time: 120ms)\n[DEBUG] Mock CLICK operation: (100,200) -> SUCCESS (time: 50ms)\n[INFO] Login result: 1 matches found\n[DEBUG] State transition: LOGIN -> DASHBOARD (probability: 0.95)\n[DEBUG] Mock FIND operation: dashboard_menu.png -> 2 matches (time: 200ms)\n[INFO] Navigation result: success=true\n"})}),"\n",(0,s.jsx)(n.h2,{id:"test-assertions-and-validation",children:"Test Assertions and Validation"}),"\n",(0,s.jsx)(n.h3,{id:"modern-assertion-patterns",children:"Modern Assertion Patterns"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'public class IntegrationTestAssertions {\n    \n    @Test\n    public void testWorkflowReliability() {\n        // Test multiple mock runs for consistency\n        List<ActionResult> results = new ArrayList<>();\n        \n        // Configure action for workflow\n        PatternFindOptions findOptions = new PatternFindOptions.Builder()\n            .setStrategy(PatternFindOptions.Strategy.BEST)\n            .setSimilarity(0.85)\n            .then(new ClickOptions.Builder().build())  // Chain find with click\n            .build();\n        \n        StateImage criticalButton = stateImageRepo.get("critical_button");\n        \n        for (int i = 0; i < 10; i++) {\n            // Each iteration uses configuration properties\n            ActionResult result = action.perform(findOptions, criticalButton);\n            results.add(result);\n        }\n        \n        // Assert workflow reliability\n        long successCount = results.stream()\n            .filter(ActionResult::isSuccess)\n            .count();\n            \n        double successRate = (double) successCount / results.size();\n        assertTrue(successRate >= 0.8, \n            String.format("Workflow success rate %.2f below threshold 0.8", successRate));\n    }\n    \n    @Test\n    public void testStateTransitionProbabilities() {\n        // Test state transition reliability\n        Map<String, Integer> transitionCounts = new HashMap<>();\n        \n        State loginState = stateRepository.get("LOGIN");\n        StateImage dashboardLink = loginState.getStateImages().stream()\n            .filter(img -> img.getName().equals("dashboard_link"))\n            .findFirst().orElseThrow();\n        \n        PatternFindOptions findAndClick = new PatternFindOptions.Builder()\n            .setStrategy(PatternFindOptions.Strategy.BEST)\n            .then(new ClickOptions.Builder().build())\n            .build();\n        \n        for (int i = 0; i < 100; i++) {\n            ActionResult result = action.perform(findAndClick, dashboardLink);\n            String outcome = result.isSuccess() ? "SUCCESS" : "FAILURE";\n            transitionCounts.merge(outcome, 1, Integer::sum);\n        }\n        \n        // Verify expected probability distribution\n        double successRate = (double) transitionCounts.getOrDefault("SUCCESS", 0) / 100;\n        assertTrue(successRate >= 0.85, "State transition success rate too low");\n        assertTrue(successRate <= 0.98, "State transition success rate unrealistically high");\n    }\n    \n    @Test\n    public void testErrorRecovery() {\n        // Test recovery mechanisms with retry logic\n        StateImage problematicElement = stateImageRepo.get("problematic_element");\n        \n        // Configure action with retry\n        PatternFindOptions findWithRetry = new PatternFindOptions.Builder()\n            .setStrategy(PatternFindOptions.Strategy.BEST)\n            .setMaxIterations(3)  // Retry up to 3 times\n            .setPauseBeforeRetry(0.5)\n            .build();\n        \n        ActionResult result = action.perform(findWithRetry, problematicElement);\n        \n        // In mock mode, the retry behavior is simulated\n        // Check that appropriate retries were attempted\n        assertTrue(result.getAttempts() <= 3, "Too many retry attempts");\n        \n        // For successful recovery after retries\n        if (result.isSuccess()) {\n            assertTrue(result.getAttempts() > 1, "Recovery should have required retries");\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"performance-assertions",children:"Performance Assertions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'@Test\npublic void testPerformanceCharacteristics() {\n    long startTime = System.currentTimeMillis();\n    \n    // Complex workflow with multiple actions\n    PatternFindOptions complexFind = new PatternFindOptions.Builder()\n        .setStrategy(PatternFindOptions.Strategy.ALL)\n        .setSimilarity(0.9)\n        .then(new DefineRegionOptions.Builder()\n            .setDefineAs(DefineRegionOptions.DefineAs.INSIDE_ANCHORS)\n            .build())\n        .then(new ClickOptions.Builder()\n            .setClickType(ClickOptions.Type.DOUBLE)\n            .build())\n        .build();\n    \n    StateImage complexElement = stateImageRepo.get("complex_element");\n    ActionResult result = action.perform(complexFind, complexElement);\n    \n    long duration = System.currentTimeMillis() - startTime;\n    \n    // Assert mock timing is realistic\n    assertTrue(duration >= 500, "Mock execution too fast - unrealistic");\n    assertTrue(duration <= 2000, "Mock execution too slow - check configuration");\n    \n    // Assert result quality\n    assertTrue(result.isSuccess());\n    assertFalse(result.isEmpty());\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"custom-test-matchers",children:"Custom Test Matchers"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'public class BrobotMatchers {\n    \n    public static Matcher<ActionResult> hasMinimumMatches(int minCount) {\n        return new TypeSafeMatcher<ActionResult>() {\n            @Override\n            protected boolean matchesSafely(ActionResult result) {\n                return result.size() >= minCount;\n            }\n            \n            @Override\n            public void describeTo(Description description) {\n                description.appendText("ActionResult with at least ").appendValue(minCount).appendText(" matches");\n            }\n        };\n    }\n    \n    public static Matcher<ActionResult> hasSuccessfulExecution() {\n        return new TypeSafeMatcher<ActionResult>() {\n            @Override\n            protected boolean matchesSafely(ActionResult result) {\n                return result.isSuccess() && !result.isEmpty();\n            }\n            \n            @Override\n            public void describeTo(Description description) {\n                description.appendText("successful ActionResult with matches");\n            }\n        };\n    }\n}\n\n// Usage in tests\n@Test\npublic void testWithCustomMatchers() {\n    PatternFindOptions findOptions = new PatternFindOptions.Builder()\n        .setStrategy(PatternFindOptions.Strategy.ALL)\n        .build();\n    \n    StateImage buttons = stateImageRepo.get("buttons");\n    ActionResult result = action.perform(findOptions, buttons);\n    \n    assertThat(result, hasMinimumMatches(2));\n    assertThat(result, hasSuccessfulExecution());\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,s.jsx)(n.h3,{id:"optimized-test-base-class",children:"Optimized Test Base Class"}),"\n",(0,s.jsxs)(n.p,{children:["For high-performance integration testing, use the ",(0,s.jsx)(n.code,{children:"OptimizedIntegrationTestBase"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"import io.github.jspinak.brobot.test.OptimizedIntegrationTestBase;\n\n@TestInstance(TestInstance.Lifecycle.PER_CLASS) // Share Spring context\n@Timeout(value = 5, unit = TimeUnit.MINUTES)     // Default timeout\npublic class FastIntegrationTest extends OptimizedIntegrationTestBase {\n    \n    @Test\n    public void testWorkflow() {\n        // Benefits:\n        // - Shared Spring context reduces initialization overhead\n        // - Optimized mock timings (0.005-0.015s per operation)\n        // - Per-class lifecycle reduces test setup time\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"gradle-configuration",children:"Gradle Configuration"}),"\n",(0,s.jsxs)(n.p,{children:["Configure ",(0,s.jsx)(n.code,{children:"library-test/build.gradle"})," for optimal test execution:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-gradle",children:"test {\n    // Increased timeout to prevent premature failures\n    timeout = Duration.ofMinutes(10)\n    \n    // Parallel execution using half of available cores\n    maxParallelForks = Math.max(1, Runtime.runtime.availableProcessors().intdiv(2))\n    \n    // Fork new JVM every 20 tests to prevent memory buildup\n    forkEvery = 20\n    \n    // Optimized memory settings\n    maxHeapSize = '4g'\n    jvmArgs '-XX:MaxRAMPercentage=75.0', \n            '-XX:+UseG1GC',\n            '-Dorg.bytedeco.javacpp.maxphysicalbytes=8G'\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"gradle-properties",children:"Gradle Properties"}),"\n",(0,s.jsxs)(n.p,{children:["Add ",(0,s.jsx)(n.code,{children:"library-test/gradle.properties"})," for test-specific optimizations:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-properties",children:"# Enable parallel execution\norg.gradle.parallel=true\norg.gradle.caching=true\n\n# Configure JUnit 5 parallel execution\nsystemProp.junit.jupiter.execution.parallel.enabled=true\nsystemProp.junit.jupiter.execution.parallel.mode.default=concurrent\nsystemProp.junit.jupiter.execution.parallel.config.strategy=dynamic\nsystemProp.junit.jupiter.execution.parallel.config.dynamic.factor=0.5\n\n# Retry flaky tests\nsystemProp.gradle.test.retry.maxRetries=2\nsystemProp.gradle.test.retry.maxFailures=5\n"})}),"\n",(0,s.jsx)(n.h3,{id:"mock-timing-optimization",children:"Mock Timing Optimization"}),"\n",(0,s.jsx)(n.p,{children:"Configure faster mock timings for test environments:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"@TestConfiguration\npublic class OptimizedTestConfig implements BeforeAllCallback {\n    \n    @Override\n    public void beforeAll(ExtensionContext context) {\n        // Ultra-fast mock timings for tests\n        FrameworkSettings.mockTimeFindFirst = 0.005;\n        FrameworkSettings.mockTimeFindAll = 0.01;\n        FrameworkSettings.mockTimeClick = 0.005;\n        FrameworkSettings.mockTimeMove = 0.005;\n        FrameworkSettings.mockTimeDrag = 0.01;\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"test-execution-strategies",children:"Test Execution Strategies"}),"\n",(0,s.jsx)(n.h4,{id:"running-specific-test-categories",children:"Running Specific Test Categories"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'# Run only fast integration tests\n./gradlew test --tests "*FastIntegrationTest*"\n\n# Run integration tests with optimized settings\n./gradlew integrationTest\n\n# Run tests in parallel with custom fork settings\n./gradlew test -PmaxParallelForks=4 -PforkEvery=10\n'})}),"\n",(0,s.jsx)(n.h4,{id:"cicd-optimization",children:"CI/CD Optimization"}),"\n",(0,s.jsx)(n.p,{children:"For CI/CD pipelines, use environment-specific configurations:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"protected double getTimeoutMultiplier() {\n    if (isCI()) return 2.0;           // Double timeout in CI\n    if (isHeadlessEnvironment()) return 1.5;  // 1.5x in headless\n    return 1.0;                       // Normal timeout locally\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Modern API Usage"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use ActionConfig subclasses (PatternFindOptions, ClickOptions, etc.) instead of ActionOptions"}),"\n",(0,s.jsx)(n.li,{children:"Configure actions through properties files rather than programmatic setup"}),"\n",(0,s.jsxs)(n.li,{children:["Leverage action chaining with ",(0,s.jsx)(n.code,{children:".then()"})," for complex workflows"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Realistic Mock Data"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use actual screenshot analysis to generate mock histories"}),"\n",(0,s.jsx)(n.li,{children:"Include both success and failure scenarios with ActionRecord snapshots"}),"\n",(0,s.jsx)(n.li,{children:"Model realistic timing and variability through ActionConfig"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Comprehensive Testing"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Test complete workflows, not just individual actions"}),"\n",(0,s.jsx)(n.li,{children:"Include error conditions and recovery paths"}),"\n",(0,s.jsx)(n.li,{children:"Validate state transitions and probabilities"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Performance Optimization"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"OptimizedIntegrationTestBase"})," for shared Spring context"]}),"\n",(0,s.jsx)(n.li,{children:"Configure parallel test execution via Gradle properties"}),"\n",(0,s.jsx)(n.li,{children:"Optimize mock timings for test environments (0.005-0.015s)"}),"\n",(0,s.jsx)(n.li,{children:"Fork JVMs strategically to prevent memory issues"}),"\n",(0,s.jsx)(n.li,{children:"Enable test result caching for faster re-runs"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Continuous Integration"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Run integration tests in CI/CD pipelines"}),"\n",(0,s.jsx)(n.li,{children:"Use deterministic random seeds for reproducible results"}),"\n",(0,s.jsx)(n.li,{children:"Archive test logs and reports for analysis"}),"\n",(0,s.jsx)(n.li,{children:"Configure environment-specific timeouts and retries"}),"\n"]}),"\n"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var i=t(96540);const s={},o=i.createContext(s);function r(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:n},e.children)}},76359:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/wrappers-8f5e2e7afa7fb9b1452c20daaa9e6e83.jpeg"}}]);
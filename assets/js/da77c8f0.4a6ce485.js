"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4307],{28453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>c});var t=i(96540);const o={},r=t.createContext(o);function s(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(r.Provider,{value:n},e.children)}},60940:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"testing/mixed-mode-execution","title":"Mixed-Mode Execution","description":"Overview","source":"@site/docs/04-testing/mixed-mode-execution.md","sourceDirName":"04-testing","slug":"/testing/mixed-mode-execution","permalink":"/brobot/docs/testing/mixed-mode-execution","draft":false,"unlisted":false,"editUrl":"https://github.com/jspinak/brobot/edit/main/docs/docs/04-testing/mixed-mode-execution.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Mixed-Mode Execution"},"sidebar":"docSidebar","previous":{"title":"ActionHistory Integration Testing","permalink":"/brobot/docs/testing/actionhistory-integration-testing"},"next":{"title":"Debugging Pattern Matching","permalink":"/brobot/docs/testing/debugging-pattern-matching"}}');var o=i(74848),r=i(28453);const s={sidebar_position:4,title:"Mixed-Mode Execution"},c="Mixed-Mode Execution Guide",l={},a=[{value:"Overview",id:"overview",level:2},{value:"Architecture",id:"architecture",level:2},{value:"Three-Layer Approach",id:"three-layer-approach",level:3},{value:"Component Structure",id:"component-structure",level:3},{value:"Enabling Mixed-Mode",id:"enabling-mixed-mode",level:2},{value:"Configuration",id:"configuration",level:3},{value:"Programmatic Activation",id:"programmatic-activation",level:3},{value:"Use Cases",id:"use-cases",level:2},{value:"1. Hybrid Testing Scenarios",id:"1-hybrid-testing-scenarios",level:3},{value:"2. Performance Testing",id:"2-performance-testing",level:3},{value:"3. Gradual Live Integration",id:"3-gradual-live-integration",level:3},{value:"4. Debug Mode",id:"4-debug-mode",level:3},{value:"Implementation Example",id:"implementation-example",level:2},{value:"Creating a Hybrid Component",id:"creating-a-hybrid-component",level:3},{value:"Configuration Properties",id:"configuration-properties",level:2},{value:"Hybrid Mode Settings",id:"hybrid-mode-settings",level:3},{value:"Component-Specific Settings",id:"component-specific-settings",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Clear Mode Boundaries",id:"1-clear-mode-boundaries",level:3},{value:"2. Mode Assertion",id:"2-mode-assertion",level:3},{value:"3. Scoped Mode Changes",id:"3-scoped-mode-changes",level:3},{value:"4. Mode-Aware Logging",id:"4-mode-aware-logging",level:3},{value:"Testing Strategies",id:"testing-strategies",level:2},{value:"Unit Tests with Mode Switching",id:"unit-tests-with-mode-switching",level:3},{value:"Integration Tests",id:"integration-tests",level:3},{value:"Parameterized Tests",id:"parameterized-tests",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Mode Not Switching",id:"mode-not-switching",level:3},{value:"Unexpected Behavior After Switch",id:"unexpected-behavior-after-switch",level:3},{value:"Performance Issues",id:"performance-issues",level:3},{value:"Migration Path",id:"migration-path",level:2},{value:"Phase 1: Enable Hybrid Mode",id:"phase-1-enable-hybrid-mode",level:3},{value:"Phase 2: Identify Switch Points",id:"phase-2-identify-switch-points",level:3},{value:"Phase 3: Implement Hybrid Components",id:"phase-3-implement-hybrid-components",level:3},{value:"Phase 4: Test Mixed Scenarios",id:"phase-4-test-mixed-scenarios",level:3},{value:"Phase 5: Optimize Switching",id:"phase-5-optimize-switching",level:3},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"mixed-mode-execution-guide",children:"Mixed-Mode Execution Guide"})}),"\n",(0,o.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsx)(n.p,{children:"Mixed-mode execution allows Brobot applications to dynamically switch between mock and live implementations within a single session. This hybrid approach combines the benefits of profile-based architecture with the flexibility of runtime delegation."}),"\n",(0,o.jsx)(n.h2,{id:"architecture",children:"Architecture"}),"\n",(0,o.jsx)(n.h3,{id:"three-layer-approach",children:"Three-Layer Approach"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         Application Layer            \u2502\n\u2502    (Uses TextTyper interface)        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n             \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502        Hybrid Layer                  \u2502\n\u2502   (HybridTextTyper wrapper)         \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502\n\u2502  \u2502Profile-Based\u2502Runtime-Based\u2502      \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n             \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502     Implementation Layer             \u2502\n\u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u2502\n\u2502 \u2502MockTyper \u2502 \u2502LiveTyper \u2502           \u2502\n\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,o.jsx)(n.h3,{id:"component-structure",children:"Component Structure"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Interface"}),": Defines the contract (e.g., ",(0,o.jsx)(n.code,{children:"TextTyper"}),")"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Profile Implementations"}),": Mock and Live versions with ",(0,o.jsx)(n.code,{children:"@Profile"})," annotations"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Hybrid Wrapper"}),": Bridges profile-based and runtime architectures"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Legacy Wrapper"}),": Original runtime-check implementation for backward compatibility"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"enabling-mixed-mode",children:"Enabling Mixed-Mode"}),"\n",(0,o.jsx)(n.h3,{id:"configuration",children:"Configuration"}),"\n",(0,o.jsx)(n.p,{children:"Enable mixed-mode execution in your application properties:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-properties",children:"# application.properties\nbrobot.hybrid.enabled=true\n"})}),"\n",(0,o.jsx)(n.h3,{id:"programmatic-activation",children:"Programmatic Activation"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'@SpringBootTest\n@TestPropertySource(properties = {\n    "brobot.hybrid.enabled=true"\n})\npublic class MixedModeTest {\n    \n    @Autowired\n    private HybridExecutionConfiguration.HybridComponentConfigurer configurer;\n    \n    @Test\n    public void testDynamicSwitching() {\n        // Start in mock mode\n        configurer.switchAllToMock();\n        performMockOperations();\n        \n        // Switch to live mode\n        configurer.switchAllToLive();\n        performLiveOperations();\n        \n        // Back to mock\n        configurer.switchAllToMock();\n        verifyMockResults();\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,o.jsx)(n.h3,{id:"1-hybrid-testing-scenarios",children:"1. Hybrid Testing Scenarios"}),"\n",(0,o.jsx)(n.p,{children:"Test workflows that require both mock and live components:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:"@Test\npublic void testLoginWithRealUIAndMockBackend() {\n    // Use live mode for UI interaction\n    hybridExecutor.switchToLive();\n    action.click(loginButton);\n    action.type(username);\n    \n    // Switch to mock for backend calls\n    hybridExecutor.switchToMock();\n    backend.simulateSuccessfulLogin();\n    \n    // Back to live for verification\n    hybridExecutor.switchToLive();\n    assertTrue(action.find(dashboardElement).isSuccess());\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"2-performance-testing",children:"2. Performance Testing"}),"\n",(0,o.jsx)(n.p,{children:"Compare mock vs. live execution times:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'@Test\npublic void benchmarkOperations() {\n    long mockTime, liveTime;\n    \n    // Measure mock performance\n    configurer.switchAllToMock();\n    long start = System.currentTimeMillis();\n    performComplexWorkflow();\n    mockTime = System.currentTimeMillis() - start;\n    \n    // Measure live performance\n    configurer.switchAllToLive();\n    start = System.currentTimeMillis();\n    performComplexWorkflow();\n    liveTime = System.currentTimeMillis() - start;\n    \n    log.info("Mock time: {}ms, Live time: {}ms", mockTime, liveTime);\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"3-gradual-live-integration",children:"3. Gradual Live Integration"}),"\n",(0,o.jsx)(n.p,{children:"Start with mostly mocked components, gradually enable live ones:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:"public class GradualIntegrationTest {\n    \n    @Test\n    public void testWithProgressiveLiveComponents() {\n        // Phase 1: All mock\n        setAllMock();\n        assertTrue(basicWorkflow());\n        \n        // Phase 2: Live clicking only\n        setAllMock();\n        clickExecutor.switchToLive();\n        assertTrue(clickWorkflow());\n        \n        // Phase 3: Live clicking and typing\n        setAllMock();\n        clickExecutor.switchToLive();\n        typeExecutor.switchToLive();\n        assertTrue(interactiveWorkflow());\n        \n        // Phase 4: Full live\n        setAllLive();\n        assertTrue(completeWorkflow());\n    }\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"4-debug-mode",children:"4. Debug Mode"}),"\n",(0,o.jsx)(n.p,{children:"Switch to mock when errors occur:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'public class DebugAwareAutomation {\n    \n    public void executeWithFallback() {\n        try {\n            // Attempt live execution\n            hybridExecutor.switchToLive();\n            performAction();\n        } catch (AutomationException e) {\n            log.warn("Live execution failed, switching to mock", e);\n            \n            // Fallback to mock mode for debugging\n            hybridExecutor.switchToMock();\n            performAction(); // This should succeed\n            \n            // Log the issue for investigation\n            debugLogger.logFailure(e);\n        }\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"implementation-example",children:"Implementation Example"}),"\n",(0,o.jsx)(n.h3,{id:"creating-a-hybrid-component",children:"Creating a Hybrid Component"}),"\n",(0,o.jsx)(n.p,{children:"Here's how to implement a hybrid component from scratch:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'// 1. Define the interface\npublic interface ClickExecutor {\n    boolean click(Location location);\n}\n\n// 2. Create mock implementation\n@Component\n@Profile("test")\npublic class MockClickExecutor implements ClickExecutor {\n    public boolean click(Location location) {\n        log.info("Mock click at {}", location);\n        pause(FrameworkSettings.mockTimeClick);\n        return true;\n    }\n}\n\n// 3. Create live implementation\n@Component\n@Profile("!test")\npublic class LiveClickExecutor implements ClickExecutor {\n    @Autowired\n    private Mouse mouse;\n    \n    public boolean click(Location location) {\n        mouse.move(location);\n        return mouse.click();\n    }\n}\n\n// 4. Create hybrid wrapper\n@Component\n@Primary\npublic class HybridClickExecutor implements ClickExecutor {\n    \n    @Autowired(required = false)\n    private MockClickExecutor mockExecutor;\n    \n    @Autowired(required = false)\n    private LiveClickExecutor liveExecutor;\n    \n    private boolean useLegacyMode = false;\n    \n    public boolean click(Location location) {\n        // Profile-based selection\n        if (!useLegacyMode) {\n            if (FrameworkSettings.mock && mockExecutor != null) {\n                return mockExecutor.click(location);\n            }\n            if (!FrameworkSettings.mock && liveExecutor != null) {\n                return liveExecutor.click(location);\n            }\n        }\n        \n        // Runtime-based fallback\n        if (FrameworkSettings.mock) {\n            return mockClick(location);\n        } else {\n            return liveClick(location);\n        }\n    }\n    \n    public void enableMixedMode() {\n        this.useLegacyMode = true;\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"configuration-properties",children:"Configuration Properties"}),"\n",(0,o.jsx)(n.h3,{id:"hybrid-mode-settings",children:"Hybrid Mode Settings"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-properties",children:"# Enable hybrid execution mode\nbrobot.hybrid.enabled=true\n\n# Allow runtime mode switching (default: false)\nbrobot.hybrid.allow-runtime-switch=true\n\n# Log mode switches (default: true)\nbrobot.hybrid.log-switches=true\n\n# Default mode when hybrid is enabled (mock|live)\nbrobot.hybrid.default-mode=mock\n"})}),"\n",(0,o.jsx)(n.h3,{id:"component-specific-settings",children:"Component-Specific Settings"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-properties",children:"# Enable hybrid mode for specific components\nbrobot.hybrid.text-typer.enabled=true\nbrobot.hybrid.click-executor.enabled=true\nbrobot.hybrid.scene-provider.enabled=false\n\n# Component-specific default modes\nbrobot.hybrid.text-typer.default=mock\nbrobot.hybrid.click-executor.default=live\n"})}),"\n",(0,o.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsx)(n.h3,{id:"1-clear-mode-boundaries",children:"1. Clear Mode Boundaries"}),"\n",(0,o.jsx)(n.p,{children:"Document when and why mode switches occur:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:"public void hybridWorkflow() {\n    // === MOCK MODE: Setup test data ===\n    switchToMock();\n    setupTestStates();\n    \n    // === LIVE MODE: Interact with real UI ===\n    switchToLive();\n    interactWithUI();\n    \n    // === MOCK MODE: Verify without side effects ===\n    switchToMock();\n    verifyResults();\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"2-mode-assertion",children:"2. Mode Assertion"}),"\n",(0,o.jsx)(n.p,{children:"Verify expected mode before critical operations:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'private void assertMockMode() {\n    if (!FrameworkSettings.mock) {\n        throw new IllegalStateException("Expected mock mode but was live");\n    }\n}\n\nprivate void assertLiveMode() {\n    if (FrameworkSettings.mock) {\n        throw new IllegalStateException("Expected live mode but was mock");\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"3-scoped-mode-changes",children:"3. Scoped Mode Changes"}),"\n",(0,o.jsx)(n.p,{children:"Use try-finally to ensure mode restoration:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:"public void temporaryMockExecution(Runnable action) {\n    boolean originalMode = FrameworkSettings.mock;\n    try {\n        FrameworkSettings.mock = true;\n        action.run();\n    } finally {\n        FrameworkSettings.mock = originalMode;\n    }\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"4-mode-aware-logging",children:"4. Mode-Aware Logging"}),"\n",(0,o.jsx)(n.p,{children:"Include current mode in log messages:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'public void logModeAware(String message) {\n    String mode = FrameworkSettings.mock ? "MOCK" : "LIVE";\n    log.info("[{}] {}", mode, message);\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"testing-strategies",children:"Testing Strategies"}),"\n",(0,o.jsx)(n.h3,{id:"unit-tests-with-mode-switching",children:"Unit Tests with Mode Switching"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:"@Test\npublic void testModeTransitions() {\n    // Test mock \u2192 live transition\n    executor.switchToMock();\n    ActionResult mockResult = executor.execute();\n    assertTrue(mockResult.isSuccess());\n    \n    executor.switchToLive();\n    ActionResult liveResult = executor.execute();\n    assertTrue(liveResult.isSuccess());\n    \n    // Verify different behaviors\n    assertNotEquals(mockResult.getDuration(), liveResult.getDuration());\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"integration-tests",children:"Integration Tests"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'@SpringBootTest\n@ActiveProfiles("integration")\n@EnableHybridMode\npublic class HybridIntegrationTest {\n    \n    @Test\n    public void testMixedModeWorkflow() {\n        // Start with known mock state\n        resetToMockBaseline();\n        \n        // Perform live interactions\n        switchToLive();\n        performUserInteractions();\n        \n        // Verify with mock to avoid side effects\n        switchToMock();\n        verifyExpectedOutcome();\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"parameterized-tests",children:"Parameterized Tests"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:"@ParameterizedTest\n@ValueSource(booleans = {true, false})\npublic void testInBothModes(boolean mockMode) {\n    FrameworkSettings.mock = mockMode;\n    \n    ActionResult result = executor.execute();\n    \n    assertTrue(result.isSuccess());\n    if (mockMode) {\n        assertEquals(0.01, result.getDuration(), 0.001);\n    } else {\n        assertTrue(result.getDuration() > 0.1);\n    }\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,o.jsx)(n.h3,{id:"mode-not-switching",children:"Mode Not Switching"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'// Check if hybrid mode is enabled\nif (!environment.getProperty("brobot.hybrid.enabled", Boolean.class, false)) {\n    log.error("Hybrid mode not enabled!");\n}\n\n// Verify component supports hybrid\nif (!(executor instanceof HybridTextTyper)) {\n    log.error("Component doesn\'t support hybrid execution");\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"unexpected-behavior-after-switch",children:"Unexpected Behavior After Switch"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'// Add mode verification\n@BeforeEach\npublic void verifyInitialMode() {\n    log.info("Initial mode: {}", FrameworkSettings.mock ? "MOCK" : "LIVE");\n    log.info("Hybrid enabled: {}", hybridConfig.isEnabled());\n}\n\n@AfterEach\npublic void logFinalMode() {\n    log.info("Final mode: {}", FrameworkSettings.mock ? "MOCK" : "LIVE");\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"performance-issues",children:"Performance Issues"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'// Monitor mode switch overhead\npublic class ModeSwitchMonitor {\n    \n    public void measureSwitchOverhead() {\n        long start = System.nanoTime();\n        for (int i = 0; i < 1000; i++) {\n            configurer.switchAllToMock();\n            configurer.switchAllToLive();\n        }\n        long elapsed = System.nanoTime() - start;\n        log.info("Average switch time: {}ns", elapsed / 2000);\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"migration-path",children:"Migration Path"}),"\n",(0,o.jsx)(n.h3,{id:"phase-1-enable-hybrid-mode",children:"Phase 1: Enable Hybrid Mode"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-properties",children:"brobot.hybrid.enabled=true\n"})}),"\n",(0,o.jsx)(n.h3,{id:"phase-2-identify-switch-points",children:"Phase 2: Identify Switch Points"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:"// Mark where mode switches are needed\n// TODO: Switch to mock here\n// TODO: Switch to live here\n"})}),"\n",(0,o.jsx)(n.h3,{id:"phase-3-implement-hybrid-components",children:"Phase 3: Implement Hybrid Components"}),"\n",(0,o.jsx)(n.p,{children:"Replace runtime checks with hybrid wrappers"}),"\n",(0,o.jsx)(n.h3,{id:"phase-4-test-mixed-scenarios",children:"Phase 4: Test Mixed Scenarios"}),"\n",(0,o.jsx)(n.p,{children:"Verify both modes work correctly"}),"\n",(0,o.jsx)(n.h3,{id:"phase-5-optimize-switching",children:"Phase 5: Optimize Switching"}),"\n",(0,o.jsx)(n.p,{children:"Minimize unnecessary mode changes"}),"\n",(0,o.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(n.p,{children:"Mixed-mode execution provides:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Flexibility"}),": Switch between mock and live at runtime"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Gradual Migration"}),": Move from runtime to profile-based architecture"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Enhanced Testing"}),": Combine mock and live components in tests"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Debugging Support"}),": Fallback to mock when live fails"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Performance Analysis"}),": Compare mock vs. live execution"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Use mixed-mode when you need dynamic control over execution behavior, especially during testing, debugging, or gradual system integration."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);
"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8365],{28453:(n,t,e)=>{e.d(t,{R:()=>o,x:()=>r});var i=e(96540);const s={},a=i.createContext(s);function o(n){const t=i.useContext(a);return i.useMemo(function(){return"function"==typeof n?n(t):{...t,...n}},[t,n])}function r(n){let t;return t=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:o(n.components),i.createElement(a.Provider,{value:t},n.children)}},43607:(n,t,e)=>{e.d(t,{A:()=>i});const i=e.p+"assets/images/transitions-c388f3c755a4df88c4c15f76e021e687.png"},91768:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"getting-started/transitions","title":"Transitions","description":"Introduction","source":"@site/docs/01-getting-started/transitions.md","sourceDirName":"01-getting-started","slug":"/getting-started/transitions","permalink":"/brobot/docs/getting-started/transitions","draft":false,"unlisted":false,"editUrl":"https://github.com/jspinak/brobot/edit/main/docs/docs/01-getting-started/transitions.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Transitions"},"sidebar":"docSidebar","previous":{"title":"States","permalink":"/brobot/docs/getting-started/states"},"next":{"title":"The Action Hierarchy","permalink":"/brobot/docs/getting-started/action-hierarchy"}}');var s=e(74848),a=e(28453);const o={sidebar_position:4,title:"Transitions"},r="Transitions",l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"The Brobot Implementation: IncomingTransition and OutgoingTransition",id:"the-brobot-implementation-incomingtransition-and-outgoingtransition",level:2},{value:"Using @TransitionSet Annotation",id:"using-transitionset-annotation",level:2},{value:"Complete Example",id:"complete-example",level:3},{value:"Annotation Types",id:"annotation-types",level:3},{value:"@TransitionSet",id:"transitionset",level:4},{value:"@IncomingTransition",id:"incomingtransition",level:4},{value:"@OutgoingTransition",id:"outgoingtransition",level:4},{value:"World State Example",id:"world-state-example",level:2},{value:"Advanced OutgoingTransition Examples",id:"advanced-outgoingtransition-examples",level:2},{value:"Modal Dialog with Origin State Visible",id:"modal-dialog-with-origin-state-visible",level:3},{value:"Complex Multi-State Activation",id:"complex-multi-state-activation",level:3},{value:"Key Benefits of This Pattern",id:"key-benefits-of-this-pattern",level:2},{value:"The Formal Model (Under the Hood)",id:"the-formal-model-under-the-hood",level:2},{value:"Multi-State Activation and Pathfinding",id:"multi-state-activation-and-pathfinding",level:2},{value:"Core Concept: No Primary Target State",id:"core-concept-no-primary-target-state",level:3},{value:"Configuring Multi-State Transitions",id:"configuring-multi-state-transitions",level:3},{value:"How Pathfinding Uses Multi-State Transitions",id:"how-pathfinding-uses-multi-state-transitions",level:3},{value:"Important Behavior: IncomingTransitions for All Activated States",id:"important-behavior-incomingtransitions-for-all-activated-states",level:3},{value:"Execution Order:",id:"execution-order",level:4},{value:"Example: Dashboard with Multiple Panels",id:"example-dashboard-with-multiple-panels",level:3},{value:"State Management in Transitions",id:"state-management-in-transitions",level:3},{value:"Activate Set",id:"activate-set",level:4},{value:"Exit Set",id:"exit-set",level:4},{value:"StaysVisible Property",id:"staysvisible-property",level:4},{value:"Benefits of Multi-State Activation",id:"benefits-of-multi-state-activation",level:3},{value:"Dynamic Transitions for Hidden States",id:"dynamic-transitions-for-hidden-states",level:2},{value:"Path Costs and Pathfinding",id:"path-costs-and-pathfinding",level:2},{value:"Default Path Costs (v1.1.0+)",id:"default-path-costs-v110",level:3},{value:"Quick Example",id:"quick-example",level:3},{value:"Learn More",id:"learn-more",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Summary",id:"summary",level:2}];function d(n){const t={a:"a",blockquote:"blockquote",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"transitions",children:"Transitions"})}),"\n",(0,s.jsx)(t.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsxs)(t.p,{children:['While states define "where you can be" in a GUI, ',(0,s.jsx)(t.strong,{children:"transitions"}),' define "how you get there." Every state that is reachable needs an associated transitions class that defines the pathways to and from other states.']}),"\n",(0,s.jsx)(t.p,{children:'Formally, a transition is a process or a sequence of actions that changes the GUI from one state to another. They form the "edges" of the state graph and are the building blocks used by the framework\'s pathfinder to navigate the application.'}),"\n",(0,s.jsx)(t.h2,{id:"the-brobot-implementation-incomingtransition-and-outgoingtransition",children:"The Brobot Implementation: IncomingTransition and OutgoingTransition"}),"\n",(0,s.jsx)(t.p,{children:"Brobot implements transitions using a cohesive pattern where each state's transition class contains:"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.img,{alt:"Transition Diagram",src:e(43607).A+"",width:"623",height:"196"}),(0,s.jsx)(t.br,{}),"\n",(0,s.jsx)(t.em,{children:"This diagram is based on Figure 8 from the research paper."})]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"IncomingTransition"}),": This verifies successful arrival at the state, regardless of which state initiated the transition. There is only one IncomingTransition per state, and it contains checks to confirm the state is active."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"OutgoingTransition"}),": These handle navigation FROM the current state TO other states. Each OutgoingTransition contains the specific actions needed to navigate to a target state."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"using-transitionset-annotation",children:"Using @TransitionSet Annotation"}),"\n",(0,s.jsx)(t.p,{children:"Brobot uses a cohesive, method-level annotation approach that groups all transitions for a state in one class. Each transition class contains:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"The IncomingTransition to verify arrival at the state"}),"\n",(0,s.jsx)(t.li,{children:"All OutgoingTransitions that navigate FROM this state to other states"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"This pattern maintains high cohesion since outgoing transitions use the current state's images."}),"\n",(0,s.jsx)(t.h3,{id:"complete-example",children:"Complete Example"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:'/**\n * TransitionSet for AmountState - handles all transitions for the Amount dialog\n * Transition classes have ONLY methods, no state objects\n */\n@TransitionSet(state = AmountState.class)\n@RequiredArgsConstructor\n@Slf4j\npublic class AmountTransitions {\n\n    private final AmountState amountState;\n    private final Action action;\n\n    @OutgoingTransition(activate = {MainScreenState.class})\n    public boolean toMainScreen() {\n        return action.type(amountState.getClose()).isSuccess();\n    }\n\n    @IncomingTransition\n    public boolean verifyArrival() {\n        PatternFindOptions findOptions = new PatternFindOptions.Builder()\n            .withBeforeActionLog("Verifying arrival at Amount dialog...")\n            .withSuccessLog("Successfully arrived at Amount dialog")\n            .withFailureLog("Failed to verify arrival at Amount dialog")\n            .setSearchDuration(5.0)\n            .build();\n\n        return action.perform(findOptions, amountState.getEingabe()).isSuccess();\n    }\n}\n'})}),"\n",(0,s.jsx)(t.h3,{id:"annotation-types",children:"Annotation Types"}),"\n",(0,s.jsx)(t.h4,{id:"transitionset",children:"@TransitionSet"}),"\n",(0,s.jsx)(t.p,{children:"Marks a class as containing all transitions for a specific state:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"state"}),": The state class these transitions belong to (required)"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"name"}),': Optional state name override (defaults to class name without "State" suffix)']}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"description"}),": Documentation for the transition set"]}),"\n"]}),"\n",(0,s.jsx)(t.h4,{id:"incomingtransition",children:"@IncomingTransition"}),"\n",(0,s.jsx)(t.p,{children:"Verifies successful arrival at the state:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"description"}),": Documentation for the verification"]}),"\n"]}),"\n",(0,s.jsx)(t.h4,{id:"outgoingtransition",children:"@OutgoingTransition"}),"\n",(0,s.jsx)(t.p,{children:"Defines a transition FROM the current state TO other states:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"activate"}),": States to activate during this transition (required array of state classes)"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"exit"}),": States to deactivate during this transition (optional array of state classes)"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"staysVisible"}),": Whether the originating state remains visible after transition (default: false)"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"pathCost"}),": Path-finding cost - LOWER costs are preferred when multiple paths exist (default: 1 as of v1.3.0)"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"description"}),": Documentation for this transition"]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"world-state-example",children:"World State Example"}),"\n",(0,s.jsx)(t.p,{children:"Here's another complete example showing transitions for a World state with multiple entry and exit points:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:'@TransitionSet(state = WorldState.class, description = "World map transitions")\n@RequiredArgsConstructor\n@Slf4j\npublic class WorldTransitions {\n\n    private final WorldState worldState;\n    private final Action action;\n    \n    /**\n     * Verify arrival at World state by checking for the state\'s images.\n     */\n    @IncomingTransition(description = "Verify arrival at World state")\n    public boolean verifyArrival() {\n        // Check for world-specific elements\n        return action.find(worldState.getWorldMap(), worldState.getIsland()).isSuccess();\n    }\n\n    /**\n     * Navigate from World to Home by clicking the home button.\n     */\n    @OutgoingTransition(activate = {HomeState.class}, description = "Navigate from World to Home")\n    public boolean toHome() {\n        return action.click(worldState.getHomeButton()).isSuccess();\n    }\n\n    /**\n     * Navigate from World to Island by clicking on the search button.\n     */\n    @OutgoingTransition(activate = {IslandState.class}, pathCost = 2, description = "Navigate from World to Island")\n    public boolean toIsland() {\n        return action.click(worldState.getSearchButton()).isSuccess();\n    }\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"advanced-outgoingtransition-examples",children:"Advanced OutgoingTransition Examples"}),"\n",(0,s.jsx)(t.h3,{id:"modal-dialog-with-origin-state-visible",children:"Modal Dialog with Origin State Visible"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"@TransitionSet(state = SettingsModalState.class)\n@RequiredArgsConstructor\n@Slf4j\npublic class SettingsModalTransitions {\n\n    private final SettingsModalState settingsModalState;\n    private final Action action;\n\n    @IncomingTransition\n    public boolean verifyArrival() {\n        return action.find(settingsModalState.getCloseButton()).isSuccess();\n    }\n\n    /**\n     * Close the modal and return to previous state.\n     * Previous state is reactivated when modal closes.\n     */\n    @OutgoingTransition(activate = {PreviousState.class})\n    public boolean closeToPrevious() {\n        return action.click(settingsModalState.getCloseButton()).isSuccess();\n    }\n}\n\n@TransitionSet(state = DashboardState.class)\npublic class DashboardTransitions {\n\n    /**\n     * Open settings modal while keeping dashboard visible in background.\n     */\n    @OutgoingTransition(\n        activate = {SettingsModalState.class},\n        staysVisible = true,  // Dashboard remains visible behind modal\n        pathCost = 2\n    )\n    public boolean openSettingsModal() {\n        return action.click(dashboardState.getSettingsButton()).isSuccess();\n    }\n}\n"})}),"\n",(0,s.jsx)(t.h3,{id:"complex-multi-state-activation",children:"Complex Multi-State Activation"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:'@TransitionSet(state = LoginState.class)\npublic class LoginTransitions {\n\n    /**\n     * Login transition that activates multiple UI components.\n     */\n    @OutgoingTransition(\n        activate = {DashboardState.class, SidebarState.class, HeaderState.class, FooterState.class},\n        exit = {SplashScreenState.class},  // Clean up login-related states\n        pathCost = 0  // Preferred path\n    )\n    public boolean login() {\n        action.type(loginState.getUsernameField(), "user@example.com");\n        action.type(loginState.getPasswordField(), "password");\n        return action.click(loginState.getLoginButton()).isSuccess();\n    }\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"key-benefits-of-this-pattern",children:"Key Benefits of This Pattern"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"High Cohesion"}),": Each transition class only needs its own state as a dependency, since outgoing transitions use that state's images"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Clear Separation"}),": IncomingTransition verifies arrival, OutgoingTransitions handle navigation FROM the state"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Natural Organization"}),": File structure mirrors state structure (one transitions class per state)"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Spring Integration"}),": Full dependency injection support (@TransitionSet includes @Component)"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Type Safety"}),": Class-based state references prevent typos and enable IDE refactoring"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Mock Mode Support"}),": Easy to add testing support with framework settings check"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Cleaner Code"}),": Each transition class is self-contained with its state's navigation logic"]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"the-formal-model-under-the-hood",children:"The Formal Model (Under the Hood)"}),"\n",(0,s.jsxs)(t.p,{children:["The academic paper provides a formal definition for a transition as a tuple ",(0,s.jsxs)(t.strong,{children:["t = (A, S",(0,s.jsx)("sub",{children:"t"}),(0,s.jsx)("sup",{children:"def"}),")"]}),"."]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"A"})," is a ",(0,s.jsx)(t.strong,{children:"process"}),", which is a sequence of one or more actions ",(0,s.jsx)(t.code,{children:"(a\xb9, a\xb2, ..., a\u207f)"}),". This corresponds to the method body in your @OutgoingTransition methods."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsxs)(t.strong,{children:["S",(0,s.jsx)("sub",{children:"t"}),(0,s.jsx)("sup",{children:"def"})]})," is the ",(0,s.jsx)(t.strong,{children:"intended state information"}),". This is handled automatically by the framework based on the @TransitionSet's state parameter and the @OutgoingTransition's activate parameter."]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"multi-state-activation-and-pathfinding",children:"Multi-State Activation and Pathfinding"}),"\n",(0,s.jsx)(t.p,{children:"Brobot supports transitions that activate multiple states simultaneously. This is useful for scenarios where opening one state brings multiple UI elements or panels into view."}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsx)(t.p,{children:(0,s.jsxs)(t.strong,{children:["\ud83d\udcd6 For complete pathfinding details, see ",(0,s.jsx)(t.a,{href:"/brobot/docs/getting-started/pathfinding",children:"Pathfinding & Multi-State Activation"})]})}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"core-concept-no-primary-target-state",children:"Core Concept: No Primary Target State"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Critical Understanding"}),': In Brobot 1.1.0, transitions don\'t have a "primary" target. ALL states in the ',(0,s.jsx)(t.code,{children:"activate"})," set are treated equally for pathfinding purposes."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:'// All four states are equal - any can be used as a path node\ntransition.setActivate(Set.of("Dashboard", "Sidebar", "Header", "Footer"));\n'})}),"\n",(0,s.jsx)(t.h3,{id:"configuring-multi-state-transitions",children:"Configuring Multi-State Transitions"}),"\n",(0,s.jsxs)(t.p,{children:["While transitions are defined using the ",(0,s.jsx)(t.code,{children:"@TransitionSet"})," and ",(0,s.jsx)(t.code,{children:"@OutgoingTransition"})," annotations, the underlying transition model supports activating and exiting multiple states. This can be configured programmatically through the transition's ",(0,s.jsx)(t.code,{children:"activate"})," and ",(0,s.jsx)(t.code,{children:"exit"})," sets:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"// In the transition configuration or builder\ntransition.setActivate(Set.of(dashboardId, sidebarId, headerId));\ntransition.setExit(Set.of(loginId));\n"})}),"\n",(0,s.jsx)(t.h3,{id:"how-pathfinding-uses-multi-state-transitions",children:"How Pathfinding Uses Multi-State Transitions"}),"\n",(0,s.jsxs)(t.p,{children:["When a transition activates multiple states, ",(0,s.jsx)(t.strong,{children:"each activated state becomes a potential path node"})," for future navigation:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"// Given: Login transition activates [Dashboard, Sidebar, Menu]\n// Then pathfinder can use:\n//   Login \u2192 Dashboard \u2192 TargetState\n//   Login \u2192 Sidebar \u2192 TargetState\n//   Login \u2192 Menu \u2192 TargetState\n// Whichever path exists and is shortest will be used\n"})}),"\n",(0,s.jsx)(t.h3,{id:"important-behavior-incomingtransitions-for-all-activated-states",children:"Important Behavior: IncomingTransitions for All Activated States"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsxs)(t.strong,{children:["When a transition activates multiple states, each activated state's ",(0,s.jsx)(t.code,{children:"@IncomingTransition"})," method is executed to verify successful arrival."]})," This ensures that all expected UI elements are present before the transition is considered successful."]}),"\n",(0,s.jsx)(t.h4,{id:"execution-order",children:"Execution Order:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"OutgoingTransition"})," executes (leaving the source state)"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Primary target state's IncomingTransition"})," executes (first state in the ",(0,s.jsx)(t.code,{children:"activate"})," array)"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Each additional state's IncomingTransition"})," executes in sequence"]}),"\n",(0,s.jsx)(t.li,{children:"States are only marked as active if their IncomingTransition succeeds"}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"example-dashboard-with-multiple-panels",children:"Example: Dashboard with Multiple Panels"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:'// Transition that activates multiple UI panels\n@TransitionSet(state = LoginState.class)\n@RequiredArgsConstructor\n@Slf4j\npublic class DashboardTransitions {\n\n    private final Action action;\n    private final LoginState loginState;\n\n    // This transition is configured to activate multiple states\n    @OutgoingTransition(activate = {DashboardState.class, NavigationBarState.class, StatusPanelState.class})\n    public boolean login() {\n        log.info("Navigating from Login to Dashboard, NavigationBar, and StatusPanel.");\n        return action.click(loginState.getLoginButton()).isSuccess();\n    }\n\n    @IncomingTransition\n    public boolean verifyArrival() {\n        log.info("Verifying login is visible");\n        return action.find(loginState.getLoginButton()).isSuccess();\n    }\n}\n\n// Each activated state verifies its own presence\n@TransitionSet(state = DashboardState.class)\npublic class DashboardTransitions {\n    @IncomingTransition\n    public boolean verifyArrival() {\n        log.info("Verifying Dashboard is visible");\n        return action.find(dashboardState.getMainContent()).isSuccess();\n    }\n}\n\n@TransitionSet(state = NavigationBarState.class)\npublic class NavigationBarTransitions {\n    @IncomingTransition\n    public boolean verifyArrival() {\n        log.info("Verifying NavigationBar is visible");\n        return action.find(navBarState.getMenuItems()).isSuccess();\n    }\n}\n\n@TransitionSet(state = StatusPanelState.class)\npublic class StatusPanelTransitions {\n    @IncomingTransition\n    public boolean verifyArrival() {\n        log.info("Verifying StatusPanel is visible");\n        return action.find(statusPanel.getStatusIndicator()).isSuccess();\n    }\n}\n'})}),"\n",(0,s.jsx)(t.h3,{id:"state-management-in-transitions",children:"State Management in Transitions"}),"\n",(0,s.jsxs)(t.p,{children:["The underlying ",(0,s.jsx)(t.code,{children:"StateTransition"})," interface provides mechanisms for managing state activation and deactivation:"]}),"\n",(0,s.jsx)(t.h4,{id:"activate-set",children:"Activate Set"}),"\n",(0,s.jsx)(t.p,{children:"States to be activated during the transition:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"// In the transition configuration\ntransition.setActivate(Set.of(gameBoardId, scorePanelId, timerId));\n"})}),"\n",(0,s.jsx)(t.h4,{id:"exit-set",children:"Exit Set"}),"\n",(0,s.jsx)(t.p,{children:"States to be deactivated (exited) during the transition:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"// States that should be deactivated\ntransition.setExit(Set.of(mainMenuId, settingsId));\n"})}),"\n",(0,s.jsx)(t.h4,{id:"staysvisible-property",children:"StaysVisible Property"}),"\n",(0,s.jsx)(t.p,{children:"Controls whether the source state remains visible after transition:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"// Keep source state visible (e.g., for overlays)\ntransition.setStaysVisibleAfterTransition(StateTransition.StaysVisible.TRUE);\n\n// Hide source state (default behavior)\ntransition.setStaysVisibleAfterTransition(StateTransition.StaysVisible.FALSE);\n\n// Inherit from StateTransitions container\ntransition.setStaysVisibleAfterTransition(StateTransition.StaysVisible.NONE);\n"})}),"\n",(0,s.jsx)(t.h3,{id:"benefits-of-multi-state-activation",children:"Benefits of Multi-State Activation"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Atomic Operations"}),": All states are verified together, ensuring UI consistency"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Better Error Detection"}),": If any expected element is missing, the transition fails"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Cleaner Code"}),": One transition handles complex UI changes"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Accurate Model"}),": Reflects how modern UIs actually work with multiple components"]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"dynamic-transitions-for-hidden-states",children:"Dynamic Transitions for Hidden States"}),"\n",(0,s.jsx)(t.p,{children:'Brobot supports dynamic transitions to handle common UI patterns like menus and pop-ups. When a state opens and covers another, the covered state is registered as "hidden."'}),"\n",(0,s.jsx)(t.p,{children:"You can define transitions that return to the previous state dynamically:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:'import io.github.jspinak.brobot.model.state.special.*;\n\n@TransitionSet(state = MenuState.class, description = "Menu overlay transitions")\n@RequiredArgsConstructor\n@Slf4j\npublic class MenuTransitions {\n    \n    private final MenuState menuState;\n    private final Action action;\n    \n    /**\n     * Close menu and return to whatever state was underneath.\n     * This uses the PreviousState special marker for dynamic navigation.\n     */\n    @OutgoingTransition(\n        activate = {PreviousState.class},\n        description = "Close menu and return to previous state"\n    )\n    public boolean toPrevious() {\n        // Click close button or press ESC\n        return action.click(menuState.getCloseButton()).isSuccess() ||\n               action.type(Key.ESC).isSuccess(); \n    }\n    \n    @IncomingTransition\n    public boolean verifyArrival() {\n        return action.find(menuState.getMenuHeader()).isSuccess();\n    }\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"path-costs-and-pathfinding",children:"Path Costs and Pathfinding"}),"\n",(0,s.jsx)(t.p,{children:"Brobot uses a cost-based pathfinding system to automatically select the best path between states. Understanding path costs is essential for predictable navigation."}),"\n",(0,s.jsx)(t.h3,{id:"default-path-costs-v110",children:"Default Path Costs (v1.1.0+)"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"States"}),": Default pathCost = 1"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Transitions"}),": Default pathCost = 1"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Total Path Cost"})," = Sum of all state costs + Sum of all transition costs"]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"quick-example",children:"Quick Example"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:"@State  // Default state pathCost = 1\npublic class HomePage { }\n\n@State(pathCost = 5)  // Expensive state\npublic class SlowLoadingPage { }\n\n@TransitionSet(state = HomePage.class)\npublic class HomeTransitions {\n\n    @OutgoingTransition(to = Settings.class)  // Default pathCost = 1\n    public boolean normalRoute() { ... }\n\n    @OutgoingTransition(to = Settings.class, pathCost = 0)  // Free transition\n    public boolean keyboardShortcut() { ... }\n\n    @OutgoingTransition(to = Settings.class, pathCost = 10)  // Expensive fallback\n    public boolean slowRoute() { ... }\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["When multiple paths exist, Brobot automatically selects the path with the ",(0,s.jsx)(t.strong,{children:"lowest total cost"}),"."]}),"\n",(0,s.jsx)(t.h3,{id:"learn-more",children:"Learn More"}),"\n",(0,s.jsxs)(t.p,{children:["For comprehensive documentation on pathfinding, cost calculation, and advanced patterns, see the ",(0,s.jsx)(t.a,{href:"/docs/core-library/guides/pathfinding-and-costs",children:(0,s.jsx)(t.strong,{children:"Pathfinding and Path Costs Guide"})}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Use descriptive method names"})," like ",(0,s.jsx)(t.code,{children:"toMenu()"}),", ",(0,s.jsx)(t.code,{children:"toHomepage()"})," for outgoing transitions"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Verify critical elements"})," in IncomingTransition to ensure state is truly active"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Set appropriate path costs"})," - use defaults for normal operations, 0 for free, higher for fallbacks"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Keep transitions focused"})," - each method should do one thing well"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Minimize dependencies"})," - each transition class should only need its own state"]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(t.p,{children:"The @TransitionSet pattern with @OutgoingTransition and @IncomingTransition provides a clean, maintainable way to define state transitions in Brobot. By grouping a state's verification logic (IncomingTransition) with its outgoing navigation logic (OutgoingTransition) in a single class, you achieve:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Better cohesion"}),": Outgoing transitions use the current state's images"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Fewer dependencies"}),": Each transition class only needs its own state"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Clearer organization"}),": Navigation logic flows naturally from each state"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Easier maintenance"}),": All transitions for a state are in one place"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"This pattern makes your automation code easier to understand, test, and maintain."})]})}function h(n={}){const{wrapper:t}={...(0,a.R)(),...n.components};return t?(0,s.jsx)(t,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}}}]);
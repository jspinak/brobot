"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1144],{28453:(e,t,i)=>{i.d(t,{R:()=>o,x:()=>r});var n=i(96540);const a={},s=n.createContext(a);function o(e){const t=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),n.createElement(s.Provider,{value:t},e.children)}},51380:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"architecture-notes/domain specific language","title":"Transitions with the BrobotApp","description":"Problem: Defining GUI Processes Visually","source":"@site/versioned_docs/version-1.0.6/architecture-notes/domain specific language.md","sourceDirName":"architecture-notes","slug":"/architecture-notes/domain specific language","permalink":"/brobot/docs/1.0.6/architecture-notes/domain specific language","draft":false,"unlisted":false,"editUrl":"https://github.com/jspinak/brobot/edit/main/docs/versioned_docs/version-1.0.6/architecture-notes/domain specific language.md","tags":[],"version":"1.0.6","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"docSidebar","previous":{"title":"BrobotApp","permalink":"/brobot/docs/1.0.6/architecture-notes/repositories"}}');var a=i(74848),s=i(28453);const o={sidebar_position:4},r="Transitions with the BrobotApp",c={},d=[{value:"Problem: Defining GUI Processes Visually",id:"problem-defining-gui-processes-visually",level:2},{value:"Serialization",id:"serialization",level:3},{value:"Domain Specific Languages",id:"domain-specific-languages",level:3}];function l(e){const t={h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"transitions-with-the-brobotapp",children:"Transitions with the BrobotApp"})}),"\n",(0,a.jsx)(t.h2,{id:"problem-defining-gui-processes-visually",children:"Problem: Defining GUI Processes Visually"}),"\n",(0,a.jsx)(t.p,{children:"When using the web-based frontend app to build and edit the state structure, we need to\nbuild not only states but also transitions. Since transitions are methods, this requires\ndefining the transition logic visually. The transitions also need to be stored as objects in\nthe project's database."}),"\n",(0,a.jsx)(t.p,{children:"There are a variety of ways to accomplish this. The two main options I considered were\nusing a DSL and serialization. DSLs are impractical for the expressing the full power of Java.\nSerialization would allow for methods to be stored as code but introduces additional complexity."}),"\n",(0,a.jsx)(t.h3,{id:"serialization",children:"Serialization"}),"\n",(0,a.jsx)(t.p,{children:"Serialization involves converting complex object graphs, which may include nested objects, circular\nreferences, and various data types, into a format that can be stored or transmitted. When the structure\nof the objects changes over time, maintaining backward and forward compatibility can be challenging."}),"\n",(0,a.jsx)(t.h3,{id:"domain-specific-languages",children:"Domain Specific Languages"}),"\n",(0,a.jsx)(t.p,{children:"A Domain-Specific Language (DSL) is designed to be more intuitive and tailored to a specific problem domain.\nDSLs provide a higher level of abstraction, focusing on the specific tasks and concepts relevant to the\ndomain. This reduces the complexity by hiding the underlying implementation details. DSLs are often designed\nto be human-readable and closer to natural language, making them easier to understand and use. Changes in\nthe domain logic can be made more easily and with less risk of introducing errors, as the DSL abstracts\naway much of the complexity."}),"\n",(0,a.jsx)(t.p,{children:'I chose to use a DSL. To adapt a DSL to the Brobot framework, I decided to restrict the transition logic\nto collections of GUI actions without Java code. This fits with the concept of "processes as objects" espoused\nby the project and in general by model-based GUI automation. While limiting somewhat the expressiveness of\ntransitions, it simplifies the creation and maintenance of Transition and StateTransitions classes. Also, the extra\nflexibility provided by Java code is not entirely necessary in state transitions. The functionality\nprovided by programming constructs like if-else statements can be achieved with an appropriate state structure.\nFor example, a transition to the Island state in the game DoT may require recognizing the name of a\nvalid island type, which can be expressed as a boolean. A failed transition would cause the framework\nto search for a different path and execute a different series of transitions, the equivalent of the\nelse clause in an if-else statement. In most cases, building the state structure without complex\nprogramming logic is preferred.'})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}}}]);
"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9916],{24972:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>p,frontMatter:()=>c,metadata:()=>t,toc:()=>s});const t=JSON.parse('{"id":"core-library/guides/runtime-delegation-migration","title":"Runtime Delegation Migration Guide","description":"Overview","source":"@site/docs/03-core-library/guides/runtime-delegation-migration.md","sourceDirName":"03-core-library/guides","slug":"/core-library/guides/runtime-delegation-migration","permalink":"/brobot/docs/core-library/guides/runtime-delegation-migration","draft":false,"unlisted":false,"editUrl":"https://github.com/jspinak/brobot/edit/main/docs/docs/03-core-library/guides/runtime-delegation-migration.md","tags":[],"version":"current","sidebarPosition":20,"frontMatter":{"sidebar_position":20,"title":"Runtime Delegation Migration Guide"},"sidebar":"docSidebar","previous":{"title":"Annotations API","permalink":"/brobot/docs/core-library/guides/annotations"},"next":{"title":"ActionConfig Factory","permalink":"/brobot/docs/core-library/guides/action-config-factory"}}');var r=i(74848),o=i(28453);const c={sidebar_position:20,title:"Runtime Delegation Migration Guide"},l="Migrating from Runtime Delegation to Profile-Based Architecture",a={},s=[{value:"Overview",id:"overview",level:2},{value:"Current State: Runtime Delegation",id:"current-state-runtime-delegation",level:2},{value:"Target State: Profile-Based Architecture",id:"target-state-profile-based-architecture",level:2},{value:"Migration Steps",id:"migration-steps",level:2},{value:"Step 1: Identify Runtime Delegation Points",id:"step-1-identify-runtime-delegation-points",level:3},{value:"Step 2: Extract Interfaces",id:"step-2-extract-interfaces",level:3},{value:"Step 3: Create Profile-Specific Implementations",id:"step-3-create-profile-specific-implementations",level:3},{value:"Step 4: Update Dependency Injection",id:"step-4-update-dependency-injection",level:3},{value:"Step 5: Handle Complex Cases",id:"step-5-handle-complex-cases",level:3},{value:"Step 6: Gradual Migration",id:"step-6-gradual-migration",level:3},{value:"Migration Examples",id:"migration-examples",level:2},{value:"Example 1: Text Typing Migration",id:"example-1-text-typing-migration",level:3},{value:"Example 2: SceneProvider Migration",id:"example-2-sceneprovider-migration",level:3},{value:"Testing the Migration",id:"testing-the-migration",level:2},{value:"Verify Profile Activation",id:"verify-profile-activation",level:3},{value:"Verify Behavior",id:"verify-behavior",level:3},{value:"Benefits of Migration",id:"benefits-of-migration",level:2},{value:"Performance",id:"performance",level:3},{value:"Maintainability",id:"maintainability",level:3},{value:"Type Safety",id:"type-safety",level:3},{value:"Backward Compatibility",id:"backward-compatibility",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"migrating-from-runtime-delegation-to-profile-based-architecture",children:"Migrating from Runtime Delegation to Profile-Based Architecture"})}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsxs)(n.p,{children:["This guide helps you migrate from Brobot's runtime delegation pattern (checking ",(0,r.jsx)(n.code,{children:"brobotProperties.getCore().isMock()"})," at runtime) to the cleaner profile-based architecture using Spring profiles and dependency injection."]}),"\n",(0,r.jsx)(n.h2,{id:"current-state-runtime-delegation",children:"Current State: Runtime Delegation"}),"\n",(0,r.jsx)(n.p,{children:"Many Brobot components currently use runtime checks:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"// Note: BrobotProperties must be injected as a dependency\n@Autowired\nprivate BrobotProperties brobotProperties;\n\n// Example from legacy text typing implementation\npublic boolean type(String text) {\n    if (brobotProperties.getCore().isMock()) {\n        return true;  // Mock execution\n    }\n    // Live execution\n    return screen.type(text) == 1;\n}\n\n// Example from SingleClickExecutor.java\npublic boolean click(Location location) {\n    if (brobotProperties.getCore().isMock()) {\n        pause(brobotProperties.getCore().isMock()TimeClick);\n        return true;\n    }\n    // Live click implementation\n    mouse.click(location);\n    return true;\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"target-state-profile-based-architecture",children:"Target State: Profile-Based Architecture"}),"\n",(0,r.jsx)(n.p,{children:"Replace runtime checks with profile-specific implementations:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// Interface\npublic interface TypeTextExecutor {\n    boolean type(String text);\n}\n\n// Mock implementation\n@Component\n@Profile("test")\npublic class MockTypeTextExecutor implements TypeTextExecutor {\n    public boolean type(String text) {\n        pause(brobotProperties.getCore().isMock()TimeType);\n        return true;\n    }\n}\n\n// Live implementation\n@Component\n@Profile("!test")\npublic class LiveTypeTextExecutor implements TypeTextExecutor {\n    @Autowired\n    private Screen screen;\n    \n    public boolean type(String text) {\n        return screen.type(text) == 1;\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"migration-steps",children:"Migration Steps"}),"\n",(0,r.jsx)(n.h3,{id:"step-1-identify-runtime-delegation-points",children:"Step 1: Identify Runtime Delegation Points"}),"\n",(0,r.jsx)(n.p,{children:"Find all runtime checks in your codebase:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'# Find all runtime mock checks\ngrep -r "if.*FrameworkSettings\\.mock" --include="*.java"\ngrep -r "FrameworkSettings\\.mock\\s*\\?" --include="*.java"\n'})}),"\n",(0,r.jsx)(n.p,{children:"Common locations:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Text typing implementations"}),"\n",(0,r.jsx)(n.li,{children:"Click execution components"}),"\n",(0,r.jsx)(n.li,{children:"Mouse wheel scrolling components"}),"\n",(0,r.jsx)(n.li,{children:"Scene provider components"}),"\n",(0,r.jsx)(n.li,{children:"Drag coordinate calculators"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"step-2-extract-interfaces",children:"Step 2: Extract Interfaces"}),"\n",(0,r.jsx)(n.p,{children:"For each class with runtime delegation, extract an interface:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"// Before: SingleClickExecutor with runtime check\npublic class SingleClickExecutor {\n    public boolean click(Location location) {\n        if (brobotProperties.getCore().isMock()) {\n            return mockClick(location);\n        }\n        return liveClick(location);\n    }\n}\n\n// After: Extract interface\npublic interface ClickExecutor {\n    boolean click(Location location);\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"step-3-create-profile-specific-implementations",children:"Step 3: Create Profile-Specific Implementations"}),"\n",(0,r.jsx)(n.p,{children:"Split the implementation into profile-specific classes:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Component\n@Profile("test")\n@Slf4j\npublic class MockClickExecutor implements ClickExecutor {\n    \n    @Override\n    public boolean click(Location location) {\n        log.debug("Mock click at {}", location);\n        pause(brobotProperties.getCore().isMock()TimeClick);\n        return true;\n    }\n    \n    private void pause(double seconds) {\n        try {\n            Thread.sleep((long)(seconds * 1000));\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n\n@Component\n@Profile("!test")\n@RequiredArgsConstructor\n@Slf4j\npublic class LiveClickExecutor implements ClickExecutor {\n    \n    private final Mouse mouse;\n    \n    @Override\n    public boolean click(Location location) {\n        log.debug("Live click at {}", location);\n        mouse.move(location);\n        mouse.click();\n        return true;\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"step-4-update-dependency-injection",children:"Step 4: Update Dependency Injection"}),"\n",(0,r.jsx)(n.p,{children:"Replace direct instantiation with dependency injection:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"// Before\npublic class Action {\n    private final SingleClickExecutor clickExecutor = new SingleClickExecutor();\n    \n    public boolean click(Location location) {\n        return clickExecutor.click(location);\n    }\n}\n\n// After\n@Component\n@RequiredArgsConstructor\npublic class Action {\n    private final ClickExecutor clickExecutor;  // Injected based on profile\n    \n    public boolean click(Location location) {\n        return clickExecutor.click(location);\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"step-5-handle-complex-cases",children:"Step 5: Handle Complex Cases"}),"\n",(0,r.jsx)(n.p,{children:"For classes with multiple responsibilities, use composition:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"// Complex class with multiple mock checks\npublic class ActionExecutor {\n    public ActionResult execute(ActionConfig config, ObjectCollection targets) {\n        if (brobotProperties.getCore().isMock()) {\n            // Mock: find\n            if (config instanceof PatternFindOptions) {\n                return mockFind(targets);\n            }\n            // Mock: click\n            if (config instanceof ClickOptions) {\n                return mockClick(targets);\n            }\n        } else {\n            // Live execution with multiple branches\n        }\n    }\n}\n\n// Refactor using Strategy pattern\n@Component\n@RequiredArgsConstructor\npublic class ActionExecutor {\n    private final Map<Class<?>, ActionStrategy> strategies;\n    \n    @PostConstruct\n    public void init() {\n        // Strategies are injected based on profile\n    }\n    \n    public ActionResult execute(ActionConfig config, ObjectCollection targets) {\n        ActionStrategy strategy = strategies.get(config.getClass());\n        return strategy.execute(config, targets);\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"step-6-gradual-migration",children:"Step 6: Gradual Migration"}),"\n",(0,r.jsx)(n.p,{children:"You don't need to migrate everything at once. Use a hybrid approach:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"@Component\n@RequiredArgsConstructor\npublic class HybridExecutor {\n    \n    @Autowired(required = false)\n    private MockExecutor mockExecutor;  // Only exists in test profile\n    \n    @Autowired(required = false)\n    private LiveExecutor liveExecutor;  // Only exists in non-test profile\n    \n    public boolean execute() {\n        // Fallback to runtime check if needed\n        if (mockExecutor != null) {\n            return mockExecutor.execute();\n        } else if (liveExecutor != null) {\n            return liveExecutor.execute();\n        } else {\n            // Legacy runtime check as fallback\n            return brobotProperties.getCore().isMock() ? \n                legacyMockExecute() : legacyLiveExecute();\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"migration-examples",children:"Migration Examples"}),"\n",(0,r.jsx)(n.h3,{id:"example-1-text-typing-migration",children:"Example 1: Text Typing Migration"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Before:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public class LegacyTextTyper {\n    public boolean type(String text) {\n        if (brobotProperties.getCore().isMock()) return true;\n        return screen.type(text) == 1;\n    }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"After:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// Interface\npublic interface TextTyper {\n    boolean type(String text);\n}\n\n// Implementations\n@Component\n@Profile("test")\npublic class MockTextTyper implements TextTyper {\n    public boolean type(String text) {\n        return true;\n    }\n}\n\n@Component\n@Profile("!test")\n@RequiredArgsConstructor\npublic class LiveTextTyper implements TextTyper {\n    private final Screen screen;\n    \n    public boolean type(String text) {\n        return screen.type(text) == 1;\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"example-2-sceneprovider-migration",children:"Example 2: SceneProvider Migration"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Before:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public class SceneProvider {\n    public Scene getScene() {\n        if (brobotProperties.getCore().isMock()) {\n            return mockSceneRepository.getRandomScene();\n        }\n        return screenCapture.captureScreen();\n    }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"After:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// Interface\npublic interface SceneProvider {\n    Scene getScene();\n}\n\n// Implementations\n@Component\n@Profile("test")\n@RequiredArgsConstructor\npublic class MockSceneProvider implements SceneProvider {\n    private final MockSceneRepository repository;\n    \n    public Scene getScene() {\n        return repository.getRandomScene();\n    }\n}\n\n@Component\n@Profile("!test")\n@RequiredArgsConstructor\npublic class LiveSceneProvider implements SceneProvider {\n    private final ScreenCapture screenCapture;\n    \n    public Scene getScene() {\n        return screenCapture.captureScreen();\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"testing-the-migration",children:"Testing the Migration"}),"\n",(0,r.jsx)(n.h3,{id:"verify-profile-activation",children:"Verify Profile Activation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Test\n@ActiveProfiles("test")\npublic void verifyMockImplementation() {\n    assertThat(executor).isInstanceOf(MockExecutor.class);\n}\n\n@Test\n@ActiveProfiles("live")\npublic void verifyLiveImplementation() {\n    assertThat(executor).isInstanceOf(LiveExecutor.class);\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"verify-behavior",children:"Verify Behavior"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@SpringBootTest\n@ActiveProfiles("test")\npublic class MigrationVerificationTest {\n    \n    @Autowired\n    private ClickExecutor clickExecutor;\n    \n    @Test\n    public void verifyNoRuntimeChecks() {\n        // Should use mock implementation without runtime checks\n        assertTrue(clickExecutor.click(new Location(0, 0)));\n        \n        // Verify no access to brobotProperties.getCore().isMock()\n        // in the execution path\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"benefits-of-migration",children:"Benefits of Migration"}),"\n",(0,r.jsx)(n.h3,{id:"performance",children:"Performance"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"No runtime overhead"}),": Eliminates conditional checks"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Better JVM optimization"}),": Static dispatch instead of dynamic"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reduced complexity"}),": Simpler execution paths"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"maintainability",children:"Maintainability"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Clear separation"}),": Test and production code separated"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Single responsibility"}),": Each class has one purpose"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Easier testing"}),": Mock and live implementations tested independently"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"type-safety",children:"Type Safety"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Compile-time verification"}),": Interface contracts enforced"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Better IDE support"}),": Profile-aware code completion"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reduced bugs"}),": No accidental mock code in production"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"backward-compatibility",children:"Backward Compatibility"}),"\n",(0,r.jsx)(n.p,{children:"The migration can be done gradually while maintaining backward compatibility:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"@Configuration\npublic class MigrationConfiguration {\n    \n    @Bean\n    @ConditionalOnMissingBean(ClickExecutor.class)\n    public ClickExecutor fallbackClickExecutor() {\n        // Provide legacy implementation if no profile-specific bean exists\n        return new LegacyClickExecutor();\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(n.p,{children:"Migrating from runtime delegation to profile-based architecture:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Improves performance"})," by eliminating runtime checks"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Enhances maintainability"})," through clear separation of concerns"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Increases reliability"})," with compile-time verification"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Simplifies testing"})," with isolated implementations"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The migration can be done incrementally, maintaining backward compatibility while progressively modernizing the codebase."})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>c,x:()=>l});var t=i(96540);const r={},o=t.createContext(r);function c(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);